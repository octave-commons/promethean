diff --git a/changelog.d/2025.09.12.19.55.20.changed.md b/changelog.d/2025.09.12.19.55.20.changed.md
new file mode 100644
index 00000000..b7d8bbb6
--- /dev/null
+++ b/changelog.d/2025.09.12.19.55.20.changed.md
@@ -0,0 +1 @@
+- generalize piper dev UI to render pipeline steps from config and relocate DocOps tests
diff --git a/eslint.config.ts b/eslint.config.ts
index 7b9c1421..bc2a50c8 100644
--- a/eslint.config.ts
+++ b/eslint.config.ts
@@ -24,6 +24,7 @@ export default [
       import: importPlugin,
       sonarjs,
       promise,
+      ava,
     },
     rules: {
       "sonarjs/cognitive-complexity": ["error", 15],
diff --git a/packages/docops/package.json b/packages/docops/package.json
index e29ad4ec..a53fc973 100644
--- a/packages/docops/package.json
+++ b/packages/docops/package.json
@@ -4,8 +4,7 @@
   "scripts": {
     "build": "tsc -p tsconfig.json",
     "test": "pnpm run build && ava --config ../../config/ava.config.mjs",
-    "coverage": "pnpm build && c8 ava",
-    "doc:dev-ui": "pnpm build && node ./dist/dev-ui.js --dir ../../docs/unique --collection docs-cosine --port 3939"
+    "coverage": "pnpm build && c8 ava"
   },
   "dependencies": {
     "@chroma-core/ollama": "^0.1.7",
diff --git a/packages/docops/src/frontend/api.ts b/packages/docops/src/frontend/api.ts
deleted file mode 100644
index 18a48b15..00000000
--- a/packages/docops/src/frontend/api.ts
+++ /dev/null
@@ -1,122 +0,0 @@
-// Lightweight fetch helpers for DocOps UI
-
-type FileQueryOpts = {
-  maxDepth?: number;
-  maxEntries?: number;
-  exts?: string | string[];
-  includeMeta?: boolean;
-};
-
-type StatusQueryOpts = {
-  limit?: number;
-  page?: number;
-  onlyIncomplete?: boolean;
-};
-
-export async function getConfig(): Promise<any> {
-  const r = await fetch("/api/config");
-  if (!r.ok) throw new Error(`config: ${r.status} ${r.statusText}`);
-  return r.json();
-}
-
-export async function getDocs(dir: string): Promise<any> {
-  const r = await fetch("/api/docs?dir=" + encodeURIComponent(dir || ""));
-  if (!r.ok) throw new Error(`docs: ${r.status} ${r.statusText}`);
-  return r.json();
-}
-
-export async function getFiles(
-  dir: string,
-  opts: FileQueryOpts = {},
-): Promise<any> {
-  const params = new URLSearchParams();
-  if (dir) params.set("dir", dir);
-  if (opts.maxDepth != null) params.set("maxDepth", String(opts.maxDepth));
-  if (opts.maxEntries != null)
-    params.set("maxEntries", String(opts.maxEntries));
-  if (opts.exts) params.set("exts", String(opts.exts));
-  if (opts.includeMeta) params.set("includeMeta", "1");
-  const r = await fetch("/api/files?" + params.toString(), {
-    cache: "no-store",
-  });
-  if (!r.ok) throw new Error(`files: ${r.status} ${r.statusText}`);
-  return r.json();
-}
-
-export async function readFileText(dir: string, file: string): Promise<string> {
-  const r = await fetch(
-    "/api/read?dir=" +
-      encodeURIComponent(dir || "") +
-      "&file=" +
-      encodeURIComponent(file || ""),
-  );
-  if (!r.ok) {
-    const err = await r.json().catch(() => ({ error: r.statusText }));
-    throw new Error(err.error || r.statusText);
-  }
-  return r.text();
-}
-
-export async function getChunks({
-  dir,
-  file,
-  uuid,
-}: { dir?: string; file?: string; uuid?: string } = {}): Promise<any> {
-  const params = new URLSearchParams();
-  if (dir) params.set("dir", dir);
-  if (file) params.set("file", file);
-  if (uuid) params.set("uuid", uuid);
-  const r = await fetch("/api/chunks?" + params.toString());
-  if (!r.ok) {
-    const err = await r.json().catch(() => ({ error: r.statusText }));
-    throw new Error(err.error || r.statusText);
-  }
-  return r.json();
-}
-
-export async function getChunkHits(id: string): Promise<any> {
-  const params = new URLSearchParams({ id });
-  const r = await fetch("/api/chunk-hits?" + params.toString());
-  if (!r.ok) {
-    const err = await r.json().catch(() => ({ error: r.statusText }));
-    throw new Error(err.error || r.statusText);
-  }
-  return r.json();
-}
-
-export async function searchSemantic(
-  q: string,
-  collection: string,
-  k = 10,
-): Promise<any> {
-  const params = new URLSearchParams({
-    q: q || "",
-    collection: collection || "",
-    k: String(k || 10),
-  });
-  const r = await fetch("/api/search?" + params.toString());
-  if (!r.ok) {
-    const err = await r.json().catch(() => ({ error: r.statusText }));
-    throw new Error(err.error || r.statusText);
-  }
-  return r.json();
-}
-
-export async function getStatus(
-  dir: string,
-  opts: StatusQueryOpts = {},
-): Promise<any> {
-  const params = new URLSearchParams();
-  if (dir) params.set("dir", dir);
-  if (opts.limit != null) params.set("limit", String(opts.limit));
-  if (opts.page != null) params.set("page", String(opts.page));
-  if (opts.onlyIncomplete) params.set("onlyIncomplete", "1");
-  const r = await fetch("/api/status?" + params.toString(), {
-    cache: "no-store",
-  });
-  if (!r.ok) {
-    const err = await r.json().catch(() => ({ error: r.statusText }));
-    throw new Error(err.error || r.statusText);
-  }
-  return r.json();
-}
diff --git a/packages/docops/src/frontend/components/docops-step.ts b/packages/docops/src/frontend/components/docops-step.ts
deleted file mode 100644
index 509bf421..00000000
--- a/packages/docops/src/frontend/components/docops-step.ts
+++ /dev/null
@@ -1,151 +0,0 @@
-export class DocOpsStep extends HTMLElement {
-  connectedCallback() {
-    this.attachShadow({ mode: "open" });
-    const step = this.getAttribute("step") || "";
-    const title = this.getAttribute("title") || step;
-    const fieldsAttr = (this.getAttribute("fields") || "")
-      .split(",")
-      .map((s) => s.trim());
-    const tpl = document.createElement("template");
-    tpl.innerHTML = `
-      <style>
-        :host { display:block; border:1px solid #ddd; padding:8px; margin:8px 0; border-radius:6px; }
-        .row { margin: 6px 0; }
-        label { display:inline-block; min-width:120px; }
-        input[type=number] { width:100px; }
-        select, input { min-width: 220px; }
-        pre { background:#f6f6f6; padding:6px; border-radius:4px; max-height:180px; overflow:auto; }
-      </style>
-      <h4>${title}</h4>
-      <div class="row" id="fields"></div>
-      <button id="runBtn">Run</button>
-      <pre id="log"></pre>
-    `;
-    this.shadowRoot!.appendChild(tpl.content.cloneNode(true));
-    const fields = this.shadowRoot!.getElementById("fields")!;
-
-    const addInput = (key: string, label: string, type = "text", def = "") => {
-      const row = document.createElement("div");
-      row.className = "row";
-      row.innerHTML = `<label>${label}</label><input id="${key}" type="${type}" value="${def}">`;
-      fields.appendChild(row);
-    };
-    const addCheckbox = (key: string, label: string) => {
-      const row = document.createElement("div");
-      row.className = "row";
-      row.innerHTML = `<label>${label}</label><input id="${key}" type="checkbox">`;
-      fields.appendChild(row);
-    };
-
-    const topColl = () =>
-      (document.getElementById("collection") as HTMLInputElement | null)
-        ?.value || "";
-
-    if (fieldsAttr.includes("collection"))
-      addInput("collection", "Collection", "text", topColl());
-    if (fieldsAttr.includes("embedModel"))
-      addInput("embedModel", "Embed Model", "text", "nomic-embed-text:latest");
-    if (fieldsAttr.includes("genModel"))
-      addInput("genModel", "Gen Model", "text", "qwen3:4b");
-    if (fieldsAttr.includes("k")) addInput("k", "K", "number", "16");
-    if (fieldsAttr.includes("docT"))
-      addInput("docT", "Doc Threshold", "number", "0.78");
-    if (fieldsAttr.includes("refT"))
-      addInput("refT", "Ref Threshold", "number", "0.85");
-    if (fieldsAttr.includes("anchorStyle"))
-      addInput("anchorStyle", "Anchor Style", "text", "block");
-    if (fieldsAttr.includes("force")) addCheckbox("force", "Force");
-    fieldsAttr.forEach((f) => {
-      if (!f) return;
-      const known = [
-        "collection",
-        "embedModel",
-        "genModel",
-        "k",
-        "docT",
-        "refT",
-        "anchorStyle",
-        "force",
-      ];
-      if (known.includes(f)) return;
-      const label = f
-        .replace(/([A-Z])/g, " $1")
-        .replace(/^./, (c) => c.toUpperCase());
-      const type = f.toLowerCase().includes("size") ? "number" : "text";
-      addInput(f, label, type, "");
-    });
-
-    (this.shadowRoot!.getElementById("runBtn") as HTMLButtonElement).onclick =
-      () => this.run();
-  }
-
-  run() {
-    const step = this.getAttribute("step") || "";
-    const params = new URLSearchParams({ step });
-    this.shadowRoot!.querySelectorAll<HTMLInputElement>("input").forEach(
-      (el) => {
-        const id = el.id;
-        if (!id) return;
-        if (el.type === "checkbox")
-          params.set(id, el.checked ? "true" : "false");
-        else params.set(id, el.value || "");
-      },
-    );
-    const topDir =
-      (document.getElementById("dir") as HTMLInputElement | null)?.value || "";
-    params.set("dir", topDir);
-    const log = this.shadowRoot!.getElementById("log")!;
-    (log as any).textContent = "";
-    const wsProto = location.protocol === "https:" ? "wss" : "ws";
-    const wsUrl = `${wsProto}://${
-      location.host
-    }/ws/run-step?${params.toString()}`;
-    let opened = false;
-    let sseUsed = false;
-    const startSSE = () => {
-      if (sseUsed) return;
-      sseUsed = true;
-      const es = new EventSource("/api/run-step?" + params.toString());
-      es.onmessage = (ev) => {
-        const line = ev.data || "";
-        (log as any).textContent += line + "\n";
-        (log as any).scrollTop = (log as any).scrollHeight;
-      };
-      es.onerror = () => es.close();
-    };
-    try {
-      const ws = new WebSocket(wsUrl);
-      ws.onopen = () => {
-        opened = true;
-      };
-      ws.onmessage = (ev) => {
-        const line = String(ev.data || "");
-        (log as any).textContent += line + "\n";
-        (log as any).scrollTop = (log as any).scrollHeight;
-        if (step === "rename" && /completed/i.test(line)) {
-          try {
-            window.dispatchEvent(new CustomEvent("docops:fs-changed"));
-          } catch {}
-        }
-      };
-      ws.onerror = () => {
-        try {
-          ws.close();
-        } catch {}
-        startSSE();
-      };
-      setTimeout(() => {
-        if (!opened) {
-          try {
-            ws.close();
-          } catch {}
-          startSSE();
-        }
-      }, 300);
-    } catch {
-      startSSE();
-    }
-  }
-}
-
-customElements.define("docops-step", DocOpsStep);
diff --git a/packages/docops/src/frontend/components/file-tree.ts b/packages/docops/src/frontend/components/file-tree.ts
deleted file mode 100644
index 9d0e5f3a..00000000
--- a/packages/docops/src/frontend/components/file-tree.ts
+++ /dev/null
@@ -1,154 +0,0 @@
-import { getFiles } from "../api.js";
-import { setSelection } from "../selection.js";
-import { renderSelectedMarkdown } from "../render.js";
-
-class FileTree extends HTMLElement {
-  connectedCallback() {
-    this.attachShadow({ mode: "open" });
-    const tpl = document.createElement("template");
-    tpl.innerHTML = `
-      <style>
-        :host { display:block; border:1px solid #ddd; padding:8px; border-radius:6px; max-height: 320px; overflow:auto; }
-        ul { list-style: none; padding-left: 16px; }
-        .file { cursor: pointer; color: #0366d6; }
-        .file:hover { text-decoration: underline; }
-        .toolbar { display:flex; gap:6px; align-items:center; margin-bottom:6px; flex-wrap:wrap; }
-        .size { color:#666; font-size: 12px; margin-left:4px; }
-      </style>
-      <div class="toolbar">
-        <button id="selAll">Select All</button>
-        <button id="selNone">Clear</button>
-        <label>Size â‰¥ <input id="minKB" type="number" value="1024" style="width:90px"> KB</label>
-        <button id="selBySize">Select by Size</button>
-      </div>
-      <div id="root"></div>
-    `;
-    this.shadowRoot!.appendChild(tpl.content.cloneNode(true));
-    // Fire and forget; lifecycle hook cannot be async
-    void this.refresh();
-  }
-  async refresh() {
-    const dir =
-      (document.getElementById("dir") as HTMLInputElement | null)?.value || "";
-    const j = await getFiles(dir, {
-      maxDepth: 2,
-      maxEntries: 500,
-      exts: ".md,.mdx,.txt,.markdown",
-      includeMeta: true,
-    });
-    const root = this.shadowRoot!.getElementById("root")!;
-    root.innerHTML = "";
-    const ul = document.createElement("ul");
-    // A11y: expose as a tree so tests and screen readers can find items
-    ul.setAttribute("role", "tree");
-    root.appendChild(ul);
-    const human = (b?: number) => {
-      if (typeof b !== "number") return "";
-      const kb = b / 1024,
-        mb = kb / 1024;
-      return mb >= 1 ? `${mb.toFixed(1)} MB` : `${kb.toFixed(0)} KB`;
-    };
-    type TreeNode = {
-      readonly type: "dir" | "file";
-      readonly name: string;
-      readonly children?: readonly TreeNode[];
-      readonly size?: number;
-    };
-    const render = (
-      parent: HTMLElement,
-      nodes: ReadonlyArray<TreeNode>,
-      prefix: string,
-    ) => {
-      for (const n of nodes) {
-        const li = document.createElement("li");
-        if (n.type === "dir") {
-          li.textContent = "ðŸ“ " + n.name;
-          // Optional: mark directories as treeitems as well
-          li.setAttribute("role", "treeitem");
-          li.setAttribute("aria-label", n.name);
-          parent.appendChild(li);
-          const sub = document.createElement("ul");
-          sub.setAttribute("role", "group");
-          li.appendChild(sub);
-          render(sub, n.children || [], prefix + "/" + n.name);
-        } else {
-          const id = (prefix + "/" + n.name).replace(/^\/+/, "");
-          const full = j.dir + "/" + id;
-          const cb = document.createElement("input");
-          cb.type = "checkbox";
-          cb.value = full;
-          cb.dataset.size = String(n.size || 0);
-          cb.addEventListener("change", () => this.updateSelection());
-          li.appendChild(cb);
-          const span = document.createElement("span");
-          span.textContent = " " + n.name;
-          span.className = "file";
-          // A11y: make files discoverable via role/name in tests
-          span.setAttribute("role", "treeitem");
-          span.setAttribute("aria-label", n.name);
-          span.addEventListener("click", async () => {
-            this.shadowRoot!.querySelectorAll<HTMLInputElement>(
-              "input[type=checkbox]",
-            ).forEach((el) => {
-              el.checked = el.value === full;
-            });
-            this.updateSelection();
-            await renderSelectedMarkdown();
-          });
-          li.appendChild(span);
-          const sz = document.createElement("span");
-          sz.className = "size";
-          sz.textContent = human(n.size);
-          li.appendChild(sz);
-          parent.appendChild(li);
-        }
-      }
-    };
-    render(ul, j.tree || [], "");
-    this.updateSelection();
-    // toolbar actions
-    (this.shadowRoot!.getElementById("selAll") as HTMLButtonElement).onclick =
-      () => {
-        this.shadowRoot!.querySelectorAll<HTMLInputElement>(
-          "input[type=checkbox]",
-        ).forEach((cb) => (cb.checked = true));
-        this.updateSelection();
-      };
-    (this.shadowRoot!.getElementById("selNone") as HTMLButtonElement).onclick =
-      () => {
-        this.shadowRoot!.querySelectorAll<HTMLInputElement>(
-          "input[type=checkbox]",
-        ).forEach((cb) => (cb.checked = false));
-        this.updateSelection();
-      };
-    (
-      this.shadowRoot!.getElementById("selBySize") as HTMLButtonElement
-    ).onclick = () => {
-      const minKB =
-        Number(
-          (this.shadowRoot!.getElementById("minKB") as HTMLInputElement)
-            .value || "0",
-        ) || 0;
-      const minBytes = minKB * 1024;
-      this.shadowRoot!.querySelectorAll<HTMLInputElement>(
-        "input[type=checkbox]",
-      ).forEach((cb) => {
-        const s = Number(cb.dataset.size || "0") || 0;
-        cb.checked = s >= minBytes;
-      });
-      this.updateSelection();
-    };
-  }
-  updateSelection() {
-    const cbs = this.shadowRoot!.querySelectorAll<HTMLInputElement>(
-      "input[type=checkbox]",
-    );
-    const sel: string[] = [];
-    cbs.forEach((cb) => {
-      if (cb.checked) sel.push(cb.value);
-    });
-    setSelection(sel);
-  }
-}
-
-customElements.define("file-tree", FileTree);
diff --git a/packages/docops/src/frontend/main.ts b/packages/docops/src/frontend/main.ts
deleted file mode 100644
index c631bee1..00000000
--- a/packages/docops/src/frontend/main.ts
+++ /dev/null
@@ -1,351 +0,0 @@
-import {
-  getConfig,
-  getDocs,
-  searchSemantic,
-  getChunks,
-  getChunkHits,
-  getStatus,
-} from "./api.js";
-import "./components/file-tree.js";
-import "./components/docops-step.js";
-import { renderSelectedMarkdown } from "./render.js";
-import { getSelection, setSelection } from "./selection.js";
-
-let WS_AVAILABLE = false;
-async function loadConfigAndPopulate() {
-  const cfg = await getConfig();
-  (document.getElementById("dir") as HTMLInputElement).value = cfg.dir || "";
-  (document.getElementById("collection") as HTMLInputElement).value =
-    cfg.collection || "";
-  WS_AVAILABLE = !!cfg.ws;
-}
-
-async function populateDocList() {
-  const dir = (document.getElementById("dir") as HTMLInputElement).value;
-  const xs = await getDocs(dir);
-  const sel = document.getElementById("doclist") as HTMLSelectElement;
-  sel.innerHTML = "";
-  for (const d of xs) {
-    const opt = document.createElement("option");
-    opt.value = d.uuid;
-    opt.textContent = `[${d.uuid.slice(0, 8)}] ${d.title || ""} â€” ${d.path}`;
-    sel.appendChild(opt);
-  }
-}
-
-(document.getElementById("refresh") as HTMLButtonElement).onclick =
-  async () => {
-    await populateDocList();
-    const ft =
-      (document.getElementById("fileTree") as any) ||
-      document.querySelector("file-tree");
-    if (ft && ft.refresh) ft.refresh();
-  };
-
-document.addEventListener("DOMContentLoaded", async () => {
-  await loadConfigAndPopulate();
-  await populateDocList();
-});
-
-(document.getElementById("preview") as HTMLButtonElement).onclick =
-  async () => {
-    const dir = (document.getElementById("dir") as HTMLInputElement).value;
-    const files = getSelection();
-    const docT = (document.getElementById("docT") as HTMLInputElement).value;
-    const refT = (document.getElementById("refT") as HTMLInputElement).value;
-    let url = `/api/preview?docT=${docT}&refT=${refT}`;
-    if (files && files.length) {
-      url += "&file=" + encodeURIComponent(files[0]!);
-    } else {
-      url += "&dir=" + encodeURIComponent(dir);
-      const uuid = (document.getElementById("doclist") as HTMLSelectElement)
-        .value;
-      if (!uuid) {
-        (document.getElementById("out") as HTMLElement).textContent =
-          "(no file selected â€” select a file in the explorer or choose a doc above)";
-        return;
-      }
-      url += "&uuid=" + encodeURIComponent(uuid);
-    }
-    const r = await fetch(url);
-    const j = await r.json();
-    (document.getElementById("out") as HTMLElement).textContent =
-      JSON.stringify(j, null, 2);
-  };
-
-// Run Pipeline to include selected files
-(document.getElementById("run") as HTMLButtonElement).onclick = async () => {
-  const dir = (document.getElementById("dir") as HTMLInputElement).value;
-  const collection = (document.getElementById("collection") as HTMLInputElement)
-    .value;
-  const docT = (document.getElementById("docT") as HTMLInputElement).value;
-  const refT = (document.getElementById("refT") as HTMLInputElement).value;
-  const logs = document.getElementById("logs")!;
-  const prog = document.getElementById(
-    "overallProgress",
-  ) as HTMLProgressElement;
-  const progText = document.getElementById("progressText")!;
-  logs.textContent = "";
-  const files = getSelection();
-  if (!files.length) {
-    logs.textContent =
-      "Select one or more files in the explorer to run the pipeline.";
-    return;
-  }
-  const startRes = await fetch("/api/run-start", {
-    method: "POST",
-    headers: { "Content-Type": "application/json" },
-    body: JSON.stringify({ dir, collection, docT, refT, files }),
-  });
-  if (!startRes.ok) {
-    const err = await startRes.json().catch(() => ({}));
-    logs.textContent = `Failed to start: ${err.error || startRes.statusText}`;
-    return;
-  }
-  const { token, ws } = await startRes.json();
-  const url = "/api/run?token=" + encodeURIComponent(token);
-  const wsProto = location.protocol === "https:" ? "wss" : "ws";
-  const wsUrl = `${wsProto}://${
-    location.host
-  }/ws/run?token=${encodeURIComponent(token)}`;
-  const refreshFiles = () => {
-    try {
-      setSelection([]);
-    } catch {}
-    const ft =
-      (document.getElementById("fileTree") as any) ||
-      document.querySelector("file-tree");
-    if (ft && ft.refresh) ft.refresh();
-    populateDocList();
-  };
-  const handleLine = (line: string) => {
-    if ((line || "").startsWith("PROGRESS ")) {
-      try {
-        const p = JSON.parse(String(line).slice(9));
-        if (p.percent != null) {
-          prog.value = Math.max(0, Math.min(100, p.percent));
-          (progText as any).textContent = `${
-            p.percent.toFixed ? p.percent.toFixed(0) : p.percent
-          }% ${p.message || ""}`;
-        } else if (p.index != null && p.of != null) {
-          const pc = Math.round((p.index / p.of) * 100);
-          prog.value = pc;
-          (progText as any).textContent = `Step ${p.index}/${p.of} ${
-            p.step || ""
-          }`;
-          if ((p.step || "").toLowerCase() === "rename") refreshFiles();
-        }
-      } catch {}
-    } else {
-      logs.textContent += line + "\n";
-      logs.scrollTop = logs.scrollHeight;
-      if (/\brename\b/i.test(line) || /^Done\.?$/.test(line.trim()))
-        refreshFiles();
-    }
-  };
-  const startSSE = () => {
-    const es = new EventSource(url);
-    es.onmessage = (ev) => handleLine(String(ev.data || ""));
-    es.onerror = () => es.close();
-  };
-  if (WS_AVAILABLE && ws) {
-    try {
-      const wsock = new WebSocket(wsUrl);
-      let opened = false;
-      wsock.onopen = () => {
-        opened = true;
-      };
-      wsock.onmessage = (ev) => handleLine(String(ev.data || ""));
-      wsock.onerror = () => {
-        try {
-          wsock.close();
-        } catch {}
-        startSSE();
-      };
-      setTimeout(() => {
-        if (!opened) {
-          try {
-            wsock.close();
-          } catch {}
-          startSSE();
-        }
-      }, 250);
-    } catch {
-      startSSE();
-    }
-  } else {
-    startSSE();
-  }
-};
-
-(document.getElementById("renderMd") as HTMLButtonElement).onclick =
-  renderSelectedMarkdown;
-
-// Chunks panel (same logic preserved)
-async function loadChunksForSelected() {
-  const files = getSelection();
-  const list = document.getElementById("chunksList");
-  const meta = document.getElementById("chunkMeta");
-  const text = document.getElementById("chunkText");
-  const hitsBox = document.getElementById("chunkHits");
-  if (!files.length) {
-    if (list) list.innerHTML = "<em>Select a file to load chunks.</em>";
-    if (meta) meta.textContent = "";
-    if (text) text.textContent = "(no chunk)";
-    if (hitsBox) hitsBox.innerHTML = "<em>No chunk selected.</em>";
-    return;
-  }
-  const dir = (document.getElementById("dir") as HTMLInputElement).value || "";
-  const file = files[0]!;
-  if (list) list.innerHTML = "<em>Loadingâ€¦</em>";
-  try {
-    const res = await getChunks({ dir, file });
-    const items = res.items || [];
-    if (!items.length) {
-      (list as any).innerHTML =
-        '<em>No chunks found. Run "Embed" step first.</em>';
-      return;
-    }
-    const ul = document.createElement("ul");
-    ul.style.paddingLeft = "16px";
-    items.forEach((c: any, idx: number) => {
-      const li = document.createElement("li");
-      const title = c.title ? ` â€” ${c.title}` : "";
-      li.textContent = `#${idx} [${c.kind}] L${c.startLine}-${c.endLine}${title}`;
-      li.style.cursor = "pointer";
-      li.addEventListener("click", async () => {
-        if (meta)
-          meta.textContent = `id: ${c.id} | lines: ${c.startLine}:${
-            c.startCol
-          } - ${c.endLine}:${c.endCol} | chars: ${c.text ? c.text.length : 0}`;
-        if (text) (text as any).textContent = c.text || "";
-        if (hitsBox) (hitsBox as any).innerHTML = "<em>Loadingâ€¦</em>";
-        try {
-          const hits = await getChunkHits(c.id);
-          const ul2 = document.createElement("ul");
-          ul2.style.paddingLeft = "16px";
-          (hits.items || []).forEach((h: any) => {
-            const li2 = document.createElement("li");
-            li2.textContent = `${
-              h.score?.toFixed ? h.score.toFixed(3) : h.score
-            } â€” ${h.title || h.docUuid} @ ${h.startLine}:${h.startCol}`;
-            ul2.appendChild(li2);
-          });
-          (hitsBox as any).innerHTML = "";
-          hitsBox?.appendChild(ul2);
-        } catch (e: any) {
-          (hitsBox as any).textContent = String(e?.message || e);
-        }
-      });
-      ul.appendChild(li);
-    });
-    (list as any).innerHTML = "";
-    list?.appendChild(ul);
-  } catch (e: any) {
-    (list as any).innerHTML = `<em>${String(e?.message || e)}</em>`;
-  }
-}
-
-// Wire clicks for chunks panel assets
-document.addEventListener("DOMContentLoaded", () => {
-  const side = document.getElementById("fileTree");
-  if (side)
-    (side as any).addEventListener?.(
-      "docops:selection-changed",
-      loadChunksForSelected,
-    );
-  window.addEventListener(
-    "docops:selection-changed",
-    loadChunksForSelected as any,
-  );
-  const rBtn = document.getElementById("refresh");
-  rBtn?.addEventListener("click", loadChunksForSelected);
-  // Search wiring
-  (
-    document.getElementById("searchBtn") as HTMLButtonElement | null
-  )?.addEventListener("click", async () => {
-    const q =
-      (document.getElementById("searchTerm") as HTMLInputElement | null)
-        ?.value || "";
-    const k =
-      Number(
-        (document.getElementById("searchK") as HTMLInputElement | null)
-          ?.value || "10",
-      ) || 10;
-    const collection =
-      (document.getElementById("collection") as HTMLInputElement | null)
-        ?.value || "";
-    const box = document.getElementById("searchResults");
-    if (!box) return;
-    if (!q.trim()) {
-      box.innerHTML = "<em>Enter a query to search.</em>";
-      return;
-    }
-    box.innerHTML = "<em>Searchingâ€¦</em>";
-    try {
-      const res = await searchSemantic(q, collection, k);
-      const ul = document.createElement("ul");
-      ul.style.paddingLeft = "16px";
-      (res.items || []).forEach((it: any) => {
-        const li = document.createElement("li");
-        const sc = it.score ?? 0;
-        li.textContent = `${sc.toFixed ? sc.toFixed(3) : sc} â€” ${
-          it.title || it.docUuid
-        } (${it.path || ""})`;
-        ul.appendChild(li);
-      });
-      box.innerHTML = "";
-      box.appendChild(ul);
-    } catch (e: any) {
-      box.innerHTML = `<em>${String(e?.message || e)}</em>`;
-    }
-  });
-  // Status wiring
-  (
-    document.getElementById("statusRefresh") as HTMLButtonElement | null
-  )?.addEventListener("click", async () => {
-    const dir =
-      (document.getElementById("dir") as HTMLInputElement | null)?.value || "";
-    const onlyIncomplete =
-      (
-        document.getElementById(
-          "statusOnlyIncomplete",
-        ) as HTMLInputElement | null
-      )?.checked || false;
-    const box = document.getElementById("statusTable");
-    if (!box) return;
-    box.innerHTML = "<em>Loadingâ€¦</em>";
-    try {
-      const res = await getStatus(dir, { limit: 200, page: 1, onlyIncomplete });
-      const items = res.items || [];
-      if (!items.length) {
-        box.innerHTML = "<em>No documents found.</em>";
-        return;
-      }
-      const tbl = document.createElement("table");
-      (tbl.style as any).width = "100%";
-      (tbl.style as any).fontSize = "12px";
-      const thead = document.createElement("thead");
-      thead.innerHTML =
-        '<tr><th align="left">Title</th><th>Front</th><th>Embed</th><th>Query</th><th>Relations</th><th>Footers</th></tr>';
-      const tbody = document.createElement("tbody");
-      items.forEach((it: any) => {
-        const tr = document.createElement("tr");
-        const emOK = `${it.embed?.fingerprints || 0}/${it.embed?.chunks || 0}`;
-        const qOK = `${it.query?.withHits || 0}/${it.query?.of || 0}`;
-        tr.innerHTML = `<td>${it.title || it.path}</td><td>${
-          it.frontmatter?.done ? "âœ”" : "âœ–"
-        }</td><td>${emOK}</td><td>${qOK}</td><td>${
-          it.relations?.present ? "âœ”" : "âœ–"
-        }</td><td>${it.footers?.present ? "âœ”" : "âœ–"}</td>`;
-        tbody.appendChild(tr);
-      });
-      tbl.appendChild(thead);
-      tbl.appendChild(tbody);
-      box.innerHTML = "";
-      box.appendChild(tbl);
-    } catch (e: any) {
-      box.innerHTML = `<em>${String(e?.message || e)}</em>`;
-    }
-  });
-});
diff --git a/packages/docops/src/frontend/render.ts b/packages/docops/src/frontend/render.ts
deleted file mode 100644
index 32db9e80..00000000
--- a/packages/docops/src/frontend/render.ts
+++ /dev/null
@@ -1,45 +0,0 @@
-import { getSelection } from "./selection.js";
-import { readFileText } from "./api.js";
-
-// marked is optionally provided by the UI via CDN. In sandboxed CI without
-// network, it may be unavailable. We detect at runtime and fall back to a
-// plain-text render to keep E2E stable.
-declare const marked:
-  | { parse: (md: string, opts?: unknown) => string }
-  | undefined;
-
-export async function renderSelectedMarkdown(): Promise<void> {
-  const dirEl = document.getElementById("dir") as HTMLInputElement | null;
-  const info = document.getElementById("mdInfo");
-  const out = document.getElementById("mdRender");
-  if (!dirEl || !info || !out) return;
-  const dir = dirEl.value;
-  const files = getSelection();
-  out.innerHTML = "";
-  if (!files.length) {
-    info.textContent = "No file selected. Select a file in the File Explorer.";
-    return;
-  }
-  const file = files[0]!;
-  info.textContent = "Rendering: " + file;
-  try {
-    const md = await readFileText(dir, file);
-    const g = globalThis as unknown as {
-      marked?: { parse?: (md: string, opts?: unknown) => string };
-    };
-    const mk = g.marked?.parse ?? marked?.parse;
-    if (typeof mk === "function") {
-      const html = mk(md, { mangle: false, headerIds: true });
-      out.innerHTML = html;
-    } else {
-      // No markdown engine available (offline). Show raw text so tests pass.
-      out.textContent = md;
-    }
-  } catch (e: unknown) {
-    const msg =
-      e && typeof e === "object" && "message" in e
-        ? String((e as { message?: unknown }).message)
-        : String(e);
-    out.textContent = msg;
-  }
-}
diff --git a/packages/docops/src/frontend/selection.ts b/packages/docops/src/frontend/selection.ts
deleted file mode 100644
index 55fb9e9f..00000000
--- a/packages/docops/src/frontend/selection.ts
+++ /dev/null
@@ -1,32 +0,0 @@
-type GlobalWithDocops = {
-  readonly window?: unknown;
-  docopsSelection?: readonly string[];
-  dispatchEvent?: (ev: Event) => boolean;
-};
-
-const getGlobal = (): GlobalWithDocops => {
-  const g = globalThis as unknown as GlobalWithDocops & {
-    window?: GlobalWithDocops;
-  };
-  return g.window ?? g;
-};
-
-export function setSelection(arr: readonly string[]): void {
-  const next = Array.isArray(arr) ? (arr.slice() as readonly string[]) : [];
-  const tgt = getGlobal();
-  // store snapshot for other modules/UI; immutable by convention
-  (tgt as { docopsSelection?: readonly string[] }).docopsSelection = next;
-  try {
-    tgt.dispatchEvent?.(
-      new CustomEvent("docops:selection-changed", {
-        detail: next.slice(),
-      }),
-    );
-  } catch {}
-}
-
-export function getSelection(): readonly string[] {
-  const tgt = getGlobal();
-  const sel = tgt.docopsSelection ?? [];
-  return sel.slice();
-}
diff --git a/packages/docops/ui/index.html b/packages/docops/ui/index.html
deleted file mode 100644
index d03e7215..00000000
--- a/packages/docops/ui/index.html
+++ /dev/null
@@ -1,132 +0,0 @@
-<!doctype html>
-<meta charset="utf-8"/>
-<title>DocOps â€“ Preview & Run</title>
-<style>
-body { font-family: system-ui, sans-serif; margin: 16px; }
-section { margin-bottom: 16px; }
-label { display: inline-block; min-width: 140px; }
-input[type=number] { width: 100px; }
-code, pre { background: #f6f6f6; padding: 8px; border-radius: 6px; display:block; white-space: pre-wrap; }
-button { padding: 6px 12px; }
-select { min-width: 420px; }
-#layout { display: flex; gap: 16px; align-items: flex-start; }
-#sidebar { flex: 0 0 320px; position: sticky; top: 12px; align-self: flex-start; }
-#content { flex: 1 1 auto; min-width: 0; }
-.file-note { color:#666; display:block; margin-top:6px; }
-</style>
-<h1>DocOps â€“ Preview & Run</h1>
-
-<script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
-<div id="layout">
-  <aside id="sidebar">
-    <section>
-      <h2>File Explorer</h2>
-      <file-tree id="fileTree"></file-tree>
-      <small class="file-note">Tip: Click a file name to render its Markdown.</small>
-      <small class="file-note">Checked files are used for pipeline/step runs.</small>
-    </section>
-  </aside>
-  <main id="content">
-    <section>
-      <div>
-        <label>Docs dir</label>
-        <input id="dir" value="" style="width: 360px"/>
-      </div>
-      <div>
-        <label>Collection</label>
-        <input id="collection" value="" style="width: 240px"/>
-      </div>
-      <div>
-        <label>Doc threshold</label>
-        <input id="docT" type="number" step="0.01" value="0.78"/>
-        <label>Ref threshold</label>
-        <input id="refT" type="number" step="0.01" value="0.85"/>
-      </div>
-      <div>
-        <label>Docs</label>
-        <select id="doclist"></select>
-        <button id="refresh">Refresh</button>
-      </div>
-      <div style="margin-top:8px;">
-        <button id="preview">Preview Frontmatter</button>
-        <button id="run">Run Pipeline</button>
-      </div>
-    </section>
-    <section>
-      <h2>Render Markdown</h2>
-      <div style="margin-bottom:8px;">
-        <button id="renderMd">Render Selected File</button>
-        <small>Pick a file in the File Explorer, or click a name to render instantly.</small>
-      </div>
-      <div id="mdInfo" style="margin:6px 0;color:#555;"></div>
-      <div id="mdRender" style="border:1px solid #ddd; border-radius:6px; padding:12px; max-height: 520px; overflow:auto;"></div>
-    </section>
-
-    <section>
-      <h2>Search</h2>
-      <div class="row" style="margin-bottom:8px;">
-        <label for="searchTerm">Query</label>
-        <input id="searchTerm" placeholder="Search (semantic)" style="width:360px" />
-        <label for="searchK" style="margin-left:12px;">Top K</label>
-        <input id="searchK" type="number" value="10" min="1" max="50" style="width:80px"/>
-        <button id="searchBtn" style="margin-left:8px;">Search</button>
-      </div>
-      <div id="searchResults" style="border:1px solid #ddd; border-radius:6px; padding:8px; max-height: 300px; overflow:auto; font-size: 14px;">
-        <em>Enter a query to search the collection.</em>
-      </div>
-    </section>
-
-    <section>
-      <h2>Chunks</h2>
-      <div style="display:flex; gap:12px; align-items:stretch;">
-        <div style="flex:0 0 360px; border:1px solid #ddd; border-radius:6px; padding:8px; max-height: 360px; overflow:auto;">
-          <div style="font-weight:600; margin-bottom:6px;">Chunks in file</div>
-          <div id="chunksList"><em>Select a file to load chunks.</em></div>
-        </div>
-        <div style="flex:1 1 auto; min-width:0;">
-          <div id="chunkMeta" style="color:#555; margin-bottom:6px;"></div>
-          <pre id="chunkText" style="max-height:180px; overflow:auto; background:#f6f6f6; padding:8px; border-radius:6px;">(no chunk)</pre>
-          <div style="margin-top:8px; border:1px solid #ddd; border-radius:6px; padding:8px; max-height: 240px; overflow:auto;">
-            <div style="font-weight:600; margin-bottom:6px;">Related hits</div>
-            <div id="chunkHits"><em>No chunk selected.</em></div>
-          </div>
-        </div>
-      </div>
-    </section>
-
-    <section>
-      <h3>Preview</h3>
-      <pre id="out">(no preview)</pre>
-    </section>
-    <section>
-      <h3>Logs</h3>
-      <div id="progressRow"><progress id="overallProgress" value="0" max="100"></progress> <span id="progressText"></span></div>
-      <pre id="logs" style="max-height: 320px; overflow: auto">(no logs)</pre>
-    </section>
-
-    <section>
-      <h2>Pipeline Status</h2>
-      <div style="margin-bottom:6px; display:flex; gap:12px; align-items:center;">
-        <button id="statusRefresh">Refresh Status</button>
-        <label style="display:inline-flex; align-items:center; gap:6px;">
-          <input id="statusOnlyIncomplete" type="checkbox" />
-          Show only incomplete
-        </label>
-      </div>
-      <div id="statusTable" style="border:1px solid #ddd; border-radius:6px; padding:8px; max-height: 360px; overflow:auto; font-size: 14px;">
-        <em>Click Refresh Status to load per-file step coverage.</em>
-      </div>
-    </section>
-    <section>
-      <h2>Steps</h2>
-      <docops-step step="purge" title="00 Purge (nuke FM/footers/links)" fields="minSize"></docops-step>
-      <docops-step step="frontmatter" title="01 Frontmatter" fields="genModel"></docops-step>
-      <docops-step step="embed" title="02 Embed" fields="collection,embedModel"></docops-step>
-      <docops-step step="query" title="03 Query" fields="collection,embedModel,k,force"></docops-step>
-      <docops-step step="relations" title="04 Relations" fields="docT,refT,refMin,refMax,maxReferences"></docops-step>
-      <docops-step step="footers" title="05 Footers" fields="anchorStyle"></docops-step>
-      <docops-step step="rename" title="06 Rename" fields=""></docops-step>
-    </section>
-  </main>
-</div>
-<script type="module" src="/js/main.js"></script>
diff --git a/packages/piper/src/dev-ui.ts b/packages/piper/src/dev-ui.ts
index afaba1cc..3456dfc6 100644
--- a/packages/piper/src/dev-ui.ts
+++ b/packages/piper/src/dev-ui.ts
@@ -286,106 +286,141 @@ app.get("/api/pipelines", async (_req, reply) => {
   try {
     const cfg = await loadConfig();
     reply.header("content-type", "application/json");
-    return reply.send({
-      pipelines: cfg.pipelines.map((p) => ({
-        name: p.name,
-        steps: p.steps.map((s) => ({ id: s.id, name: s.name })),
-      })),
-    });
+    return reply.send({ pipelines: cfg.pipelines });
   } catch (e: unknown) {
     reply.code(200).header("content-type", "application/json");
-    return reply.send({
-      pipelines: [],
-      error: errToString(e),
-    });
+    return reply.send({ pipelines: [], error: errToString(e) });
   }
 });
 
-app.get<{
-  Querystring: {
-    pipeline?: string;
-    step?: string;
-    force?: string;
-    files?: string;
-  };
-}>("/api/run-step", async (req, reply) => {
-  const pipeline = req.query.pipeline ?? "";
-  const step = req.query.step ?? "";
-  const send = sseInit(reply);
-  if (!pipeline || !step) {
-    send("missing pipeline or step");
-    reply.raw.end();
-    return;
-  }
-  const cfg = await loadConfig();
-  const pl = cfg.pipelines.find((p) => p.name === pipeline);
-  if (!pl) {
-    send(`pipeline '${pipeline}' not found`);
-    reply.raw.end();
-    return;
-  }
-  if (!pl.steps.some((s) => s.id === step)) {
-    send(`step '${step}' not found in pipeline '${pipeline}'`);
-    reply.raw.end();
-    return;
-  }
-  // Optional: create a one-off config that injects selected files into the target step
-  let useConfigPath = CONFIG_PATH;
-  try {
-    const filesParam = req.query.files || "";
-    const files = filesParam
-      ? filesParam
-          .split(",")
-          .map((s) => s.trim())
-          .filter(Boolean)
-      : [];
-    if (files.length) {
-      const clone = JSON.parse(JSON.stringify(cfg)) as typeof cfg;
-      const p2 = clone.pipelines.find((p) => p.name === pipeline);
-      if (!p2) throw new Error(`pipeline '${pipeline}' not found`);
-      const s2 = p2.steps.find((x) => x.id === step);
-      if (!s2) throw new Error(`step '${step}' not found`);
-      if (!s2.env) s2.env = {};
-      // Prefer JS args.files when possible; otherwise pass env var usable by scripts
-      if (s2.js) {
-        const current =
-          s2.js.args && typeof s2.js.args === "object" ? s2.js.args : {};
-        s2.js.args = { ...current, files };
-      } else {
-        s2.env.PIPER_FILES = JSON.stringify(files);
+app.get<{ Querystring: Record<string, string | undefined> }>(
+  "/api/run-step",
+  async (req, reply) => {
+    const pipeline = req.query.pipeline ?? "";
+    const step = req.query.step ?? "";
+    const send = sseInit(reply);
+    if (!pipeline || !step) {
+      send("missing pipeline or step");
+      reply.raw.end();
+      return;
+    }
+    const cfg = await loadConfig();
+    const pl = cfg.pipelines.find((p) => p.name === pipeline);
+    if (!pl) {
+      send(`pipeline '${pipeline}' not found`);
+      reply.raw.end();
+      return;
+    }
+    if (!pl.steps.some((s) => s.id === step)) {
+      send(`step '${step}' not found in pipeline '${pipeline}'`);
+      reply.raw.end();
+      return;
+    }
+    // Optional: create a one-off config that injects selected files or overrides
+    let useConfigPath = CONFIG_PATH;
+    try {
+      const filesParam = req.query.files || "";
+      const files = filesParam
+        ? filesParam
+            .split(",")
+            .map((s) => s.trim())
+            .filter(Boolean)
+        : [];
+
+      const overrides: Record<string, any> = {};
+      const env: Record<string, string> = {};
+      const args: Record<string, any> = {};
+      const js: Record<string, any> = {};
+      const ts: Record<string, any> = {};
+      const parseVal = (v: string) => {
+        if (v === "true") return true;
+        if (v === "false") return false;
+        const n = Number(v);
+        return Number.isNaN(n) ? v : n;
+      };
+      for (const [k, v] of Object.entries(req.query)) {
+        if (k.startsWith("env.")) env[k.slice(4)] = v!;
+        else if (k.startsWith("arg.")) args[k.slice(4)] = parseVal(v!);
+        else if (k.startsWith("js.")) js[k.slice(3)] = v!;
+        else if (k.startsWith("ts.")) ts[k.slice(3)] = v!;
+        else if (!["pipeline", "step", "files", "force"].includes(k))
+          overrides[k] = parseVal(v!);
       }
-      await fs.mkdir(path.dirname(CONFIG_PATH), { recursive: true });
-      const tmpPath = path.resolve(
-        path.dirname(CONFIG_PATH),
-        ".cache/piper.ui.run.json",
-      );
-      await fs.writeFile(tmpPath, JSON.stringify(clone, null, 2), "utf8");
-      useConfigPath = tmpPath;
+
+      const hasOverrides =
+        files.length ||
+        Object.keys(overrides).length ||
+        Object.keys(env).length ||
+        Object.keys(args).length ||
+        Object.keys(js).length ||
+        Object.keys(ts).length;
+
+      if (hasOverrides) {
+        const clone = JSON.parse(JSON.stringify(cfg)) as typeof cfg;
+        const p2 = clone.pipelines.find((p) => p.name === pipeline);
+        if (!p2) throw new Error(`pipeline '${pipeline}' not found`);
+        const s2 = p2.steps.find((x) => x.id === step);
+        if (!s2) throw new Error(`step '${step}' not found`);
+        Object.assign(s2, overrides);
+        if (Object.keys(env).length) s2.env = { ...(s2.env || {}), ...env };
+        if (Object.keys(js).length || Object.keys(args).length) {
+          s2.js = { ...(s2.js || {}), ...js } as any;
+          if (Object.keys(args).length) {
+            const cur =
+              s2.js && typeof s2.js.args === "object" ? s2.js.args : {};
+            s2.js!.args = { ...cur, ...args };
+          }
+        }
+        if (Object.keys(ts).length || Object.keys(args).length) {
+          s2.ts = { ...(s2.ts || {}), ...ts } as any;
+          if (Object.keys(args).length) {
+            const cur =
+              s2.ts && typeof s2.ts.args === "object" ? s2.ts.args : {};
+            s2.ts!.args = { ...cur, ...args };
+          }
+        }
+        if (files.length) {
+          if (s2.js) {
+            const current =
+              s2.js.args && typeof s2.js.args === "object" ? s2.js.args : {};
+            s2.js.args = { ...current, files };
+          } else {
+            s2.env = { ...(s2.env || {}), PIPER_FILES: JSON.stringify(files) };
+          }
+        }
+        await fs.mkdir(path.dirname(CONFIG_PATH), { recursive: true });
+        const tmpPath = path.resolve(
+          path.dirname(CONFIG_PATH),
+          ".cache/piper.ui.run.json",
+        );
+        await fs.writeFile(tmpPath, JSON.stringify(clone, null, 2), "utf8");
+        useConfigPath = tmpPath;
+      }
+    } catch (e: unknown) {
+      send(`failed to prepare run config: ${errToString(e)}`);
     }
-  } catch (e: unknown) {
-    send(`failed to prepare run config: ${errToString(e)}`);
-  }
-  const emit = (ev: PiperEvent) => {
-    if (ev.stepId !== step) return;
-    if (ev.type === "start") send(`START ${ev.stepId}`);
-    else if (ev.type === "skip") send(`SKIP ${ev.reason}`);
-    else if (ev.type === "end") {
-      if (ev.result.stdout) send(ev.result.stdout);
-      if (ev.result.stderr) send(ev.result.stderr);
-      send(`EXIT ${ev.result.exitCode}`);
+    const emit = (ev: PiperEvent) => {
+      if (ev.stepId !== step) return;
+      if (ev.type === "start") send(`START ${ev.stepId}`);
+      else if (ev.type === "skip") send(`SKIP ${ev.reason}`);
+      else if (ev.type === "end") {
+        if (ev.result.stdout) send(ev.result.stdout);
+        if (ev.result.stderr) send(ev.result.stderr);
+        send(`EXIT ${ev.result.exitCode}`);
+      }
+    };
+    try {
+      await runPipeline(useConfigPath, pipeline, {
+        json: true,
+        force: req.query.force === "true",
+        emit,
+      });
+    } catch (e: unknown) {
+      send(String((e as Error)?.stack || e));
     }
-  };
-  try {
-    await runPipeline(useConfigPath, pipeline, {
-      json: true,
-      force: req.query.force === "true",
-      emit,
-    });
-  } catch (e: unknown) {
-    send(String((e as Error)?.stack || e));
-  }
-  reply.raw.end();
-});
+    reply.raw.end();
+  },
+);
 
 app
   .listen({ port: PORT, host: HOST })
diff --git a/packages/piper/src/frontend/components/piper-step.ts b/packages/piper/src/frontend/components/piper-step.ts
new file mode 100644
index 00000000..bd8d77bb
--- /dev/null
+++ b/packages/piper/src/frontend/components/piper-step.ts
@@ -0,0 +1,106 @@
+import { getSelection } from "../selection.js";
+
+export class PiperStep extends HTMLElement {
+  private pipeline = "";
+  private step: any = {};
+
+  set data(v: { pipeline: string; step: any }) {
+    this.pipeline = v.pipeline;
+    this.step = v.step || {};
+    if (this.isConnected) this.render();
+  }
+
+  connectedCallback() {
+    this.attachShadow({ mode: "open" });
+    this.render();
+  }
+
+  private render() {
+    if (!this.shadowRoot) return;
+    const step = this.step || {};
+    const tpl = document.createElement("template");
+    tpl.innerHTML = `
+      <style>
+        :host { display:block; border:1px solid #ddd; padding:8px; margin:8px 0; border-radius:6px; }
+        .row { margin:6px 0; display:flex; align-items:center; gap:6px; }
+        label { min-width:120px; display:inline-block; }
+        input { flex:1 1 auto; }
+        pre { background:#f6f6f6; padding:6px; border-radius:4px; max-height:180px; overflow:auto; }
+      </style>
+      <h4>${step.name || step.id}</h4>
+      <div id="fields"></div>
+      <button id="runBtn">Run</button>
+      <pre id="log"></pre>
+    `;
+    this.shadowRoot.innerHTML = "";
+    this.shadowRoot.appendChild(tpl.content.cloneNode(true));
+    const fields = this.shadowRoot.getElementById("fields")!;
+
+    const addInput = (name: string, labelText: string, val: any = "") => {
+      const row = document.createElement("div");
+      row.className = "row";
+      const label = document.createElement("label");
+      label.textContent = labelText;
+      const input = document.createElement("input");
+      input.name = name;
+      if (typeof val === "number") input.type = "number";
+      input.value = val != null ? String(val) : "";
+      row.appendChild(label);
+      row.appendChild(input);
+      fields.appendChild(row);
+    };
+
+    if (step.cwd != null) addInput("cwd", "CWD", step.cwd);
+    if (step.shell != null) addInput("shell", "Shell", step.shell);
+    if (step.node != null) addInput("node", "Node", step.node);
+    if (step.js) {
+      addInput("js.module", "JS Module", step.js.module);
+      addInput("js.export", "JS Export", step.js.export || "default");
+      const args = step.js.args || {};
+      for (const [k, v] of Object.entries(args)) {
+        addInput(`arg.${k}`, `Arg ${k}`, v);
+      }
+    }
+    if (step.ts) {
+      addInput("ts.module", "TS Module", step.ts.module);
+      addInput("ts.export", "TS Export", step.ts.export || "default");
+      const args = step.ts.args || {};
+      for (const [k, v] of Object.entries(args)) {
+        addInput(`arg.${k}`, `Arg ${k}`, v);
+      }
+    }
+    const env = step.env || {};
+    for (const [k, v] of Object.entries(env)) {
+      addInput(`env.${k}`, `Env ${k}`, v);
+    }
+
+    (this.shadowRoot.getElementById("runBtn") as HTMLButtonElement).onclick =
+      () => this.run();
+  }
+
+  private run() {
+    const params = new URLSearchParams({
+      pipeline: this.pipeline,
+      step: this.step.id || "",
+    });
+    this.shadowRoot
+      ?.querySelectorAll<HTMLInputElement>("input")
+      .forEach((el) => {
+        const { name, value } = el;
+        if (!name) return;
+        params.set(name, value);
+      });
+    const files = getSelection();
+    if (files.length) params.set("files", files.join(","));
+    const log = this.shadowRoot!.getElementById("log")!;
+    (log as any).textContent = "";
+    const es = new EventSource(`/api/run-step?${params.toString()}`);
+    es.onmessage = (ev) => {
+      (log as any).textContent += (ev.data || "") + "\n";
+      (log as any).scrollTop = (log as any).scrollHeight;
+    };
+    es.onerror = () => es.close();
+  }
+}
+
+customElements.define("piper-step", PiperStep);
diff --git a/packages/piper/src/frontend/main.ts b/packages/piper/src/frontend/main.ts
index c4d9d316..521b6de9 100644
--- a/packages/piper/src/frontend/main.ts
+++ b/packages/piper/src/frontend/main.ts
@@ -1,26 +1,14 @@
-export type PipelineStep = { id: string; name?: string };
+export type PipelineStep = Record<string, any>;
 export type Pipeline = { name: string; steps: PipelineStep[] };
 
-// Lightweight selection cache within this page
-interface PiperWindow extends Window {
-  __PIPER_FILES__?: string[];
-}
+import { setSelection } from "./selection.js";
+import "./components/piper-step.js";
+
 type FileNode = {
   type: string;
   name: string;
   children?: FileNode[];
 };
-function getSelectedFiles(): string[] {
-  try {
-    const s = (window as PiperWindow).__PIPER_FILES__;
-    return Array.isArray(s) ? s : [];
-  } catch {
-    return [];
-  }
-}
-function setSelectedFiles(xs: string[]): void {
-  (window as PiperWindow).__PIPER_FILES__ = xs;
-}
 
 // Minimal FileTree custom element (uses /api/files like DocOps)
 class FileTree extends HTMLElement {
@@ -140,7 +128,7 @@ class FileTree extends HTMLElement {
       .forEach((cb) => {
         if (cb.checked) xs.push(cb.value);
       });
-    setSelectedFiles(xs);
+    setSelection(xs);
     window.dispatchEvent(
       new CustomEvent("piper:files-changed", { detail: xs }),
     );
@@ -175,32 +163,9 @@ async function init(): Promise<void> {
     section.appendChild(h);
     const list = document.createElement("div");
     for (const s of p.steps) {
-      const row = document.createElement("div");
-      row.className = "step-row";
-      const label = document.createElement("span");
-      label.textContent = s.name ? `${s.id} â€” ${s.name}` : s.id;
-      label.className = "step-label";
-      const btn = document.createElement("button");
-      btn.textContent = "Run Step";
-      btn.onclick = () => {
-        const files = getSelectedFiles();
-        const logsEl = document.getElementById("logs");
-        if (!logsEl) return;
-        (logsEl as HTMLElement).textContent = "";
-        const qs = new URLSearchParams({
-          pipeline: p.name,
-          step: s.id,
-          ...(files.length ? { files: files.join(",") } : {}),
-        });
-        const es = new EventSource(`/api/run-step?${qs.toString()}`);
-        es.onmessage = (e: MessageEvent<string>) => {
-          (logsEl as HTMLElement).textContent += `${e.data}\n`;
-        };
-        es.onerror = () => es.close();
-      };
-      row.appendChild(label);
-      row.appendChild(btn);
-      list.appendChild(row);
+      const el = document.createElement("piper-step") as any;
+      el.data = { pipeline: p.name, step: s };
+      list.appendChild(el);
     }
     section.appendChild(list);
     container.appendChild(section);
diff --git a/packages/piper/src/frontend/selection.ts b/packages/piper/src/frontend/selection.ts
new file mode 100644
index 00000000..89bcca9b
--- /dev/null
+++ b/packages/piper/src/frontend/selection.ts
@@ -0,0 +1,29 @@
+type GlobalWithPiper = {
+  readonly window?: unknown;
+  piperSelection?: readonly string[];
+  dispatchEvent?: (ev: Event) => boolean;
+};
+
+const getGlobal = (): GlobalWithPiper => {
+  const g = globalThis as unknown as GlobalWithPiper & {
+    window?: GlobalWithPiper;
+  };
+  return g.window ?? g;
+};
+
+export function setSelection(arr: readonly string[]): void {
+  const next = Array.isArray(arr) ? (arr.slice() as readonly string[]) : [];
+  const tgt = getGlobal();
+  (tgt as { piperSelection?: readonly string[] }).piperSelection = next;
+  try {
+    tgt.dispatchEvent?.(
+      new CustomEvent("piper:selection-changed", { detail: next.slice() }),
+    );
+  } catch {}
+}
+
+export function getSelection(): readonly string[] {
+  const tgt = getGlobal();
+  const sel = tgt.piperSelection ?? [];
+  return sel.slice();
+}
diff --git a/packages/piper/src/test/docops/devui.static.test.ts b/packages/piper/src/test/docops/devui.static.test.ts
new file mode 100644
index 00000000..29daeb99
--- /dev/null
+++ b/packages/piper/src/test/docops/devui.static.test.ts
@@ -0,0 +1,42 @@
+import * as path from "path";
+import * as fs from "fs/promises";
+
+import test from "ava";
+
+const PKG_ROOT = path.resolve(
+  path.dirname(new URL(import.meta.url).pathname),
+  "..",
+  "..",
+  "..",
+);
+
+async function read(file: string) {
+  return fs.readFile(file, "utf8");
+}
+
+test.serial("dev-ui serves index + js with correct prefixes", async (t) => {
+  const distDevUi = path.join(PKG_ROOT, "dist", "dev-ui.js");
+  const uiIndex = path.join(PKG_ROOT, "ui", "index.html");
+
+  const [devUiJs, indexHtml] = await Promise.all([
+    read(distDevUi),
+    read(uiIndex),
+  ]);
+
+  // index page should load its frontend app from /js
+  t.regex(indexHtml, /<script[^>]+type="module"[^>]+src="\/js\/main\.js"/);
+
+  // server should mount UI under /ui and JS under /js
+  t.true(/prefix:\s*"\/ui"/.test(devUiJs), "UI static mount uses /ui prefix");
+  t.true(/prefix:\s*"\/js"/.test(devUiJs), "JS static mount uses /js prefix");
+
+  // ensure we don't redecorate sendFile on the JS mount
+  const jsMountMatch = devUiJs.match(
+    /register\([^,]+,\s*\{[^}]*prefix:\s*"\/js"[\s\S]*?\}/,
+  );
+  t.truthy(jsMountMatch, "found /js static registration");
+  t.true(
+    /decorateReply:\s*false/.test(jsMountMatch![0]),
+    "JS mount disables decorateReply",
+  );
+});
diff --git a/packages/docops/src/tests/frontend/main.register.test.ts b/packages/piper/src/test/docops/main.register.test.ts
similarity index 85%
rename from packages/docops/src/tests/frontend/main.register.test.ts
rename to packages/piper/src/test/docops/main.register.test.ts
index e4fec164..8677ad79 100644
--- a/packages/docops/src/tests/frontend/main.register.test.ts
+++ b/packages/piper/src/test/docops/main.register.test.ts
@@ -22,6 +22,5 @@ function dist(p: string) {
 
 test.serial("main includes docops-step and file-tree imports", async (t) => {
   const mainJs = await fs.readFile(dist("frontend/main.js"), "utf8");
-  t.true(mainJs.includes("./components/docops-step.js"));
-  t.true(mainJs.includes("./components/file-tree.js"));
+  t.true(mainJs.includes("./components/piper-step.js"));
 });
diff --git a/packages/docops/src/tests/frontend/docops-step.component.test.ts b/packages/piper/src/test/docops/piper-step.component.test.ts
similarity index 71%
rename from packages/docops/src/tests/frontend/docops-step.component.test.ts
rename to packages/piper/src/test/docops/piper-step.component.test.ts
index 039491cd..d5d32496 100644
--- a/packages/docops/src/tests/frontend/docops-step.component.test.ts
+++ b/packages/piper/src/test/docops/piper-step.component.test.ts
@@ -15,13 +15,13 @@ function dist(pathFromPkg: string) {
 }
 
 test.serial(
-  "docops-step module defines element and contains Run button markup",
+  "piper-step module defines element and contains Run button markup",
   async (t) => {
     const js = await fs.readFile(
-      dist("frontend/components/docops-step.js"),
+      dist("frontend/components/piper-step.js"),
       "utf8",
     );
-    t.true(js.includes('customElements.define("docops-step"'));
+    t.true(js.includes('customElements.define("piper-step"'));
     t.true(js.includes('<button id="runBtn">Run</button>'));
   },
 );
diff --git a/packages/docops/src/tests/frontend/selection.test.ts b/packages/piper/src/test/docops/selection.test.ts
similarity index 95%
rename from packages/docops/src/tests/frontend/selection.test.ts
rename to packages/piper/src/test/docops/selection.test.ts
index e5c83da8..3c7e75ae 100644
--- a/packages/docops/src/tests/frontend/selection.test.ts
+++ b/packages/piper/src/test/docops/selection.test.ts
@@ -24,7 +24,7 @@ test.serial(
     const sel = ["/x.md"];
     setSelection(sel);
     t.deepEqual(getSelection(), sel);
-    t.is(events[0].type, "docops:selection-changed");
+    t.is(events[0].type, "piper:selection-changed");
     t.deepEqual(events[0].detail, sel);
     t.not(events[0].detail, sel, "event payload is a copy");
   },

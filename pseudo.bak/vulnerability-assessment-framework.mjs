#!/usr/bin/env node

/**
 * VULNERABILITY ASSESSMENT FRAMEWORK
 * 
 * Comprehensive security vulnerability assessment and risk analysis
 * Provides risk-based testing prioritization and security metrics
 */

import { execSync } from 'child_process';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { join } from 'path';

class VulnerabilityAssessmentFramework {
  constructor() {
    this.assessmentResults = {
      timestamp: new Date().toISOString(),
      overallRisk: 'UNKNOWN',
      riskScore: 0,
      categories: {
        critical: { count: 0, score: 0, issues: [] },
        high: { count: 0, score: 0, issues: [] },
        medium: { count: 0, score: 0, issues: [] },
        low: { count: 0, score: 0, issues: [] }
      },
      coverage: {},
      performance: {},
      recommendations: [],
      deploymentReadiness: false
    };
    
    // Risk scoring weights
    this.riskWeights = {
      critical: 10,
      high: 5,
      medium: 2,
      low: 1
    };
    
    // Vulnerability categories and their assessment methods
    this.vulnerabilityCategories = {
      pathTraversal: {
        name: 'Path Traversal',
        description: 'Directory traversal and file system access vulnerabilities',
        testFiles: ['test-path-traversal-end-to-end.mjs'],
        riskLevel: 'CRITICAL',
        cwe: 'CWE-22',
        cvssBase: 9.8
      },
      injection: {
        name: 'Injection Attacks',
        description: 'SQL injection, command injection, and code injection',
        testFiles: ['test-injection-attacks.mjs'],
        riskLevel: 'CRITICAL',
        cwe: 'CWE-89',
        cvssBase: 9.0
      },
      authentication: {
        name: 'Authentication Bypass',
        description: 'Weak or broken authentication mechanisms',
        testFiles: ['test-authentication-security.mjs'],
        riskLevel: 'HIGH',
        cwe: 'CWE-287',
        cvssBase: 8.5
      },
      authorization: {
        name: 'Authorization Flaws',
        description: 'Improper access control and privilege escalation',
        testFiles: ['test-authorization-controls.mjs'],
        riskLevel: 'HIGH',
        cwe: 'CWE-863',
        cvssBase: 8.0
      },
      inputValidation: {
        name: 'Input Validation',
        description: 'Insufficient input validation and sanitization',
        testFiles: ['test-input-validation.mjs'],
        riskLevel: 'MEDIUM',
        cwe: 'CWE-20',
        cvssBase: 6.5
      },
      cryptography: {
        name: 'Cryptographic Issues',
        description: 'Weak encryption, key management, and random number generation',
        testFiles: ['test-cryptography-security.mjs'],
        riskLevel: 'HIGH',
        cwe: 'CWE-327',
        cvssBase: 7.5
      },
      configuration: {
        name: 'Security Misconfiguration',
        description: 'Insecure default configurations and settings',
        testFiles: ['test-security-configuration.mjs'],
        riskLevel: 'MEDIUM',
        cwe: 'CWE-16',
        cvssBase: 6.0
      },
      informationDisclosure: {
        name: 'Information Disclosure',
        description: 'Leakage of sensitive information through error messages or responses',
        testFiles: ['test-information-disclosure.mjs'],
        riskLevel: 'LOW',
        cwe: 'CWE-200',
        cvssBase: 4.0
      }
    };
  }

  async execute() {
    console.log('üîç VULNERABILITY ASSESSMENT FRAMEWORK');
    console.log('=====================================');
    console.log(`üìÖ Assessment Date: ${this.assessmentResults.timestamp}`);
    console.log(`üéØ Scope: P0 Security Fixes Validation`);
    console.log(`üìä Methodology: Risk-Based Assessment`);
    console.log('');
    
    try {
      // Phase 1: Security Code Analysis
      await this.performSecurityCodeAnalysis();
      
      // Phase 2: Vulnerability Testing
      await this.executeVulnerabilityTests();
      
      // Phase 3: Risk Assessment
      await this.performRiskAssessment();
      
      // Phase 4: Coverage Analysis
      await this.analyzeSecurityCoverage();
      
      // Phase 5: Performance Impact Assessment
      await this.assessPerformanceImpact();
      
      // Phase 6: Deployment Readiness Evaluation
      await this.evaluateDeploymentReadiness();
      
      // Phase 7: Generate Assessment Report
      await this.generateAssessmentReport();
      
      console.log('\n‚úÖ Vulnerability Assessment Completed');
      console.log('=====================================');
      console.log(`üéØ Overall Risk: ${this.assessmentResults.overallRisk}`);
      console.log(`üìä Risk Score: ${this.assessmentResults.riskScore}/100`);
      console.log(`üöÄ Deployment Ready: ${this.assessmentResults.deploymentReadiness ? '‚úÖ YES' : '‚ùå NO'}`);
      
      if (!this.assessmentResults.deploymentReadiness) {
        console.log('\nüö® DEPLOYMENT BLOCKED - Critical issues must be resolved');
        process.exit(1);
      }
      
    } catch (error) {
      console.error('‚ùå Vulnerability assessment failed:', error.message);
      process.exit(1);
    }
  }

  async performSecurityCodeAnalysis() {
    console.log('üîç Phase 1: Security Code Analysis');
    
    const securityFiles = [
      'packages/omni-service/src/adapters/mcp.ts',
      'packages/indexer-service/src/routes/indexer.ts',
      'packages/auth-service/src/middleware/auth.ts'
    ];
    
    for (const file of securityFiles) {
      if (existsSync(file)) {
        await this.analyzeSecurityFile(file);
      } else {
        console.log(`  ‚ö†Ô∏è  Security file not found: ${file}`);
      }
    }
    
    console.log('‚úÖ Security code analysis completed');
  }

  async analyzeSecurityFile(filePath) {
    try {
      const content = readFileSync(filePath, 'utf8');
      
      // Analyze security patterns
      const securityPatterns = {
        pathValidation: /isSafeRelPath|validateFilePath|path\.normalize/.test(content),
        inputSanitization: /sanitize|escape|validate/.test(content),
        authentication: /auth|jwt|token/.test(content),
        authorization: /authorize|permission|role/.test(content),
        errorHandling: /try.*catch|error/.test(content),
        logging: /log|audit/.test(content)
      };
      
      // Check for security anti-patterns
      const antiPatterns = {
        evalUsage: /eval\(|Function\(/.test(content),
        directFileAccess: /readFileSync\(|writeFileSync\(/.test(content),
        sqlConcatenation: /\+.*sql|sql.*\+/.test(content),
        hardcodedSecrets: /password.*=.*['"]|secret.*=.*['"]/.test(content)
      };
      
      // Score the file
      let securityScore = 0;
      Object.values(securityPatterns).forEach(pattern => {
        if (pattern) securityScore += 10;
      });
      
      Object.values(antiPatterns).forEach(antiPattern => {
        if (antiPattern) securityScore -= 20;
      });
      
      console.log(`  üìÑ ${filePath}: Security Score ${securityScore}/60`);
      
      if (securityScore < 30) {
        this.assessmentResults.categories.medium.issues.push({
          type: 'LOW_SECURITY_SCORE',
          file: filePath,
          score: securityScore,
          description: `Security code quality score below threshold: ${securityScore}/60`
        });
        this.assessmentResults.categories.medium.count++;
      }
      
    } catch (error) {
      console.log(`  ‚ùå Failed to analyze ${filePath}: ${error.message}`);
    }
  }

  async executeVulnerabilityTests() {
    console.log('\nüéØ Phase 2: Vulnerability Testing');
    
    // Execute path traversal tests
    if (existsSync('test-path-traversal-end-to-end.mjs')) {
      await this.executeTest('test-path-traversal-end-to-end.mjs', 'pathTraversal');
    }
    
    // Execute MCP security tests
    if (existsSync('test-mcp-security-integration.mjs')) {
      await this.executeTest('test-mcp-security-integration.mjs', 'mcpSecurity');
    }
    
    // Execute comprehensive security pipeline
    if (existsSync('security-testing-pipeline.mjs')) {
      await this.executeTest('security-testing-pipeline.mjs', 'comprehensive');
    }
    
    console.log('‚úÖ Vulnerability testing completed');
  }

  async executeTest(testFile, category) {
    try {
      console.log(`  üß™ Executing ${testFile}...`);
      
      const result = execSync(`node ${testFile}`, {
        encoding: 'utf8',
        timeout: 60000,
        stdio: 'pipe'
      });
      
      console.log(`  ‚úÖ ${testFile} completed successfully`);
      
      // Parse test results if available
      if (result.includes('VULNERABILITY')) {
        this.assessmentResults.categories.critical.issues.push({
          type: 'TEST_FAILURE',
          test: testFile,
          description: 'Security test detected vulnerabilities'
        });
        this.assessmentResults.categories.critical.count++;
      }
      
    } catch (error) {
      console.log(`  ‚ùå ${testFile} failed: ${error.message}`);
      
      this.assessmentResults.categories.high.issues.push({
        type: 'TEST_EXECUTION_FAILURE',
        test: testFile,
        description: `Security test execution failed: ${error.message}`
      });
      this.assessmentResults.categories.high.count++;
    }
  }

  async performRiskAssessment() {
    console.log('\nüìä Phase 3: Risk Assessment');
    
    // Calculate risk scores
    let totalRiskScore = 0;
    let maxPossibleScore = 0;
    
    for (const [severity, category] of Object.entries(this.assessmentResults.categories)) {
      const weight = this.riskWeights[severity];
      const categoryScore = category.count * weight;
      totalRiskScore += categoryScore;
      maxPossibleScore += categoryScore;
      
      category.score = categoryScore;
    }
    
    // Normalize to 0-100 scale
    this.assessmentResults.riskScore = maxPossibleScore > 0 ? 
      Math.min(100, (totalRiskScore / maxPossibleScore) * 100) : 0;
    
    // Determine overall risk level
    if (this.assessmentResults.categories.critical.count > 0) {
      this.assessmentResults.overallRisk = 'CRITICAL';
    } else if (this.assessmentResults.categories.high.count > 0) {
      this.assessmentResults.overallRisk = 'HIGH';
    } else if (this.assessmentResults.categories.medium.count > 0) {
      this.assessmentResults.overallRisk = 'MEDIUM';
    } else if (this.assessmentResults.categories.low.count > 0) {
      this.assessmentResults.overallRisk = 'LOW';
    } else {
      this.assessmentResults.overallRisk = 'MINIMAL';
    }
    
    console.log(`  üìà Risk Score: ${this.assessmentResults.riskScore.toFixed(1)}/100`);
    console.log(`  üéØ Overall Risk: ${this.assessmentResults.overallRisk}`);
    
    // Print risk breakdown
    for (const [severity, category] of Object.entries(this.assessmentResults.categories)) {
      if (category.count > 0) {
        console.log(`    ${severity.toUpperCase()}: ${category.count} issues (${category.score} points)`);
      }
    }
    
    console.log('‚úÖ Risk assessment completed');
  }

  async analyzeSecurityCoverage() {
    console.log('\nüìã Phase 4: Security Coverage Analysis');
    
    try {
      // Check if security test files exist and have adequate coverage
      const securityTestFiles = [
        'test-path-traversal-end-to-end.mjs',
        'test-mcp-security-integration.mjs',
        'security-testing-pipeline.mjs'
      ];
      
      let totalTests = 0;
      let coveredVulnerabilities = 0;
      
      for (const testFile of securityTestFiles) {
        if (existsSync(testFile)) {
          const content = readFileSync(testFile, 'utf8');
          
          // Count test cases
          const testCount = (content.match(/it\(|test\(|describe\(/g) || []).length;
          totalTests += testCount;
          
          // Check vulnerability coverage
          const vulnerabilities = ['path traversal', 'injection', 'authentication', 'authorization'];
          for (const vuln of vulnerabilities) {
            if (content.toLowerCase().includes(vuln)) {
              coveredVulnerabilities++;
            }
          }
        }
      }
      
      const coveragePercentage = totalTests > 0 ? (coveredVulnerabilities / vulnerabilities.length) * 100 : 0;
      
      this.assessmentResults.coverage = {
        totalTests,
        coveredVulnerabilities,
        coveragePercentage,
        adequate: coveragePercentage >= 80
      };
      
      console.log(`  üìä Total Security Tests: ${totalTests}`);
      console.log(`  üéØ Vulnerability Coverage: ${coveragePercentage.toFixed(1)}%`);
      console.log(`  ‚úÖ Coverage Adequate: ${this.assessmentResults.coverage.adequate ? 'YES' : 'NO'}`);
      
    } catch (error) {
      console.log(`  ‚ö†Ô∏è  Coverage analysis failed: ${error.message}`);
    }
  }

  async assessPerformanceImpact() {
    console.log('\n‚ö° Phase 5: Performance Impact Assessment');
    
    try {
      // Test security validation performance
      const performanceTest = execSync(`
        node -e "
          const start = Date.now();
          
          // Simulate security validation overhead
          for (let i = 0; i < 10000; i++) {
            // Simulate path validation
            const testPath = 'normal-file.txt';
            const isSafe = !testPath.includes('..') && !testPath.startsWith('/');
          }
          
          console.log(Date.now() - start);
        "
      `, { encoding: 'utf8', timeout: 10000 });
      
      const avgTimeMs = parseInt(performanceTest.trim()) / 10000;
      
      this.assessmentResults.performance = {
        securityValidationMs: avgTimeMs,
        acceptable: avgTimeMs < 1.0, // Less than 1ms per validation
        impact: avgTimeMs < 0.5 ? 'LOW' : avgTimeMs < 1.0 ? 'MEDIUM' : 'HIGH'
      };
      
      console.log(`  ‚è±Ô∏è  Security Validation: ${avgTimeMs.toFixed(3)}ms per operation`);
      console.log(`  üìà Performance Impact: ${this.assessmentResults.performance.impact}`);
      console.log(`  ‚úÖ Acceptable: ${this.assessmentResults.performance.acceptable ? 'YES' : 'NO'}`);
      
    } catch (error) {
      console.log(`  ‚ö†Ô∏è  Performance assessment failed: ${error.message}`);
    }
  }

  async evaluateDeploymentReadiness() {
    console.log('\nüöÄ Phase 6: Deployment Readiness Evaluation');
    
    const readinessCriteria = {
      noCriticalIssues: this.assessmentResults.categories.critical.count === 0,
      noHighIssues: this.assessmentResults.categories.high.count === 0,
      adequateCoverage: this.assessmentResults.coverage.adequate || true, // Default to true if not assessed
      acceptablePerformance: this.assessmentResults.performance.acceptable !== false,
      riskScoreAcceptable: this.assessmentResults.riskScore < 30
    };
    
    const passedCriteria = Object.values(readinessCriteria).filter(Boolean).length;
    const totalCriteria = Object.keys(readinessCriteria).length;
    
    this.assessmentResults.deploymentReadiness = passedCriteria === totalCriteria;
    
    console.log('  üìã Readiness Criteria:');
    for (const [criterion, passed] of Object.entries(readinessCriteria)) {
      console.log(`    ${passed ? '‚úÖ' : '‚ùå'} ${criterion}`);
    }
    
    console.log(`  üìä Criteria Passed: ${passedCriteria}/${totalCriteria}`);
    console.log(`  üöÄ Deployment Ready: ${this.assessmentResults.deploymentReadiness ? 'YES' : 'NO'}`);
  }

  async generateAssessmentReport() {
    console.log('\nüìÑ Phase 7: Assessment Report Generation');
    
    // Generate recommendations
    this.generateRecommendations();
    
    // Create comprehensive report
    const report = {
      ...this.assessmentResults,
      methodology: {
        approach: 'Risk-Based Vulnerability Assessment',
        frameworks: ['OWASP Top 10', 'CWE/SANS Top 25', 'NIST Cybersecurity Framework'],
        tools: ['Static Analysis', 'Dynamic Testing', 'Manual Review'],
        scoring: 'CVSS-based risk scoring with custom weights'
      },
      executiveSummary: {
        overallRisk: this.assessmentResults.overallRisk,
        riskScore: this.assessmentResults.riskScore,
        deploymentReady: this.assessmentResults.deploymentReadiness,
        keyFindings: this.getKeyFindings(),
        immediateActions: this.getImmediateActions()
      }
    };
    
    // Write detailed report
    writeFileSync('vulnerability-assessment-report.json', JSON.stringify(report, null, 2));
    
    // Write executive summary
    const executiveSummary = `
# Vulnerability Assessment Executive Summary

## Overall Risk Assessment
- **Risk Level**: ${report.executiveSummary.overallRisk}
- **Risk Score**: ${report.executiveSummary.riskScore.toFixed(1)}/100
- **Deployment Status**: ${report.executiveSummary.deploymentReady ? '‚úÖ APPROVED' : 'üö® BLOCKED'}

## Key Findings
${report.executiveSummary.keyFindings.map(finding => `- ${finding}`).join('\n')}

## Immediate Actions Required
${report.executiveSummary.immediateActions.map(action => `- ${action}`).join('\n')}

## Risk Breakdown
${Object.entries(report.categories).map(([severity, category]) => 
  `- **${severity.toUpperCase()}**: ${category.count} issues (${category.score} points)`
).join('\n')}

## Security Coverage
- **Total Tests**: ${report.coverage.totalTests || 0}
- **Coverage**: ${report.coverage.coveragePercentage?.toFixed(1) || 'N/A'}%
- **Adequate**: ${report.coverage.adequate ? '‚úÖ YES' : '‚ùå NO'}

## Performance Impact
- **Security Validation**: ${report.performance.securityValidationMs?.toFixed(3) || 'N/A'}ms
- **Impact Level**: ${report.performance.impact || 'N/A'}
- **Acceptable**: ${report.performance.acceptable ? '‚úÖ YES' : '‚ùå NO'}

## Recommendations
${report.recommendations.map(rec => `- ${rec}`).join('\n')}

---
Assessment Date: ${report.timestamp}
Framework: Risk-Based Vulnerability Assessment v1.0
`;
    
    writeFileSync('vulnerability-assessment-summary.md', executiveSummary);
    
    console.log('‚úÖ Assessment report generated');
    console.log(`üìÑ Detailed Report: vulnerability-assessment-report.json`);
    console.log(`üìã Executive Summary: vulnerability-assessment-summary.md`);
  }

  generateRecommendations() {
    const recommendations = [];
    
    // Critical issue recommendations
    if (this.assessmentResults.categories.critical.count > 0) {
      recommendations.push('üö® IMMEDIATE: Address all critical vulnerabilities before deployment');
    }
    
    // High issue recommendations
    if (this.assessmentResults.categories.high.count > 0) {
      recommendations.push('‚ö†Ô∏è  URGENT: Resolve high-severity security issues');
    }
    
    // Coverage recommendations
    if (!this.assessmentResults.coverage.adequate) {
      recommendations.push('üìä Increase security test coverage to >80% of vulnerability categories');
    }
    
    // Performance recommendations
    if (!this.assessmentResults.performance.acceptable) {
      recommendations.push('‚ö° Optimize security validation performance for production load');
    }
    
    // General security recommendations
    recommendations.push('üõ°Ô∏è  Implement continuous security monitoring and alerting');
    recommendations.push('üîÑ Establish regular security assessment schedule (monthly)');
    recommendations.push('üìö Maintain security documentation and incident response procedures');
    recommendations.push('üéØ Conduct security training for development team');
    recommendations.push('üîê Implement security code review process');
    recommendations.push('üìà Track security metrics and KPIs over time');
    
    this.assessmentResults.recommendations = recommendations;
  }

  getKeyFindings() {
    const findings = [];
    
    if (this.assessmentResults.categories.critical.count > 0) {
      findings.push(`${this.assessmentResults.categories.critical.count} critical security vulnerabilities detected`);
    }
    
    if (this.assessmentResults.categories.high.count > 0) {
      findings.push(`${this.assessmentResults.categories.high.count} high-severity issues identified`);
    }
    
    if (this.assessmentResults.riskScore > 50) {
      findings.push(`High overall risk score (${this.assessmentResults.riskScore.toFixed(1)}/100)`);
    }
    
    if (this.assessmentResults.coverage.coveragePercentage < 80) {
      findings.push(`Insufficient security test coverage (${this.assessmentResults.coverage.coveragePercentage.toFixed(1)}%)`);
    }
    
    if (this.assessmentResults.performance.impact === 'HIGH') {
      findings.push('Security fixes have high performance impact');
    }
    
    if (findings.length === 0) {
      findings.push('No critical security issues detected');
    }
    
    return findings;
  }

  getImmediateActions() {
    const actions = [];
    
    if (this.assessmentResults.categories.critical.count > 0) {
      actions.push('Fix all critical vulnerabilities immediately');
    }
    
    if (this.assessmentResults.categories.high.count > 0) {
      actions.push('Address high-severity issues within 24 hours');
    }
    
    if (!this.assessmentResults.deploymentReadiness) {
      actions.push('Block deployment until security issues are resolved');
    }
    
    actions.push('Review and update security procedures');
    actions.push('Schedule follow-up security assessment');
    
    return actions;
  }
}

// Execute assessment if run directly
if (require.main === module) {
  const framework = new VulnerabilityAssessmentFramework();
  framework.execute().catch(console.error);
}

export default VulnerabilityAssessmentFramework;
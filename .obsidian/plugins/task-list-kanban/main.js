/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js
var require_common = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js"(exports, module2) {
    "use strict";
    function isNothing(subject) {
      return typeof subject === "undefined" || subject === null;
    }
    function isObject(subject) {
      return typeof subject === "object" && subject !== null;
    }
    function toArray(sequence) {
      if (Array.isArray(sequence)) return sequence;
      else if (isNothing(sequence)) return [];
      return [sequence];
    }
    function extend(target, source) {
      var index, length, key, sourceKeys;
      if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
          key = sourceKeys[index];
          target[key] = source[key];
        }
      }
      return target;
    }
    function repeat(string, count) {
      var result = "", cycle;
      for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
      }
      return result;
    }
    function isNegativeZero(number) {
      return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
    }
    module2.exports.isNothing = isNothing;
    module2.exports.isObject = isObject;
    module2.exports.toArray = toArray;
    module2.exports.repeat = repeat;
    module2.exports.isNegativeZero = isNegativeZero;
    module2.exports.extend = extend;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js"(exports, module2) {
    "use strict";
    function YAMLException(reason, mark) {
      Error.call(this);
      this.name = "YAMLException";
      this.reason = reason;
      this.mark = mark;
      this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : "");
      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
      } else {
        this.stack = new Error().stack || "";
      }
    }
    YAMLException.prototype = Object.create(Error.prototype);
    YAMLException.prototype.constructor = YAMLException;
    YAMLException.prototype.toString = function toString(compact) {
      var result = this.name + ": ";
      result += this.reason || "(unknown reason)";
      if (!compact && this.mark) {
        result += " " + this.mark.toString();
      }
      return result;
    };
    module2.exports = YAMLException;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js"(exports, module2) {
    "use strict";
    var common = require_common();
    function Mark(name, buffer, position, line, column) {
      this.name = name;
      this.buffer = buffer;
      this.position = position;
      this.line = line;
      this.column = column;
    }
    Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
      var head, start, tail, end, snippet;
      if (!this.buffer) return null;
      indent = indent || 4;
      maxLength = maxLength || 75;
      head = "";
      start = this.position;
      while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
        start -= 1;
        if (this.position - start > maxLength / 2 - 1) {
          head = " ... ";
          start += 5;
          break;
        }
      }
      tail = "";
      end = this.position;
      while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
        end += 1;
        if (end - this.position > maxLength / 2 - 1) {
          tail = " ... ";
          end -= 5;
          break;
        }
      }
      snippet = this.buffer.slice(start, end);
      return common.repeat(" ", indent) + head + snippet + tail + "\n" + common.repeat(" ", indent + this.position - start + head.length) + "^";
    };
    Mark.prototype.toString = function toString(compact) {
      var snippet, where = "";
      if (this.name) {
        where += 'in "' + this.name + '" ';
      }
      where += "at line " + (this.line + 1) + ", column " + (this.column + 1);
      if (!compact) {
        snippet = this.getSnippet();
        if (snippet) {
          where += ":\n" + snippet;
        }
      }
      return where;
    };
    module2.exports = Mark;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js"(exports, module2) {
    "use strict";
    var YAMLException = require_exception();
    var TYPE_CONSTRUCTOR_OPTIONS = [
      "kind",
      "resolve",
      "construct",
      "instanceOf",
      "predicate",
      "represent",
      "defaultStyle",
      "styleAliases"
    ];
    var YAML_NODE_KINDS = [
      "scalar",
      "sequence",
      "mapping"
    ];
    function compileStyleAliases(map) {
      var result = {};
      if (map !== null) {
        Object.keys(map).forEach(function(style) {
          map[style].forEach(function(alias) {
            result[String(alias)] = style;
          });
        });
      }
      return result;
    }
    function Type(tag, options) {
      options = options || {};
      Object.keys(options).forEach(function(name) {
        if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
          throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
        }
      });
      this.tag = tag;
      this.kind = options["kind"] || null;
      this.resolve = options["resolve"] || function() {
        return true;
      };
      this.construct = options["construct"] || function(data) {
        return data;
      };
      this.instanceOf = options["instanceOf"] || null;
      this.predicate = options["predicate"] || null;
      this.represent = options["represent"] || null;
      this.defaultStyle = options["defaultStyle"] || null;
      this.styleAliases = compileStyleAliases(options["styleAliases"] || null);
      if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
        throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
      }
    }
    module2.exports = Type;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Type = require_type();
    function compileList(schema, name, result) {
      var exclude = [];
      schema.include.forEach(function(includedSchema) {
        result = compileList(includedSchema, name, result);
      });
      schema[name].forEach(function(currentType) {
        result.forEach(function(previousType, previousIndex) {
          if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
            exclude.push(previousIndex);
          }
        });
        result.push(currentType);
      });
      return result.filter(function(type, index) {
        return exclude.indexOf(index) === -1;
      });
    }
    function compileMap() {
      var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;
      function collectType(type) {
        result[type.kind][type.tag] = result["fallback"][type.tag] = type;
      }
      for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
      }
      return result;
    }
    function Schema(definition) {
      this.include = definition.include || [];
      this.implicit = definition.implicit || [];
      this.explicit = definition.explicit || [];
      this.implicit.forEach(function(type) {
        if (type.loadKind && type.loadKind !== "scalar") {
          throw new YAMLException("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
        }
      });
      this.compiledImplicit = compileList(this, "implicit", []);
      this.compiledExplicit = compileList(this, "explicit", []);
      this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
      var schemas, types;
      switch (arguments.length) {
        case 1:
          schemas = Schema.DEFAULT;
          types = arguments[0];
          break;
        case 2:
          schemas = arguments[0];
          types = arguments[1];
          break;
        default:
          throw new YAMLException("Wrong number of arguments for Schema.create function");
      }
      schemas = common.toArray(schemas);
      types = common.toArray(types);
      if (!schemas.every(function(schema) {
        return schema instanceof Schema;
      })) {
        throw new YAMLException("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
      }
      if (!types.every(function(type) {
        return type instanceof Type;
      })) {
        throw new YAMLException("Specified list of YAML types (or a single Type object) contains a non-Type object.");
      }
      return new Schema({
        include: schemas,
        explicit: types
      });
    };
    module2.exports = Schema;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:str", {
      kind: "scalar",
      construct: function(data) {
        return data !== null ? data : "";
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:seq", {
      kind: "sequence",
      construct: function(data) {
        return data !== null ? data : [];
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    module2.exports = new Type("tag:yaml.org,2002:map", {
      kind: "mapping",
      construct: function(data) {
        return data !== null ? data : {};
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      explicit: [
        require_str(),
        require_seq(),
        require_map()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlNull(data) {
      if (data === null) return true;
      var max2 = data.length;
      return max2 === 1 && data === "~" || max2 === 4 && (data === "null" || data === "Null" || data === "NULL");
    }
    function constructYamlNull() {
      return null;
    }
    function isNull(object) {
      return object === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:null", {
      kind: "scalar",
      resolve: resolveYamlNull,
      construct: constructYamlNull,
      predicate: isNull,
      represent: {
        canonical: function() {
          return "~";
        },
        lowercase: function() {
          return "null";
        },
        uppercase: function() {
          return "NULL";
        },
        camelcase: function() {
          return "Null";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlBoolean(data) {
      if (data === null) return false;
      var max2 = data.length;
      return max2 === 4 && (data === "true" || data === "True" || data === "TRUE") || max2 === 5 && (data === "false" || data === "False" || data === "FALSE");
    }
    function constructYamlBoolean(data) {
      return data === "true" || data === "True" || data === "TRUE";
    }
    function isBoolean(object) {
      return Object.prototype.toString.call(object) === "[object Boolean]";
    }
    module2.exports = new Type("tag:yaml.org,2002:bool", {
      kind: "scalar",
      resolve: resolveYamlBoolean,
      construct: constructYamlBoolean,
      predicate: isBoolean,
      represent: {
        lowercase: function(object) {
          return object ? "true" : "false";
        },
        uppercase: function(object) {
          return object ? "TRUE" : "FALSE";
        },
        camelcase: function(object) {
          return object ? "True" : "False";
        }
      },
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    function isHexCode(c) {
      return 48 <= c && c <= 57 || 65 <= c && c <= 70 || 97 <= c && c <= 102;
    }
    function isOctCode(c) {
      return 48 <= c && c <= 55;
    }
    function isDecCode(c) {
      return 48 <= c && c <= 57;
    }
    function resolveYamlInteger(data) {
      if (data === null) return false;
      var max2 = data.length, index = 0, hasDigits = false, ch;
      if (!max2) return false;
      ch = data[index];
      if (ch === "-" || ch === "+") {
        ch = data[++index];
      }
      if (ch === "0") {
        if (index + 1 === max2) return true;
        ch = data[++index];
        if (ch === "b") {
          index++;
          for (; index < max2; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (ch !== "0" && ch !== "1") return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        if (ch === "x") {
          index++;
          for (; index < max2; index++) {
            ch = data[index];
            if (ch === "_") continue;
            if (!isHexCode(data.charCodeAt(index))) return false;
            hasDigits = true;
          }
          return hasDigits && ch !== "_";
        }
        for (; index < max2; index++) {
          ch = data[index];
          if (ch === "_") continue;
          if (!isOctCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }
        return hasDigits && ch !== "_";
      }
      if (ch === "_") return false;
      for (; index < max2; index++) {
        ch = data[index];
        if (ch === "_") continue;
        if (ch === ":") break;
        if (!isDecCode(data.charCodeAt(index))) {
          return false;
        }
        hasDigits = true;
      }
      if (!hasDigits || ch === "_") return false;
      if (ch !== ":") return true;
      return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
    }
    function constructYamlInteger(data) {
      var value = data, sign = 1, ch, base, digits = [];
      if (value.indexOf("_") !== -1) {
        value = value.replace(/_/g, "");
      }
      ch = value[0];
      if (ch === "-" || ch === "+") {
        if (ch === "-") sign = -1;
        value = value.slice(1);
        ch = value[0];
      }
      if (value === "0") return 0;
      if (ch === "0") {
        if (value[1] === "b") return sign * parseInt(value.slice(2), 2);
        if (value[1] === "x") return sign * parseInt(value, 16);
        return sign * parseInt(value, 8);
      }
      if (value.indexOf(":") !== -1) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseInt(value, 10);
    }
    function isInteger(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 === 0 && !common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:int", {
      kind: "scalar",
      resolve: resolveYamlInteger,
      construct: constructYamlInteger,
      predicate: isInteger,
      represent: {
        binary: function(obj) {
          return obj >= 0 ? "0b" + obj.toString(2) : "-0b" + obj.toString(2).slice(1);
        },
        octal: function(obj) {
          return obj >= 0 ? "0" + obj.toString(8) : "-0" + obj.toString(8).slice(1);
        },
        decimal: function(obj) {
          return obj.toString(10);
        },
        /* eslint-disable max-len */
        hexadecimal: function(obj) {
          return obj >= 0 ? "0x" + obj.toString(16).toUpperCase() : "-0x" + obj.toString(16).toUpperCase().slice(1);
        }
      },
      defaultStyle: "decimal",
      styleAliases: {
        binary: [2, "bin"],
        octal: [8, "oct"],
        decimal: [10, "dec"],
        hexadecimal: [16, "hex"]
      }
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var Type = require_type();
    var YAML_FLOAT_PATTERN = new RegExp(
      // 2.5e4, 2.5 and integers
      "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
    );
    function resolveYamlFloat(data) {
      if (data === null) return false;
      if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === "_") {
        return false;
      }
      return true;
    }
    function constructYamlFloat(data) {
      var value, sign, base, digits;
      value = data.replace(/_/g, "").toLowerCase();
      sign = value[0] === "-" ? -1 : 1;
      digits = [];
      if ("+-".indexOf(value[0]) >= 0) {
        value = value.slice(1);
      }
      if (value === ".inf") {
        return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
      } else if (value === ".nan") {
        return NaN;
      } else if (value.indexOf(":") >= 0) {
        value.split(":").forEach(function(v) {
          digits.unshift(parseFloat(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function(d) {
          value += d * base;
          base *= 60;
        });
        return sign * value;
      }
      return sign * parseFloat(value, 10);
    }
    var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
    function representYamlFloat(object, style) {
      var res;
      if (isNaN(object)) {
        switch (style) {
          case "lowercase":
            return ".nan";
          case "uppercase":
            return ".NAN";
          case "camelcase":
            return ".NaN";
        }
      } else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return ".inf";
          case "uppercase":
            return ".INF";
          case "camelcase":
            return ".Inf";
        }
      } else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
          case "lowercase":
            return "-.inf";
          case "uppercase":
            return "-.INF";
          case "camelcase":
            return "-.Inf";
        }
      } else if (common.isNegativeZero(object)) {
        return "-0.0";
      }
      res = object.toString(10);
      return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace("e", ".e") : res;
    }
    function isFloat(object) {
      return Object.prototype.toString.call(object) === "[object Number]" && (object % 1 !== 0 || common.isNegativeZero(object));
    }
    module2.exports = new Type("tag:yaml.org,2002:float", {
      kind: "scalar",
      resolve: resolveYamlFloat,
      construct: constructYamlFloat,
      predicate: isFloat,
      represent: representYamlFloat,
      defaultStyle: "lowercase"
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_failsafe()
      ],
      implicit: [
        require_null(),
        require_bool(),
        require_int(),
        require_float()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_json()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var YAML_DATE_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
    );
    var YAML_TIMESTAMP_REGEXP = new RegExp(
      "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
    );
    function resolveYamlTimestamp(data) {
      if (data === null) return false;
      if (YAML_DATE_REGEXP.exec(data) !== null) return true;
      if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
      return false;
    }
    function constructYamlTimestamp(data) {
      var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
      match = YAML_DATE_REGEXP.exec(data);
      if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
      if (match === null) throw new Error("Date resolve error");
      year = +match[1];
      month = +match[2] - 1;
      day = +match[3];
      if (!match[4]) {
        return new Date(Date.UTC(year, month, day));
      }
      hour = +match[4];
      minute = +match[5];
      second = +match[6];
      if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
          fraction += "0";
        }
        fraction = +fraction;
      }
      if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 6e4;
        if (match[9] === "-") delta = -delta;
      }
      date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
      if (delta) date.setTime(date.getTime() - delta);
      return date;
    }
    function representYamlTimestamp(object) {
      return object.toISOString();
    }
    module2.exports = new Type("tag:yaml.org,2002:timestamp", {
      kind: "scalar",
      resolve: resolveYamlTimestamp,
      construct: constructYamlTimestamp,
      instanceOf: Date,
      represent: representYamlTimestamp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveYamlMerge(data) {
      return data === "<<" || data === null;
    }
    module2.exports = new Type("tag:yaml.org,2002:merge", {
      kind: "scalar",
      resolve: resolveYamlMerge
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js"(exports, module2) {
    "use strict";
    var NodeBuffer;
    try {
      _require = require;
      NodeBuffer = _require("buffer").Buffer;
    } catch (__) {
    }
    var _require;
    var Type = require_type();
    var BASE64_MAP = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r";
    function resolveYamlBinary(data) {
      if (data === null) return false;
      var code, idx, bitlen = 0, max2 = data.length, map = BASE64_MAP;
      for (idx = 0; idx < max2; idx++) {
        code = map.indexOf(data.charAt(idx));
        if (code > 64) continue;
        if (code < 0) return false;
        bitlen += 6;
      }
      return bitlen % 8 === 0;
    }
    function constructYamlBinary(data) {
      var idx, tailbits, input = data.replace(/[\r\n=]/g, ""), max2 = input.length, map = BASE64_MAP, bits = 0, result = [];
      for (idx = 0; idx < max2; idx++) {
        if (idx % 4 === 0 && idx) {
          result.push(bits >> 16 & 255);
          result.push(bits >> 8 & 255);
          result.push(bits & 255);
        }
        bits = bits << 6 | map.indexOf(input.charAt(idx));
      }
      tailbits = max2 % 4 * 6;
      if (tailbits === 0) {
        result.push(bits >> 16 & 255);
        result.push(bits >> 8 & 255);
        result.push(bits & 255);
      } else if (tailbits === 18) {
        result.push(bits >> 10 & 255);
        result.push(bits >> 2 & 255);
      } else if (tailbits === 12) {
        result.push(bits >> 4 & 255);
      }
      if (NodeBuffer) {
        return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
      }
      return result;
    }
    function representYamlBinary(object) {
      var result = "", bits = 0, idx, tail, max2 = object.length, map = BASE64_MAP;
      for (idx = 0; idx < max2; idx++) {
        if (idx % 3 === 0 && idx) {
          result += map[bits >> 18 & 63];
          result += map[bits >> 12 & 63];
          result += map[bits >> 6 & 63];
          result += map[bits & 63];
        }
        bits = (bits << 8) + object[idx];
      }
      tail = max2 % 3;
      if (tail === 0) {
        result += map[bits >> 18 & 63];
        result += map[bits >> 12 & 63];
        result += map[bits >> 6 & 63];
        result += map[bits & 63];
      } else if (tail === 2) {
        result += map[bits >> 10 & 63];
        result += map[bits >> 4 & 63];
        result += map[bits << 2 & 63];
        result += map[64];
      } else if (tail === 1) {
        result += map[bits >> 2 & 63];
        result += map[bits << 4 & 63];
        result += map[64];
        result += map[64];
      }
      return result;
    }
    function isBinary(object) {
      return NodeBuffer && NodeBuffer.isBuffer(object);
    }
    module2.exports = new Type("tag:yaml.org,2002:binary", {
      kind: "scalar",
      resolve: resolveYamlBinary,
      construct: constructYamlBinary,
      predicate: isBinary,
      represent: representYamlBinary
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var _toString = Object.prototype.toString;
    function resolveYamlOmap(data) {
      if (data === null) return true;
      var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if (_toString.call(pair) !== "[object Object]") return false;
        for (pairKey in pair) {
          if (_hasOwnProperty.call(pair, pairKey)) {
            if (!pairHasKey) pairHasKey = true;
            else return false;
          }
        }
        if (!pairHasKey) return false;
        if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
        else return false;
      }
      return true;
    }
    function constructYamlOmap(data) {
      return data !== null ? data : [];
    }
    module2.exports = new Type("tag:yaml.org,2002:omap", {
      kind: "sequence",
      resolve: resolveYamlOmap,
      construct: constructYamlOmap
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _toString = Object.prototype.toString;
    function resolveYamlPairs(data) {
      if (data === null) return true;
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if (_toString.call(pair) !== "[object Object]") return false;
        keys = Object.keys(pair);
        if (keys.length !== 1) return false;
        result[index] = [keys[0], pair[keys[0]]];
      }
      return true;
    }
    function constructYamlPairs(data) {
      if (data === null) return [];
      var index, length, pair, keys, result, object = data;
      result = new Array(object.length);
      for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        keys = Object.keys(pair);
        result[index] = [keys[0], pair[keys[0]]];
      }
      return result;
    }
    module2.exports = new Type("tag:yaml.org,2002:pairs", {
      kind: "sequence",
      resolve: resolveYamlPairs,
      construct: constructYamlPairs
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    function resolveYamlSet(data) {
      if (data === null) return true;
      var key, object = data;
      for (key in object) {
        if (_hasOwnProperty.call(object, key)) {
          if (object[key] !== null) return false;
        }
      }
      return true;
    }
    function constructYamlSet(data) {
      return data !== null ? data : {};
    }
    module2.exports = new Type("tag:yaml.org,2002:set", {
      kind: "mapping",
      resolve: resolveYamlSet,
      construct: constructYamlSet
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = new Schema({
      include: [
        require_core()
      ],
      implicit: [
        require_timestamp(),
        require_merge()
      ],
      explicit: [
        require_binary(),
        require_omap(),
        require_pairs(),
        require_set()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptUndefined() {
      return true;
    }
    function constructJavascriptUndefined() {
      return void 0;
    }
    function representJavascriptUndefined() {
      return "";
    }
    function isUndefined(object) {
      return typeof object === "undefined";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/undefined", {
      kind: "scalar",
      resolve: resolveJavascriptUndefined,
      construct: constructJavascriptUndefined,
      predicate: isUndefined,
      represent: representJavascriptUndefined
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js"(exports, module2) {
    "use strict";
    var Type = require_type();
    function resolveJavascriptRegExp(data) {
      if (data === null) return false;
      if (data.length === 0) return false;
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        if (modifiers.length > 3) return false;
        if (regexp[regexp.length - modifiers.length - 1] !== "/") return false;
      }
      return true;
    }
    function constructJavascriptRegExp(data) {
      var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = "";
      if (regexp[0] === "/") {
        if (tail) modifiers = tail[1];
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
      }
      return new RegExp(regexp, modifiers);
    }
    function representJavascriptRegExp(object) {
      var result = "/" + object.source + "/";
      if (object.global) result += "g";
      if (object.multiline) result += "m";
      if (object.ignoreCase) result += "i";
      return result;
    }
    function isRegExp(object) {
      return Object.prototype.toString.call(object) === "[object RegExp]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/regexp", {
      kind: "scalar",
      resolve: resolveJavascriptRegExp,
      construct: constructJavascriptRegExp,
      predicate: isRegExp,
      represent: representJavascriptRegExp
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js"(exports, module2) {
    "use strict";
    var esprima;
    try {
      _require = require;
      esprima = _require("esprima");
    } catch (_) {
      if (typeof window !== "undefined") esprima = window.esprima;
    }
    var _require;
    var Type = require_type();
    function resolveJavascriptFunction(data) {
      if (data === null) return false;
      try {
        var source = "(" + data + ")", ast = esprima.parse(source, { range: true });
        if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
          return false;
        }
        return true;
      } catch (err) {
        return false;
      }
    }
    function constructJavascriptFunction(data) {
      var source = "(" + data + ")", ast = esprima.parse(source, { range: true }), params = [], body;
      if (ast.type !== "Program" || ast.body.length !== 1 || ast.body[0].type !== "ExpressionStatement" || ast.body[0].expression.type !== "ArrowFunctionExpression" && ast.body[0].expression.type !== "FunctionExpression") {
        throw new Error("Failed to resolve function");
      }
      ast.body[0].expression.params.forEach(function(param) {
        params.push(param.name);
      });
      body = ast.body[0].expression.body.range;
      if (ast.body[0].expression.body.type === "BlockStatement") {
        return new Function(params, source.slice(body[0] + 1, body[1] - 1));
      }
      return new Function(params, "return " + source.slice(body[0], body[1]));
    }
    function representJavascriptFunction(object) {
      return object.toString();
    }
    function isFunction(object) {
      return Object.prototype.toString.call(object) === "[object Function]";
    }
    module2.exports = new Type("tag:yaml.org,2002:js/function", {
      kind: "scalar",
      resolve: resolveJavascriptFunction,
      construct: constructJavascriptFunction,
      predicate: isFunction,
      represent: representJavascriptFunction
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js"(exports, module2) {
    "use strict";
    var Schema = require_schema();
    module2.exports = Schema.DEFAULT = new Schema({
      include: [
        require_default_safe()
      ],
      explicit: [
        require_undefined(),
        require_regexp(),
        require_function()
      ]
    });
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var Mark = require_mark();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CONTEXT_FLOW_IN = 1;
    var CONTEXT_FLOW_OUT = 2;
    var CONTEXT_BLOCK_IN = 3;
    var CONTEXT_BLOCK_OUT = 4;
    var CHOMPING_CLIP = 1;
    var CHOMPING_STRIP = 2;
    var CHOMPING_KEEP = 3;
    var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
    var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
    var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
    var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
    var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
    function _class(obj) {
      return Object.prototype.toString.call(obj);
    }
    function is_EOL(c) {
      return c === 10 || c === 13;
    }
    function is_WHITE_SPACE(c) {
      return c === 9 || c === 32;
    }
    function is_WS_OR_EOL(c) {
      return c === 9 || c === 32 || c === 10 || c === 13;
    }
    function is_FLOW_INDICATOR(c) {
      return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
    }
    function fromHexCode(c) {
      var lc;
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      lc = c | 32;
      if (97 <= lc && lc <= 102) {
        return lc - 97 + 10;
      }
      return -1;
    }
    function escapedHexLen(c) {
      if (c === 120) {
        return 2;
      }
      if (c === 117) {
        return 4;
      }
      if (c === 85) {
        return 8;
      }
      return 0;
    }
    function fromDecimalCode(c) {
      if (48 <= c && c <= 57) {
        return c - 48;
      }
      return -1;
    }
    function simpleEscapeSequence(c) {
      return c === 48 ? "\0" : c === 97 ? "\x07" : c === 98 ? "\b" : c === 116 ? "	" : c === 9 ? "	" : c === 110 ? "\n" : c === 118 ? "\v" : c === 102 ? "\f" : c === 114 ? "\r" : c === 101 ? "\x1B" : c === 32 ? " " : c === 34 ? '"' : c === 47 ? "/" : c === 92 ? "\\" : c === 78 ? "\x85" : c === 95 ? "\xA0" : c === 76 ? "\u2028" : c === 80 ? "\u2029" : "";
    }
    function charFromCodepoint(c) {
      if (c <= 65535) {
        return String.fromCharCode(c);
      }
      return String.fromCharCode(
        (c - 65536 >> 10) + 55296,
        (c - 65536 & 1023) + 56320
      );
    }
    var simpleEscapeCheck = new Array(256);
    var simpleEscapeMap = new Array(256);
    for (i = 0; i < 256; i++) {
      simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
      simpleEscapeMap[i] = simpleEscapeSequence(i);
    }
    var i;
    function State(input, options) {
      this.input = input;
      this.filename = options["filename"] || null;
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.onWarning = options["onWarning"] || null;
      this.legacy = options["legacy"] || false;
      this.json = options["json"] || false;
      this.listener = options["listener"] || null;
      this.implicitTypes = this.schema.compiledImplicit;
      this.typeMap = this.schema.compiledTypeMap;
      this.length = input.length;
      this.position = 0;
      this.line = 0;
      this.lineStart = 0;
      this.lineIndent = 0;
      this.documents = [];
    }
    function generateError(state, message) {
      return new YAMLException(
        message,
        new Mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart)
      );
    }
    function throwError(state, message) {
      throw generateError(state, message);
    }
    function throwWarning(state, message) {
      if (state.onWarning) {
        state.onWarning.call(null, generateError(state, message));
      }
    }
    var directiveHandlers = {
      YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (state.version !== null) {
          throwError(state, "duplication of %YAML directive");
        }
        if (args.length !== 1) {
          throwError(state, "YAML directive accepts exactly one argument");
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (match === null) {
          throwError(state, "ill-formed argument of the YAML directive");
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (major !== 1) {
          throwError(state, "unacceptable YAML version of the document");
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (minor !== 1 && minor !== 2) {
          throwWarning(state, "unsupported YAML version of the document");
        }
      },
      TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (args.length !== 2) {
          throwError(state, "TAG directive accepts exactly two arguments");
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
          throwError(state, "ill-formed tag handle (first argument) of the TAG directive");
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
          throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
          throwError(state, "ill-formed tag prefix (second argument) of the TAG directive");
        }
        state.tagMap[handle] = prefix;
      }
    };
    function captureSegment(state, start, end, checkJson) {
      var _position, _length, _character, _result;
      if (start < end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
          for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
            _character = _result.charCodeAt(_position);
            if (!(_character === 9 || 32 <= _character && _character <= 1114111)) {
              throwError(state, "expected valid JSON character");
            }
          }
        } else if (PATTERN_NON_PRINTABLE.test(_result)) {
          throwError(state, "the stream contains non-printable characters");
        }
        state.result += _result;
      }
    }
    function mergeMappings(state, destination, source, overridableKeys) {
      var sourceKeys, key, index, quantity;
      if (!common.isObject(source)) {
        throwError(state, "cannot merge mappings; the provided source object is unacceptable");
      }
      sourceKeys = Object.keys(source);
      for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
          destination[key] = source[key];
          overridableKeys[key] = true;
        }
      }
    }
    function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
      var index, quantity;
      if (Array.isArray(keyNode)) {
        keyNode = Array.prototype.slice.call(keyNode);
        for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
          if (Array.isArray(keyNode[index])) {
            throwError(state, "nested arrays are not supported inside keys");
          }
          if (typeof keyNode === "object" && _class(keyNode[index]) === "[object Object]") {
            keyNode[index] = "[object Object]";
          }
        }
      }
      if (typeof keyNode === "object" && _class(keyNode) === "[object Object]") {
        keyNode = "[object Object]";
      }
      keyNode = String(keyNode);
      if (_result === null) {
        _result = {};
      }
      if (keyTag === "tag:yaml.org,2002:merge") {
        if (Array.isArray(valueNode)) {
          for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
            mergeMappings(state, _result, valueNode[index], overridableKeys);
          }
        } else {
          mergeMappings(state, _result, valueNode, overridableKeys);
        }
      } else {
        if (!state.json && !_hasOwnProperty.call(overridableKeys, keyNode) && _hasOwnProperty.call(_result, keyNode)) {
          state.line = startLine || state.line;
          state.position = startPos || state.position;
          throwError(state, "duplicated mapping key");
        }
        _result[keyNode] = valueNode;
        delete overridableKeys[keyNode];
      }
      return _result;
    }
    function readLineBreak(state) {
      var ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 10) {
        state.position++;
      } else if (ch === 13) {
        state.position++;
        if (state.input.charCodeAt(state.position) === 10) {
          state.position++;
        }
      } else {
        throwError(state, "a line break is expected");
      }
      state.line += 1;
      state.lineStart = state.position;
    }
    function skipSeparationSpace(state, allowComments, checkIndent) {
      var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 10 && ch !== 13 && ch !== 0);
        }
        if (is_EOL(ch)) {
          readLineBreak(state);
          ch = state.input.charCodeAt(state.position);
          lineBreaks++;
          state.lineIndent = 0;
          while (ch === 32) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
          }
        } else {
          break;
        }
      }
      if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
        throwWarning(state, "deficient indentation");
      }
      return lineBreaks;
    }
    function testDocumentSeparator(state) {
      var _position = state.position, ch;
      ch = state.input.charCodeAt(_position);
      if ((ch === 45 || ch === 46) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
          return true;
        }
      }
      return false;
    }
    function writeFoldedLines(state, count) {
      if (count === 1) {
        state.result += " ";
      } else if (count > 1) {
        state.result += common.repeat("\n", count - 1);
      }
    }
    function readPlainScalar(state, nodeIndent, withinFlowCollection) {
      var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
      ch = state.input.charCodeAt(state.position);
      if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 35 || ch === 38 || ch === 42 || ch === 33 || ch === 124 || ch === 62 || ch === 39 || ch === 34 || ch === 37 || ch === 64 || ch === 96) {
        return false;
      }
      if (ch === 63 || ch === 45) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }
      state.kind = "scalar";
      state.result = "";
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
      while (ch !== 0) {
        if (ch === 58) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 35) {
          preceding = state.input.charCodeAt(state.position - 1);
          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
          break;
        } else if (is_EOL(ch)) {
          _line = state.line;
          _lineStart = state.lineStart;
          _lineIndent = state.lineIndent;
          skipSeparationSpace(state, false, -1);
          if (state.lineIndent >= nodeIndent) {
            hasPendingContent = true;
            ch = state.input.charCodeAt(state.position);
            continue;
          } else {
            state.position = captureEnd;
            state.line = _line;
            state.lineStart = _lineStart;
            state.lineIndent = _lineIndent;
            break;
          }
        }
        if (hasPendingContent) {
          captureSegment(state, captureStart, captureEnd, false);
          writeFoldedLines(state, state.line - _line);
          captureStart = captureEnd = state.position;
          hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
          captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
      }
      captureSegment(state, captureStart, captureEnd, false);
      if (state.result) {
        return true;
      }
      state.kind = _kind;
      state.result = _result;
      return false;
    }
    function readSingleQuotedScalar(state, nodeIndent) {
      var ch, captureStart, captureEnd;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 39) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 39) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (ch === 39) {
            captureStart = state.position;
            state.position++;
            captureEnd = state.position;
          } else {
            return true;
          }
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a single quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a single quoted scalar");
    }
    function readDoubleQuotedScalar(state, nodeIndent) {
      var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 34) {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      state.position++;
      captureStart = captureEnd = state.position;
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        if (ch === 34) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 92) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);
          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent);
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;
            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);
              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, "expected hexadecimal character");
              }
            }
            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, "unknown escape sequence");
          }
          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
          captureSegment(state, captureStart, captureEnd, true);
          writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
          captureStart = captureEnd = state.position;
        } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
          throwError(state, "unexpected end of the document within a double quoted scalar");
        } else {
          state.position++;
          captureEnd = state.position;
        }
      }
      throwError(state, "unexpected end of the stream within a double quoted scalar");
    }
    function readFlowCollection(state, nodeIndent) {
      var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, overridableKeys = {}, keyNode, keyTag, valueNode, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 91) {
        terminator = 93;
        isMapping = false;
        _result = [];
      } else if (ch === 123) {
        terminator = 125;
        isMapping = true;
        _result = {};
      } else {
        return false;
      }
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(++state.position);
      while (ch !== 0) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
          state.position++;
          state.tag = _tag;
          state.anchor = _anchor;
          state.kind = isMapping ? "mapping" : "sequence";
          state.result = _result;
          return true;
        } else if (!readNext) {
          throwError(state, "missed comma between flow collection entries");
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (ch === 63) {
          following = state.input.charCodeAt(state.position + 1);
          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && ch === 58) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }
        if (isMapping) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
        } else if (isPair) {
          _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
        } else {
          _result.push(keyNode);
        }
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === 44) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
          readNext = false;
        }
      }
      throwError(state, "unexpected end of the stream within a flow collection");
    }
    function readBlockScalar(state, nodeIndent) {
      var captureStart, folding, chomping = CHOMPING_CLIP, didReadContent = false, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch === 124) {
        folding = false;
      } else if (ch === 62) {
        folding = true;
      } else {
        return false;
      }
      state.kind = "scalar";
      state.result = "";
      while (ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
        if (ch === 43 || ch === 45) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, "repeat of a chomping mode identifier");
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
          if (tmp === 0) {
            throwError(state, "bad explicit indentation width of a block scalar; it cannot be less than one");
          } else if (!detectedIndent) {
            textIndent = nodeIndent + tmp - 1;
            detectedIndent = true;
          } else {
            throwError(state, "repeat of an indentation width identifier");
          }
        } else {
          break;
        }
      }
      if (is_WHITE_SPACE(ch)) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (ch === 35) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
      }
      while (ch !== 0) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
          textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
          emptyLines++;
          continue;
        }
        if (state.lineIndent < textIndent) {
          if (chomping === CHOMPING_KEEP) {
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (chomping === CHOMPING_CLIP) {
            if (didReadContent) {
              state.result += "\n";
            }
          }
          break;
        }
        if (folding) {
          if (is_WHITE_SPACE(ch)) {
            atMoreIndented = true;
            state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
          } else if (atMoreIndented) {
            atMoreIndented = false;
            state.result += common.repeat("\n", emptyLines + 1);
          } else if (emptyLines === 0) {
            if (didReadContent) {
              state.result += " ";
            }
          } else {
            state.result += common.repeat("\n", emptyLines);
          }
        } else {
          state.result += common.repeat("\n", didReadContent ? 1 + emptyLines : emptyLines);
        }
        didReadContent = true;
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && ch !== 0) {
          ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
      }
      return true;
    }
    function readBlockSequence(state, nodeIndent) {
      var _line, _tag = state.tag, _anchor = state.anchor, _result = [], following, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        if (ch !== 45) {
          break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
          break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
          if (state.lineIndent <= nodeIndent) {
            _result.push(null);
            ch = state.input.charCodeAt(state.position);
            continue;
          }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        _result.push(state.result);
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
          throwError(state, "bad indentation of a sequence entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "sequence";
        state.result = _result;
        return true;
      }
      return false;
    }
    function readBlockMapping(state, nodeIndent, flowIndent) {
      var following, allowCompact, _line, _pos, _tag = state.tag, _anchor = state.anchor, _result = {}, overridableKeys = {}, keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
      if (state.anchor !== null) {
        state.anchorMap[state.anchor] = _result;
      }
      ch = state.input.charCodeAt(state.position);
      while (ch !== 0) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line;
        _pos = state.position;
        if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
          if (ch === 63) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }
            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
            atExplicitKey = false;
            allowCompact = true;
          } else {
            throwError(state, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line");
          }
          state.position += 1;
          ch = following;
        } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
          if (state.line === _line) {
            ch = state.input.charCodeAt(state.position);
            while (is_WHITE_SPACE(ch)) {
              ch = state.input.charCodeAt(++state.position);
            }
            if (ch === 58) {
              ch = state.input.charCodeAt(++state.position);
              if (!is_WS_OR_EOL(ch)) {
                throwError(state, "a whitespace character is expected after the key-value separator within a block mapping");
              }
              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }
              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
              throwError(state, "can not read an implicit mapping pair; a colon is missed");
            } else {
              state.tag = _tag;
              state.anchor = _anchor;
              return true;
            }
          } else if (detected) {
            throwError(state, "can not read a block mapping entry; a multiline key may not be an implicit key");
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true;
          }
        } else {
          break;
        }
        if (state.line === _line || state.lineIndent > nodeIndent) {
          if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
            if (atExplicitKey) {
              keyNode = state.result;
            } else {
              valueNode = state.result;
            }
          }
          if (!atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
            keyTag = keyNode = valueNode = null;
          }
          skipSeparationSpace(state, true, -1);
          ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && ch !== 0) {
          throwError(state, "bad indentation of a mapping entry");
        } else if (state.lineIndent < nodeIndent) {
          break;
        }
      }
      if (atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
      }
      if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = "mapping";
        state.result = _result;
      }
      return detected;
    }
    function readTagProperty(state) {
      var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 33) return false;
      if (state.tag !== null) {
        throwError(state, "duplication of a tag property");
      }
      ch = state.input.charCodeAt(++state.position);
      if (ch === 60) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 33) {
        isNamed = true;
        tagHandle = "!!";
        ch = state.input.charCodeAt(++state.position);
      } else {
        tagHandle = "!";
      }
      _position = state.position;
      if (isVerbatim) {
        do {
          ch = state.input.charCodeAt(++state.position);
        } while (ch !== 0 && ch !== 62);
        if (state.position < state.length) {
          tagName = state.input.slice(_position, state.position);
          ch = state.input.charCodeAt(++state.position);
        } else {
          throwError(state, "unexpected end of the stream within a verbatim tag");
        }
      } else {
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          if (ch === 33) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);
              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, "named tag handle cannot contain such characters");
              }
              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, "tag suffix cannot contain exclamation marks");
            }
          }
          ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
          throwError(state, "tag suffix cannot contain flow indicator characters");
        }
      }
      if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, "tag name cannot contain such characters: " + tagName);
      }
      if (isVerbatim) {
        state.tag = tagName;
      } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
      } else if (tagHandle === "!") {
        state.tag = "!" + tagName;
      } else if (tagHandle === "!!") {
        state.tag = "tag:yaml.org,2002:" + tagName;
      } else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
      }
      return true;
    }
    function readAnchorProperty(state) {
      var _position, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 38) return false;
      if (state.anchor !== null) {
        throwError(state, "duplication of an anchor property");
      }
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an anchor node must contain at least one character");
      }
      state.anchor = state.input.slice(_position, state.position);
      return true;
    }
    function readAlias(state) {
      var _position, alias, ch;
      ch = state.input.charCodeAt(state.position);
      if (ch !== 42) return false;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;
      while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }
      if (state.position === _position) {
        throwError(state, "name of an alias node must contain at least one character");
      }
      alias = state.input.slice(_position, state.position);
      if (!_hasOwnProperty.call(state.anchorMap, alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
      }
      state.result = state.anchorMap[alias];
      skipSeparationSpace(state, true, -1);
      return true;
    }
    function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
      var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent;
      if (state.listener !== null) {
        state.listener("open", state);
      }
      state.tag = null;
      state.anchor = null;
      state.kind = null;
      state.result = null;
      allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
      if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        }
      }
      if (indentStatus === 1) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
          if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            allowBlockCollections = allowBlockStyles;
            if (state.lineIndent > parentIndent) {
              indentStatus = 1;
            } else if (state.lineIndent === parentIndent) {
              indentStatus = 0;
            } else if (state.lineIndent < parentIndent) {
              indentStatus = -1;
            }
          } else {
            allowBlockCollections = false;
          }
        }
      }
      if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
      }
      if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
          flowIndent = parentIndent;
        } else {
          flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (indentStatus === 1) {
          if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
            hasContent = true;
          } else {
            if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
              hasContent = true;
            } else if (readAlias(state)) {
              hasContent = true;
              if (state.tag !== null || state.anchor !== null) {
                throwError(state, "alias node should not have any properties");
              }
            } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
              hasContent = true;
              if (state.tag === null) {
                state.tag = "?";
              }
            }
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else if (indentStatus === 0) {
          hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
        }
      }
      if (state.tag !== null && state.tag !== "!") {
        if (state.tag === "?") {
          if (state.result !== null && state.kind !== "scalar") {
            throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
          }
          for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
            type = state.implicitTypes[typeIndex];
            if (type.resolve(state.result)) {
              state.result = type.construct(state.result);
              state.tag = type.tag;
              if (state.anchor !== null) {
                state.anchorMap[state.anchor] = state.result;
              }
              break;
            }
          }
        } else if (_hasOwnProperty.call(state.typeMap[state.kind || "fallback"], state.tag)) {
          type = state.typeMap[state.kind || "fallback"][state.tag];
          if (state.result !== null && type.kind !== state.kind) {
            throwError(state, "unacceptable node kind for !<" + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
          }
          if (!type.resolve(state.result)) {
            throwError(state, "cannot resolve a node with !<" + state.tag + "> explicit tag");
          } else {
            state.result = type.construct(state.result);
            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }
          }
        } else {
          throwError(state, "unknown tag !<" + state.tag + ">");
        }
      }
      if (state.listener !== null) {
        state.listener("close", state);
      }
      return state.tag !== null || state.anchor !== null || hasContent;
    }
    function readDocument(state) {
      var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
      state.version = null;
      state.checkLineBreaks = state.legacy;
      state.tagMap = {};
      state.anchorMap = {};
      while ((ch = state.input.charCodeAt(state.position)) !== 0) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || ch !== 37) {
          break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
          throwError(state, "directive name must not be less than one character in length");
        }
        while (ch !== 0) {
          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          if (ch === 35) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));
            break;
          }
          if (is_EOL(ch)) break;
          _position = state.position;
          while (ch !== 0 && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }
          directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (ch !== 0) readLineBreak(state);
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
          directiveHandlers[directiveName](state, directiveName, directiveArgs);
        } else {
          throwWarning(state, 'unknown document directive "' + directiveName + '"');
        }
      }
      skipSeparationSpace(state, true, -1);
      if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 45 && state.input.charCodeAt(state.position + 1) === 45 && state.input.charCodeAt(state.position + 2) === 45) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
        throwError(state, "directives end mark is expected");
      }
      composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
      skipSeparationSpace(state, true, -1);
      if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, "non-ASCII line breaks are interpreted as content");
      }
      state.documents.push(state.result);
      if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (state.input.charCodeAt(state.position) === 46) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }
        return;
      }
      if (state.position < state.length - 1) {
        throwError(state, "end of the stream or a document separator is expected");
      } else {
        return;
      }
    }
    function loadDocuments(input, options) {
      input = String(input);
      options = options || {};
      if (input.length !== 0) {
        if (input.charCodeAt(input.length - 1) !== 10 && input.charCodeAt(input.length - 1) !== 13) {
          input += "\n";
        }
        if (input.charCodeAt(0) === 65279) {
          input = input.slice(1);
        }
      }
      var state = new State(input, options);
      var nullpos = input.indexOf("\0");
      if (nullpos !== -1) {
        state.position = nullpos;
        throwError(state, "null byte is not allowed in input");
      }
      state.input += "\0";
      while (state.input.charCodeAt(state.position) === 32) {
        state.lineIndent += 1;
        state.position += 1;
      }
      while (state.position < state.length - 1) {
        readDocument(state);
      }
      return state.documents;
    }
    function loadAll(input, iterator, options) {
      if (iterator !== null && typeof iterator === "object" && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      var documents = loadDocuments(input, options);
      if (typeof iterator !== "function") {
        return documents;
      }
      for (var index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
      }
    }
    function load(input, options) {
      var documents = loadDocuments(input, options);
      if (documents.length === 0) {
        return void 0;
      } else if (documents.length === 1) {
        return documents[0];
      }
      throw new YAMLException("expected a single document in the stream, but found more");
    }
    function safeLoadAll(input, iterator, options) {
      if (typeof iterator === "object" && iterator !== null && typeof options === "undefined") {
        options = iterator;
        iterator = null;
      }
      return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    function safeLoad(input, options) {
      return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.loadAll = loadAll;
    module2.exports.load = load;
    module2.exports.safeLoadAll = safeLoadAll;
    module2.exports.safeLoad = safeLoad;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js"(exports, module2) {
    "use strict";
    var common = require_common();
    var YAMLException = require_exception();
    var DEFAULT_FULL_SCHEMA = require_default_full();
    var DEFAULT_SAFE_SCHEMA = require_default_safe();
    var _toString = Object.prototype.toString;
    var _hasOwnProperty = Object.prototype.hasOwnProperty;
    var CHAR_TAB = 9;
    var CHAR_LINE_FEED = 10;
    var CHAR_CARRIAGE_RETURN = 13;
    var CHAR_SPACE = 32;
    var CHAR_EXCLAMATION = 33;
    var CHAR_DOUBLE_QUOTE = 34;
    var CHAR_SHARP = 35;
    var CHAR_PERCENT = 37;
    var CHAR_AMPERSAND = 38;
    var CHAR_SINGLE_QUOTE = 39;
    var CHAR_ASTERISK = 42;
    var CHAR_COMMA = 44;
    var CHAR_MINUS = 45;
    var CHAR_COLON = 58;
    var CHAR_EQUALS = 61;
    var CHAR_GREATER_THAN = 62;
    var CHAR_QUESTION = 63;
    var CHAR_COMMERCIAL_AT = 64;
    var CHAR_LEFT_SQUARE_BRACKET = 91;
    var CHAR_RIGHT_SQUARE_BRACKET = 93;
    var CHAR_GRAVE_ACCENT = 96;
    var CHAR_LEFT_CURLY_BRACKET = 123;
    var CHAR_VERTICAL_LINE = 124;
    var CHAR_RIGHT_CURLY_BRACKET = 125;
    var ESCAPE_SEQUENCES = {};
    ESCAPE_SEQUENCES[0] = "\\0";
    ESCAPE_SEQUENCES[7] = "\\a";
    ESCAPE_SEQUENCES[8] = "\\b";
    ESCAPE_SEQUENCES[9] = "\\t";
    ESCAPE_SEQUENCES[10] = "\\n";
    ESCAPE_SEQUENCES[11] = "\\v";
    ESCAPE_SEQUENCES[12] = "\\f";
    ESCAPE_SEQUENCES[13] = "\\r";
    ESCAPE_SEQUENCES[27] = "\\e";
    ESCAPE_SEQUENCES[34] = '\\"';
    ESCAPE_SEQUENCES[92] = "\\\\";
    ESCAPE_SEQUENCES[133] = "\\N";
    ESCAPE_SEQUENCES[160] = "\\_";
    ESCAPE_SEQUENCES[8232] = "\\L";
    ESCAPE_SEQUENCES[8233] = "\\P";
    var DEPRECATED_BOOLEANS_SYNTAX = [
      "y",
      "Y",
      "yes",
      "Yes",
      "YES",
      "on",
      "On",
      "ON",
      "n",
      "N",
      "no",
      "No",
      "NO",
      "off",
      "Off",
      "OFF"
    ];
    function compileStyleMap(schema, map) {
      var result, keys, index, length, tag, style, type;
      if (map === null) return {};
      result = {};
      keys = Object.keys(map);
      for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if (tag.slice(0, 2) === "!!") {
          tag = "tag:yaml.org,2002:" + tag.slice(2);
        }
        type = schema.compiledTypeMap["fallback"][tag];
        if (type && _hasOwnProperty.call(type.styleAliases, style)) {
          style = type.styleAliases[style];
        }
        result[tag] = style;
      }
      return result;
    }
    function encodeHex(character) {
      var string, handle, length;
      string = character.toString(16).toUpperCase();
      if (character <= 255) {
        handle = "x";
        length = 2;
      } else if (character <= 65535) {
        handle = "u";
        length = 4;
      } else if (character <= 4294967295) {
        handle = "U";
        length = 8;
      } else {
        throw new YAMLException("code point within a string may not be greater than 0xFFFFFFFF");
      }
      return "\\" + handle + common.repeat("0", length - string.length) + string;
    }
    function State(options) {
      this.schema = options["schema"] || DEFAULT_FULL_SCHEMA;
      this.indent = Math.max(1, options["indent"] || 2);
      this.noArrayIndent = options["noArrayIndent"] || false;
      this.skipInvalid = options["skipInvalid"] || false;
      this.flowLevel = common.isNothing(options["flowLevel"]) ? -1 : options["flowLevel"];
      this.styleMap = compileStyleMap(this.schema, options["styles"] || null);
      this.sortKeys = options["sortKeys"] || false;
      this.lineWidth = options["lineWidth"] || 80;
      this.noRefs = options["noRefs"] || false;
      this.noCompatMode = options["noCompatMode"] || false;
      this.condenseFlow = options["condenseFlow"] || false;
      this.implicitTypes = this.schema.compiledImplicit;
      this.explicitTypes = this.schema.compiledExplicit;
      this.tag = null;
      this.result = "";
      this.duplicates = [];
      this.usedDuplicates = null;
    }
    function indentString(string, spaces) {
      var ind = common.repeat(" ", spaces), position = 0, next = -1, result = "", line, length = string.length;
      while (position < length) {
        next = string.indexOf("\n", position);
        if (next === -1) {
          line = string.slice(position);
          position = length;
        } else {
          line = string.slice(position, next + 1);
          position = next + 1;
        }
        if (line.length && line !== "\n") result += ind;
        result += line;
      }
      return result;
    }
    function generateNextLine(state, level) {
      return "\n" + common.repeat(" ", state.indent * level);
    }
    function testImplicitResolving(state, str) {
      var index, length, type;
      for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
          return true;
        }
      }
      return false;
    }
    function isWhitespace(c) {
      return c === CHAR_SPACE || c === CHAR_TAB;
    }
    function isPrintable(c) {
      return 32 <= c && c <= 126 || 161 <= c && c <= 55295 && c !== 8232 && c !== 8233 || 57344 <= c && c <= 65533 && c !== 65279 || 65536 <= c && c <= 1114111;
    }
    function isNsChar(c) {
      return isPrintable(c) && !isWhitespace(c) && c !== 65279 && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
    }
    function isPlainSafe(c, prev) {
      return isPrintable(c) && c !== 65279 && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
    }
    function isPlainSafeFirst(c) {
      return isPrintable(c) && c !== 65279 && !isWhitespace(c) && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
    }
    function needIndentIndicator(string) {
      var leadingSpaceRe = /^\n* /;
      return leadingSpaceRe.test(string);
    }
    var STYLE_PLAIN = 1;
    var STYLE_SINGLE = 2;
    var STYLE_LITERAL = 3;
    var STYLE_FOLDED = 4;
    var STYLE_DOUBLE = 5;
    function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
      var i;
      var char, prev_char;
      var hasLineBreak = false;
      var hasFoldableLine = false;
      var shouldTrackWidth = lineWidth !== -1;
      var previousLineBreak = -1;
      var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));
      if (singleLineOnly) {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
      } else {
        for (i = 0; i < string.length; i++) {
          char = string.charCodeAt(i);
          if (char === CHAR_LINE_FEED) {
            hasLineBreak = true;
            if (shouldTrackWidth) {
              hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
              i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ";
              previousLineBreak = i;
            }
          } else if (!isPrintable(char)) {
            return STYLE_DOUBLE;
          }
          prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
          plain = plain && isPlainSafe(char, prev_char);
        }
        hasFoldableLine = hasFoldableLine || shouldTrackWidth && (i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== " ");
      }
      if (!hasLineBreak && !hasFoldableLine) {
        return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
      }
      if (indentPerLevel > 9 && needIndentIndicator(string)) {
        return STYLE_DOUBLE;
      }
      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
    }
    function writeScalar(state, string, level, iskey) {
      state.dump = function() {
        if (string.length === 0) {
          return "''";
        }
        if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
          return "'" + string + "'";
        }
        var indent = state.indent * Math.max(1, level);
        var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
        var singleLineOnly = iskey || state.flowLevel > -1 && level >= state.flowLevel;
        function testAmbiguity(string2) {
          return testImplicitResolving(state, string2);
        }
        switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
          case STYLE_PLAIN:
            return string;
          case STYLE_SINGLE:
            return "'" + string.replace(/'/g, "''") + "'";
          case STYLE_LITERAL:
            return "|" + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));
          case STYLE_FOLDED:
            return ">" + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
          case STYLE_DOUBLE:
            return '"' + escapeString(string, lineWidth) + '"';
          default:
            throw new YAMLException("impossible error: invalid scalar style");
        }
      }();
    }
    function blockHeader(string, indentPerLevel) {
      var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : "";
      var clip = string[string.length - 1] === "\n";
      var keep = clip && (string[string.length - 2] === "\n" || string === "\n");
      var chomp = keep ? "+" : clip ? "" : "-";
      return indentIndicator + chomp + "\n";
    }
    function dropEndingNewline(string) {
      return string[string.length - 1] === "\n" ? string.slice(0, -1) : string;
    }
    function foldString(string, width) {
      var lineRe = /(\n+)([^\n]*)/g;
      var result = function() {
        var nextLF = string.indexOf("\n");
        nextLF = nextLF !== -1 ? nextLF : string.length;
        lineRe.lastIndex = nextLF;
        return foldLine(string.slice(0, nextLF), width);
      }();
      var prevMoreIndented = string[0] === "\n" || string[0] === " ";
      var moreIndented;
      var match;
      while (match = lineRe.exec(string)) {
        var prefix = match[1], line = match[2];
        moreIndented = line[0] === " ";
        result += prefix + (!prevMoreIndented && !moreIndented && line !== "" ? "\n" : "") + foldLine(line, width);
        prevMoreIndented = moreIndented;
      }
      return result;
    }
    function foldLine(line, width) {
      if (line === "" || line[0] === " ") return line;
      var breakRe = / [^ ]/g;
      var match;
      var start = 0, end, curr = 0, next = 0;
      var result = "";
      while (match = breakRe.exec(line)) {
        next = match.index;
        if (next - start > width) {
          end = curr > start ? curr : next;
          result += "\n" + line.slice(start, end);
          start = end + 1;
        }
        curr = next;
      }
      result += "\n";
      if (line.length - start > width && curr > start) {
        result += line.slice(start, curr) + "\n" + line.slice(curr + 1);
      } else {
        result += line.slice(start);
      }
      return result.slice(1);
    }
    function escapeString(string) {
      var result = "";
      var char, nextChar;
      var escapeSeq;
      for (var i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);
        if (char >= 55296 && char <= 56319) {
          nextChar = string.charCodeAt(i + 1);
          if (nextChar >= 56320 && nextChar <= 57343) {
            result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
            i++;
            continue;
          }
        }
        escapeSeq = ESCAPE_SEQUENCES[char];
        result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
      }
      return result;
    }
    function writeFlowSequence(state, level, object) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level, object[index], false, false)) {
          if (index !== 0) _result += "," + (!state.condenseFlow ? " " : "");
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = "[" + _result + "]";
    }
    function writeBlockSequence(state, level, object, compact) {
      var _result = "", _tag = state.tag, index, length;
      for (index = 0, length = object.length; index < length; index += 1) {
        if (writeNode(state, level + 1, object[index], true, true)) {
          if (!compact || index !== 0) {
            _result += generateNextLine(state, level);
          }
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            _result += "-";
          } else {
            _result += "- ";
          }
          _result += state.dump;
        }
      }
      state.tag = _tag;
      state.dump = _result || "[]";
    }
    function writeFlowMapping(state, level, object) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (index !== 0) pairBuffer += ", ";
        if (state.condenseFlow) pairBuffer += '"';
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
          continue;
        }
        if (state.dump.length > 1024) pairBuffer += "? ";
        pairBuffer += state.dump + (state.condenseFlow ? '"' : "") + ":" + (state.condenseFlow ? "" : " ");
        if (!writeNode(state, level, objectValue, false, false)) {
          continue;
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = "{" + _result + "}";
    }
    function writeBlockMapping(state, level, object, compact) {
      var _result = "", _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
      if (state.sortKeys === true) {
        objectKeyList.sort();
      } else if (typeof state.sortKeys === "function") {
        objectKeyList.sort(state.sortKeys);
      } else if (state.sortKeys) {
        throw new YAMLException("sortKeys must be a boolean or a function");
      }
      for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = "";
        if (!compact || index !== 0) {
          pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true, true)) {
          continue;
        }
        explicitPair = state.tag !== null && state.tag !== "?" || state.dump && state.dump.length > 1024;
        if (explicitPair) {
          if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += "?";
          } else {
            pairBuffer += "? ";
          }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
          pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
          continue;
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += ":";
        } else {
          pairBuffer += ": ";
        }
        pairBuffer += state.dump;
        _result += pairBuffer;
      }
      state.tag = _tag;
      state.dump = _result || "{}";
    }
    function detectType(state, object, explicit) {
      var _result, typeList, index, length, type, style;
      typeList = explicit ? state.explicitTypes : state.implicitTypes;
      for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === "object" && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
          state.tag = explicit ? type.tag : "?";
          if (type.represent) {
            style = state.styleMap[type.tag] || type.defaultStyle;
            if (_toString.call(type.represent) === "[object Function]") {
              _result = type.represent(object, style);
            } else if (_hasOwnProperty.call(type.represent, style)) {
              _result = type.represent[style](object, style);
            } else {
              throw new YAMLException("!<" + type.tag + '> tag resolver accepts not "' + style + '" style');
            }
            state.dump = _result;
          }
          return true;
        }
      }
      return false;
    }
    function writeNode(state, level, object, block, compact, iskey) {
      state.tag = null;
      state.dump = object;
      if (!detectType(state, object, false)) {
        detectType(state, object, true);
      }
      var type = _toString.call(state.dump);
      if (block) {
        block = state.flowLevel < 0 || state.flowLevel > level;
      }
      var objectOrArray = type === "[object Object]" || type === "[object Array]", duplicateIndex, duplicate;
      if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
      }
      if (state.tag !== null && state.tag !== "?" || duplicate || state.indent !== 2 && level > 0) {
        compact = false;
      }
      if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = "*ref_" + duplicateIndex;
      } else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
          state.usedDuplicates[duplicateIndex] = true;
        }
        if (type === "[object Object]") {
          if (block && Object.keys(state.dump).length !== 0) {
            writeBlockMapping(state, level, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowMapping(state, level, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object Array]") {
          var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
          if (block && state.dump.length !== 0) {
            writeBlockSequence(state, arrayLevel, state.dump, compact);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + state.dump;
            }
          } else {
            writeFlowSequence(state, arrayLevel, state.dump);
            if (duplicate) {
              state.dump = "&ref_" + duplicateIndex + " " + state.dump;
            }
          }
        } else if (type === "[object String]") {
          if (state.tag !== "?") {
            writeScalar(state, state.dump, level, iskey);
          }
        } else {
          if (state.skipInvalid) return false;
          throw new YAMLException("unacceptable kind of an object to dump " + type);
        }
        if (state.tag !== null && state.tag !== "?") {
          state.dump = "!<" + state.tag + "> " + state.dump;
        }
      }
      return true;
    }
    function getDuplicateReferences(object, state) {
      var objects = [], duplicatesIndexes = [], index, length;
      inspectNode(object, objects, duplicatesIndexes);
      for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
      }
      state.usedDuplicates = new Array(length);
    }
    function inspectNode(object, objects, duplicatesIndexes) {
      var objectKeyList, index, length;
      if (object !== null && typeof object === "object") {
        index = objects.indexOf(object);
        if (index !== -1) {
          if (duplicatesIndexes.indexOf(index) === -1) {
            duplicatesIndexes.push(index);
          }
        } else {
          objects.push(object);
          if (Array.isArray(object)) {
            for (index = 0, length = object.length; index < length; index += 1) {
              inspectNode(object[index], objects, duplicatesIndexes);
            }
          } else {
            objectKeyList = Object.keys(object);
            for (index = 0, length = objectKeyList.length; index < length; index += 1) {
              inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
            }
          }
        }
      }
    }
    function dump(input, options) {
      options = options || {};
      var state = new State(options);
      if (!state.noRefs) getDuplicateReferences(input, state);
      if (writeNode(state, 0, input, true, true)) return state.dump + "\n";
      return "";
    }
    function safeDump(input, options) {
      return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
    }
    module2.exports.dump = dump;
    module2.exports.safeDump = safeDump;
  }
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js"(exports, module2) {
    "use strict";
    var loader = require_loader();
    var dumper = require_dumper();
    function deprecated(name) {
      return function() {
        throw new Error("Function " + name + " is deprecated and cannot be used.");
      };
    }
    module2.exports.Type = require_type();
    module2.exports.Schema = require_schema();
    module2.exports.FAILSAFE_SCHEMA = require_failsafe();
    module2.exports.JSON_SCHEMA = require_json();
    module2.exports.CORE_SCHEMA = require_core();
    module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
    module2.exports.load = loader.load;
    module2.exports.loadAll = loader.loadAll;
    module2.exports.safeLoad = loader.safeLoad;
    module2.exports.safeLoadAll = loader.safeLoadAll;
    module2.exports.dump = dumper.dump;
    module2.exports.safeDump = dumper.safeDump;
    module2.exports.YAMLException = require_exception();
    module2.exports.MINIMAL_SCHEMA = require_failsafe();
    module2.exports.SAFE_SCHEMA = require_default_safe();
    module2.exports.DEFAULT_SCHEMA = require_default_full();
    module2.exports.scan = deprecated("scan");
    module2.exports.parse = deprecated("parse");
    module2.exports.compose = deprecated("compose");
    module2.exports.addConstructor = deprecated("addConstructor");
  }
});

// node_modules/front-matter/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
  "node_modules/front-matter/node_modules/js-yaml/index.js"(exports, module2) {
    "use strict";
    var yaml = require_js_yaml();
    module2.exports = yaml;
  }
});

// node_modules/front-matter/index.js
var require_front_matter = __commonJS({
  "node_modules/front-matter/index.js"(exports, module2) {
    var parser = require_js_yaml2();
    var optionalByteOrderMark = "\\ufeff?";
    var platform2 = typeof process !== "undefined" ? process.platform : "";
    var pattern = "^(" + optionalByteOrderMark + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (platform2 === "win32" ? "\\r?" : "") + "(?:\\n)?)";
    var regex = new RegExp(pattern, "m");
    module2.exports = extractor;
    module2.exports.test = test;
    function extractor(string, options) {
      string = string || "";
      var defaultOptions = { allowUnsafe: false };
      options = options instanceof Object ? { ...defaultOptions, ...options } : defaultOptions;
      options.allowUnsafe = Boolean(options.allowUnsafe);
      var lines = string.split(/(\r?\n)/);
      if (lines[0] && /= yaml =|---/.test(lines[0])) {
        return parse(string, options.allowUnsafe);
      } else {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
    }
    function computeLocation(match, body) {
      var line = 1;
      var pos = body.indexOf("\n");
      var offset3 = match.index + match[0].length;
      while (pos !== -1) {
        if (pos >= offset3) {
          return line;
        }
        line++;
        pos = body.indexOf("\n", pos + 1);
      }
      return line;
    }
    function parse(string, allowUnsafe) {
      var match = regex.exec(string);
      if (!match) {
        return {
          attributes: {},
          body: string,
          bodyBegin: 1
        };
      }
      var loader = allowUnsafe ? parser.load : parser.safeLoad;
      var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, "");
      var attributes = loader(yaml) || {};
      var body = string.replace(match[0], "");
      var line = computeLocation(match, string);
      return {
        attributes,
        body,
        bodyBegin: line,
        frontmatter: yaml
      };
    }
    function test(string) {
      string = string || "";
      return regex.test(string);
    }
  }
});

// node_modules/crypto-js/core.js
var require_core2 = __commonJS({
  "node_modules/crypto-js/core.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory();
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.CryptoJS = factory();
      }
    })(exports, function() {
      var CryptoJS = CryptoJS || function(Math2, undefined2) {
        var crypto2;
        if (typeof window !== "undefined" && window.crypto) {
          crypto2 = window.crypto;
        }
        if (typeof self !== "undefined" && self.crypto) {
          crypto2 = self.crypto;
        }
        if (typeof globalThis !== "undefined" && globalThis.crypto) {
          crypto2 = globalThis.crypto;
        }
        if (!crypto2 && typeof window !== "undefined" && window.msCrypto) {
          crypto2 = window.msCrypto;
        }
        if (!crypto2 && typeof global !== "undefined" && global.crypto) {
          crypto2 = global.crypto;
        }
        if (!crypto2 && typeof require === "function") {
          try {
            crypto2 = require("crypto");
          } catch (err) {
          }
        }
        var cryptoSecureRandomInt = function() {
          if (crypto2) {
            if (typeof crypto2.getRandomValues === "function") {
              try {
                return crypto2.getRandomValues(new Uint32Array(1))[0];
              } catch (err) {
              }
            }
            if (typeof crypto2.randomBytes === "function") {
              try {
                return crypto2.randomBytes(4).readInt32LE();
              } catch (err) {
              }
            }
          }
          throw new Error("Native crypto module could not be used to get secure random number.");
        };
        var create = Object.create || /* @__PURE__ */ function() {
          function F() {
          }
          return function(obj) {
            var subtype;
            F.prototype = obj;
            subtype = new F();
            F.prototype = null;
            return subtype;
          };
        }();
        var C = {};
        var C_lib = C.lib = {};
        var Base2 = C_lib.Base = /* @__PURE__ */ function() {
          return {
            /**
             * Creates a new object that inherits from this object.
             *
             * @param {Object} overrides Properties to copy into the new object.
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         field: 'value',
             *
             *         method: function () {
             *         }
             *     });
             */
            extend: function(overrides) {
              var subtype = create(this);
              if (overrides) {
                subtype.mixIn(overrides);
              }
              if (!subtype.hasOwnProperty("init") || this.init === subtype.init) {
                subtype.init = function() {
                  subtype.$super.init.apply(this, arguments);
                };
              }
              subtype.init.prototype = subtype;
              subtype.$super = this;
              return subtype;
            },
            /**
             * Extends this object and runs the init method.
             * Arguments to create() will be passed to init().
             *
             * @return {Object} The new object.
             *
             * @static
             *
             * @example
             *
             *     var instance = MyType.create();
             */
            create: function() {
              var instance10 = this.extend();
              instance10.init.apply(instance10, arguments);
              return instance10;
            },
            /**
             * Initializes a newly created object.
             * Override this method to add some logic when your objects are created.
             *
             * @example
             *
             *     var MyType = CryptoJS.lib.Base.extend({
             *         init: function () {
             *             // ...
             *         }
             *     });
             */
            init: function() {
            },
            /**
             * Copies properties into this object.
             *
             * @param {Object} properties The properties to mix in.
             *
             * @example
             *
             *     MyType.mixIn({
             *         field: 'value'
             *     });
             */
            mixIn: function(properties) {
              for (var propertyName in properties) {
                if (properties.hasOwnProperty(propertyName)) {
                  this[propertyName] = properties[propertyName];
                }
              }
              if (properties.hasOwnProperty("toString")) {
                this.toString = properties.toString;
              }
            },
            /**
             * Creates a copy of this object.
             *
             * @return {Object} The clone.
             *
             * @example
             *
             *     var clone = instance.clone();
             */
            clone: function() {
              return this.init.prototype.extend(this);
            }
          };
        }();
        var WordArray = C_lib.WordArray = Base2.extend({
          /**
           * Initializes a newly created word array.
           *
           * @param {Array} words (Optional) An array of 32-bit words.
           * @param {number} sigBytes (Optional) The number of significant bytes in the words.
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.create();
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
           *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
           */
          init: function(words, sigBytes) {
            words = this.words = words || [];
            if (sigBytes != undefined2) {
              this.sigBytes = sigBytes;
            } else {
              this.sigBytes = words.length * 4;
            }
          },
          /**
           * Converts this word array to a string.
           *
           * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
           *
           * @return {string} The stringified word array.
           *
           * @example
           *
           *     var string = wordArray + '';
           *     var string = wordArray.toString();
           *     var string = wordArray.toString(CryptoJS.enc.Utf8);
           */
          toString: function(encoder) {
            return (encoder || Hex).stringify(this);
          },
          /**
           * Concatenates a word array to this word array.
           *
           * @param {WordArray} wordArray The word array to append.
           *
           * @return {WordArray} This word array.
           *
           * @example
           *
           *     wordArray1.concat(wordArray2);
           */
          concat: function(wordArray) {
            var thisWords = this.words;
            var thatWords = wordArray.words;
            var thisSigBytes = this.sigBytes;
            var thatSigBytes = wordArray.sigBytes;
            this.clamp();
            if (thisSigBytes % 4) {
              for (var i = 0; i < thatSigBytes; i++) {
                var thatByte = thatWords[i >>> 2] >>> 24 - i % 4 * 8 & 255;
                thisWords[thisSigBytes + i >>> 2] |= thatByte << 24 - (thisSigBytes + i) % 4 * 8;
              }
            } else {
              for (var j = 0; j < thatSigBytes; j += 4) {
                thisWords[thisSigBytes + j >>> 2] = thatWords[j >>> 2];
              }
            }
            this.sigBytes += thatSigBytes;
            return this;
          },
          /**
           * Removes insignificant bits.
           *
           * @example
           *
           *     wordArray.clamp();
           */
          clamp: function() {
            var words = this.words;
            var sigBytes = this.sigBytes;
            words[sigBytes >>> 2] &= 4294967295 << 32 - sigBytes % 4 * 8;
            words.length = Math2.ceil(sigBytes / 4);
          },
          /**
           * Creates a copy of this word array.
           *
           * @return {WordArray} The clone.
           *
           * @example
           *
           *     var clone = wordArray.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone.words = this.words.slice(0);
            return clone;
          },
          /**
           * Creates a word array filled with random bytes.
           *
           * @param {number} nBytes The number of random bytes to generate.
           *
           * @return {WordArray} The random word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.lib.WordArray.random(16);
           */
          random: function(nBytes) {
            var words = [];
            for (var i = 0; i < nBytes; i += 4) {
              words.push(cryptoSecureRandomInt());
            }
            return new WordArray.init(words, nBytes);
          }
        });
        var C_enc = C.enc = {};
        var Hex = C_enc.Hex = {
          /**
           * Converts a word array to a hex string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The hex string.
           *
           * @static
           *
           * @example
           *
           *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var hexChars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              hexChars.push((bite >>> 4).toString(16));
              hexChars.push((bite & 15).toString(16));
            }
            return hexChars.join("");
          },
          /**
           * Converts a hex string to a word array.
           *
           * @param {string} hexStr The hex string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
           */
          parse: function(hexStr) {
            var hexStrLength = hexStr.length;
            var words = [];
            for (var i = 0; i < hexStrLength; i += 2) {
              words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << 24 - i % 8 * 4;
            }
            return new WordArray.init(words, hexStrLength / 2);
          }
        };
        var Latin1 = C_enc.Latin1 = {
          /**
           * Converts a word array to a Latin1 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The Latin1 string.
           *
           * @static
           *
           * @example
           *
           *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
           */
          stringify: function(wordArray) {
            var words = wordArray.words;
            var sigBytes = wordArray.sigBytes;
            var latin1Chars = [];
            for (var i = 0; i < sigBytes; i++) {
              var bite = words[i >>> 2] >>> 24 - i % 4 * 8 & 255;
              latin1Chars.push(String.fromCharCode(bite));
            }
            return latin1Chars.join("");
          },
          /**
           * Converts a Latin1 string to a word array.
           *
           * @param {string} latin1Str The Latin1 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
           */
          parse: function(latin1Str) {
            var latin1StrLength = latin1Str.length;
            var words = [];
            for (var i = 0; i < latin1StrLength; i++) {
              words[i >>> 2] |= (latin1Str.charCodeAt(i) & 255) << 24 - i % 4 * 8;
            }
            return new WordArray.init(words, latin1StrLength);
          }
        };
        var Utf8 = C_enc.Utf8 = {
          /**
           * Converts a word array to a UTF-8 string.
           *
           * @param {WordArray} wordArray The word array.
           *
           * @return {string} The UTF-8 string.
           *
           * @static
           *
           * @example
           *
           *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
           */
          stringify: function(wordArray) {
            try {
              return decodeURIComponent(escape(Latin1.stringify(wordArray)));
            } catch (e) {
              throw new Error("Malformed UTF-8 data");
            }
          },
          /**
           * Converts a UTF-8 string to a word array.
           *
           * @param {string} utf8Str The UTF-8 string.
           *
           * @return {WordArray} The word array.
           *
           * @static
           *
           * @example
           *
           *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
           */
          parse: function(utf8Str) {
            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
          }
        };
        var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base2.extend({
          /**
           * Resets this block algorithm's data buffer to its initial state.
           *
           * @example
           *
           *     bufferedBlockAlgorithm.reset();
           */
          reset: function() {
            this._data = new WordArray.init();
            this._nDataBytes = 0;
          },
          /**
           * Adds new data to this block algorithm's buffer.
           *
           * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
           *
           * @example
           *
           *     bufferedBlockAlgorithm._append('data');
           *     bufferedBlockAlgorithm._append(wordArray);
           */
          _append: function(data) {
            if (typeof data == "string") {
              data = Utf8.parse(data);
            }
            this._data.concat(data);
            this._nDataBytes += data.sigBytes;
          },
          /**
           * Processes available data blocks.
           *
           * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
           *
           * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
           *
           * @return {WordArray} The processed data.
           *
           * @example
           *
           *     var processedData = bufferedBlockAlgorithm._process();
           *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
           */
          _process: function(doFlush) {
            var processedWords;
            var data = this._data;
            var dataWords = data.words;
            var dataSigBytes = data.sigBytes;
            var blockSize = this.blockSize;
            var blockSizeBytes = blockSize * 4;
            var nBlocksReady = dataSigBytes / blockSizeBytes;
            if (doFlush) {
              nBlocksReady = Math2.ceil(nBlocksReady);
            } else {
              nBlocksReady = Math2.max((nBlocksReady | 0) - this._minBufferSize, 0);
            }
            var nWordsReady = nBlocksReady * blockSize;
            var nBytesReady = Math2.min(nWordsReady * 4, dataSigBytes);
            if (nWordsReady) {
              for (var offset3 = 0; offset3 < nWordsReady; offset3 += blockSize) {
                this._doProcessBlock(dataWords, offset3);
              }
              processedWords = dataWords.splice(0, nWordsReady);
              data.sigBytes -= nBytesReady;
            }
            return new WordArray.init(processedWords, nBytesReady);
          },
          /**
           * Creates a copy of this object.
           *
           * @return {Object} The clone.
           *
           * @example
           *
           *     var clone = bufferedBlockAlgorithm.clone();
           */
          clone: function() {
            var clone = Base2.clone.call(this);
            clone._data = this._data.clone();
            return clone;
          },
          _minBufferSize: 0
        });
        var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
          /**
           * Configuration options.
           */
          cfg: Base2.extend(),
          /**
           * Initializes a newly created hasher.
           *
           * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
           *
           * @example
           *
           *     var hasher = CryptoJS.algo.SHA256.create();
           */
          init: function(cfg) {
            this.cfg = this.cfg.extend(cfg);
            this.reset();
          },
          /**
           * Resets this hasher to its initial state.
           *
           * @example
           *
           *     hasher.reset();
           */
          reset: function() {
            BufferedBlockAlgorithm.reset.call(this);
            this._doReset();
          },
          /**
           * Updates this hasher with a message.
           *
           * @param {WordArray|string} messageUpdate The message to append.
           *
           * @return {Hasher} This hasher.
           *
           * @example
           *
           *     hasher.update('message');
           *     hasher.update(wordArray);
           */
          update: function(messageUpdate) {
            this._append(messageUpdate);
            this._process();
            return this;
          },
          /**
           * Finalizes the hash computation.
           * Note that the finalize operation is effectively a destructive, read-once operation.
           *
           * @param {WordArray|string} messageUpdate (Optional) A final message update.
           *
           * @return {WordArray} The hash.
           *
           * @example
           *
           *     var hash = hasher.finalize();
           *     var hash = hasher.finalize('message');
           *     var hash = hasher.finalize(wordArray);
           */
          finalize: function(messageUpdate) {
            if (messageUpdate) {
              this._append(messageUpdate);
            }
            var hash = this._doFinalize();
            return hash;
          },
          blockSize: 512 / 32,
          /**
           * Creates a shortcut function to a hasher's object interface.
           *
           * @param {Hasher} hasher The hasher to create a helper for.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
           */
          _createHelper: function(hasher) {
            return function(message, cfg) {
              return new hasher.init(cfg).finalize(message);
            };
          },
          /**
           * Creates a shortcut function to the HMAC's object interface.
           *
           * @param {Hasher} hasher The hasher to use in this HMAC helper.
           *
           * @return {Function} The shortcut function.
           *
           * @static
           *
           * @example
           *
           *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
           */
          _createHmacHelper: function(hasher) {
            return function(message, key) {
              return new C_algo.HMAC.init(hasher, key).finalize(message);
            };
          }
        });
        var C_algo = C.algo = {};
        return C;
      }(Math);
      return CryptoJS;
    });
  }
});

// node_modules/crypto-js/sha256.js
var require_sha256 = __commonJS({
  "node_modules/crypto-js/sha256.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        module2.exports = exports = factory(require_core2());
      } else if (typeof define === "function" && define.amd) {
        define(["./core"], factory);
      } else {
        factory(root.CryptoJS);
      }
    })(exports, function(CryptoJS) {
      (function(Math2) {
        var C = CryptoJS;
        var C_lib = C.lib;
        var WordArray = C_lib.WordArray;
        var Hasher = C_lib.Hasher;
        var C_algo = C.algo;
        var H = [];
        var K = [];
        (function() {
          function isPrime(n2) {
            var sqrtN = Math2.sqrt(n2);
            for (var factor = 2; factor <= sqrtN; factor++) {
              if (!(n2 % factor)) {
                return false;
              }
            }
            return true;
          }
          function getFractionalBits(n2) {
            return (n2 - (n2 | 0)) * 4294967296 | 0;
          }
          var n = 2;
          var nPrime = 0;
          while (nPrime < 64) {
            if (isPrime(n)) {
              if (nPrime < 8) {
                H[nPrime] = getFractionalBits(Math2.pow(n, 1 / 2));
              }
              K[nPrime] = getFractionalBits(Math2.pow(n, 1 / 3));
              nPrime++;
            }
            n++;
          }
        })();
        var W = [];
        var SHA256 = C_algo.SHA256 = Hasher.extend({
          _doReset: function() {
            this._hash = new WordArray.init(H.slice(0));
          },
          _doProcessBlock: function(M, offset3) {
            var H2 = this._hash.words;
            var a = H2[0];
            var b = H2[1];
            var c = H2[2];
            var d = H2[3];
            var e = H2[4];
            var f = H2[5];
            var g = H2[6];
            var h = H2[7];
            for (var i = 0; i < 64; i++) {
              if (i < 16) {
                W[i] = M[offset3 + i] | 0;
              } else {
                var gamma0x = W[i - 15];
                var gamma0 = (gamma0x << 25 | gamma0x >>> 7) ^ (gamma0x << 14 | gamma0x >>> 18) ^ gamma0x >>> 3;
                var gamma1x = W[i - 2];
                var gamma1 = (gamma1x << 15 | gamma1x >>> 17) ^ (gamma1x << 13 | gamma1x >>> 19) ^ gamma1x >>> 10;
                W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];
              }
              var ch = e & f ^ ~e & g;
              var maj = a & b ^ a & c ^ b & c;
              var sigma0 = (a << 30 | a >>> 2) ^ (a << 19 | a >>> 13) ^ (a << 10 | a >>> 22);
              var sigma1 = (e << 26 | e >>> 6) ^ (e << 21 | e >>> 11) ^ (e << 7 | e >>> 25);
              var t1 = h + sigma1 + ch + K[i] + W[i];
              var t2 = sigma0 + maj;
              h = g;
              g = f;
              f = e;
              e = d + t1 | 0;
              d = c;
              c = b;
              b = a;
              a = t1 + t2 | 0;
            }
            H2[0] = H2[0] + a | 0;
            H2[1] = H2[1] + b | 0;
            H2[2] = H2[2] + c | 0;
            H2[3] = H2[3] + d | 0;
            H2[4] = H2[4] + e | 0;
            H2[5] = H2[5] + f | 0;
            H2[6] = H2[6] + g | 0;
            H2[7] = H2[7] + h | 0;
          },
          _doFinalize: function() {
            var data = this._data;
            var dataWords = data.words;
            var nBitsTotal = this._nDataBytes * 8;
            var nBitsLeft = data.sigBytes * 8;
            dataWords[nBitsLeft >>> 5] |= 128 << 24 - nBitsLeft % 32;
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 14] = Math2.floor(nBitsTotal / 4294967296);
            dataWords[(nBitsLeft + 64 >>> 9 << 4) + 15] = nBitsTotal;
            data.sigBytes = dataWords.length * 4;
            this._process();
            return this._hash;
          },
          clone: function() {
            var clone = Hasher.clone.call(this);
            clone._hash = this._hash.clone();
            return clone;
          }
        });
        C.SHA256 = Hasher._createHelper(SHA256);
        C.HmacSHA256 = Hasher._createHmacHelper(SHA256);
      })(Math);
      return CryptoJS.SHA256;
    });
  }
});

// src/entry.ts
var entry_exports = {};
__export(entry_exports, {
  default: () => Base
});
module.exports = __toCommonJS(entry_exports);
var import_obsidian9 = require("obsidian");

// src/ui/text_view.ts
var import_obsidian8 = require("obsidian");
var import_front_matter = __toESM(require_front_matter());

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src) tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function compute_slots(slots) {
  const result = {};
  for (const key in slots) {
    result[key] = true;
  }
  return result;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node) return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i]) iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function svg_element(name) {
  return document.createElementNS("http://www.w3.org/2000/svg", name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null) node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value) node.setAttribute(attribute, value);
}
var always_set_through_set_attribute = ["width", "height"];
function set_attributes(node, attributes) {
  const descriptors = Object.getOwnPropertyDescriptors(node.__proto__);
  for (const key in attributes) {
    if (attributes[key] == null) {
      node.removeAttribute(key);
    } else if (key === "style") {
      node.style.cssText = attributes[key];
    } else if (key === "__value") {
      node.value = node[key] = attributes[key];
    } else if (descriptors[key] && descriptors[key].set && always_set_through_set_attribute.indexOf(key) === -1) {
      node[key] = attributes[key];
    } else {
      attr(node, key, attributes[key]);
    }
  }
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data) return;
  text2.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  return new CustomEvent(type, { detail, bubbles, cancelable });
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component) throw new Error("Function called outside component initialization");
  return current_component;
}
function beforeUpdate(fn) {
  get_current_component().$$.before_update.push(fn);
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function createEventDispatcher() {
  const component = get_current_component();
  return (type, detail, { cancelable = false } = {}) => {
    const callbacks = component.$$.callbacks[type];
    if (callbacks) {
      const event = custom_event(
        /** @type {string} */
        type,
        detail,
        { cancelable }
      );
      callbacks.slice().forEach((fn) => {
        fn.call(component, event);
      });
      return !event.defaultPrevented;
    }
    return true;
  };
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function tick() {
  schedule_update();
  return resolved_promise;
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length) binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block)) return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2) block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/runtime/internal/spread.js
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n)) to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2)) update2[key] = void 0;
  }
  return update2;
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance10, create_fragment13, not_equal, props, append_styles2 = null, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance10 ? instance10(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i]) $$.bound[i](value);
      if (ready) make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment13 ? create_fragment13($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro) transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
      if (this.$$l[type]) {
        const idx = this.$$l[type].indexOf(listener);
        if (idx >= 0) {
          this.$$l[type].splice(idx, 1);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn || this.$$c) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        for (const key in this.$$p_d) {
          if (!(key in this.$$d) && this[key] !== void 0) {
            this.$$d[key] = this[key];
            delete this[key];
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(this.$$p_d[key].attribute || key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r) return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn && this.$$c) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      // conversion already handled above
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1) callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/parsing/kebab/kebab.ts
function kebab(input) {
  return input.replaceAll(/\p{Lu}/gu, (match) => `-${match.toLowerCase()}`).replaceAll(/\p{Z}/gu, "-").replaceAll(/[^\p{L}\p{N}-]/gu, "-").replaceAll(/-+/g, "-").replace(/^-/, "").replace(/-$/, "");
}

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set, update2) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set, update2) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set, update2);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/ui/columns/columns.ts
var parseColumnSpec = (columnSpec) => {
  const hashMatch = columnSpec.match(/^(.+?)\(#([0-9a-fA-F]{6})\)$/);
  const oxMatch = columnSpec.match(/^(.+?)\(0x([0-9a-fA-F]{6})\)$/);
  const match = hashMatch || oxMatch;
  if (match && match[1] && match[2]) {
    return {
      raw: columnSpec,
      label: match[1],
      color: `#${match[2]}`
    };
  }
  return {
    raw: columnSpec,
    label: columnSpec
  };
};
var createColumnStores = (settingsStore) => {
  const columnTagTable = derived([settingsStore], ([settings]) => {
    var _a;
    const output = {};
    for (const column of (_a = settings.columns) != null ? _a : []) {
      const parsed = parseColumnSpec(column);
      output[kebab(parsed.label)] = parsed.label;
    }
    return output;
  });
  const columnColourTable = derived([settingsStore], ([settings]) => {
    var _a;
    const output = {};
    for (const column of (_a = settings.columns) != null ? _a : []) {
      const parsed = parseColumnSpec(column);
      if (parsed.color) {
        output[kebab(parsed.label)] = parsed.color;
      }
    }
    return output;
  });
  return { columnTagTable, columnColourTable };
};
function isColumnTag(input, columnTagTableStore) {
  return input in get_store_value(columnTagTableStore);
}

// src/ui/components/column.svelte
var import_obsidian4 = require("obsidian");

// src/ui/dnd/store.ts
var isDraggingStore = writable(null);

// src/ui/components/task_menu.svelte
var import_obsidian2 = require("obsidian");

// src/ui/components/icon_button.svelte
var import_obsidian = require("obsidian");
function add_css(target) {
  append_styles(target, "svelte-1ww0j6i", "button.svelte-1ww0j6i{width:24px;height:24px;display:flex;justify-content:center;align-items:center;border-radius:var(--radius-s);transition:background linear 100ms;cursor:pointer;background:unset;padding:0}");
}
function create_fragment(ctx) {
  let button;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      attr(button, "class", "svelte-1ww0j6i");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      ctx[3](button);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[2]
        );
        mounted = true;
      }
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      ctx[3](null);
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let { icon } = $$props;
  let element2;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  function button_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      element2 = $$value;
      $$invalidate(0, element2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("icon" in $$props2) $$invalidate(1, icon = $$props2.icon);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*element, icon*/
    3) {
      $: {
        if (element2) {
          (0, import_obsidian.setIcon)(element2, icon);
        }
      }
    }
  };
  return [element2, icon, click_handler, button_binding];
}
var Icon_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { icon: 1 }, add_css);
  }
};
var icon_button_default = Icon_button;

// src/ui/components/task_menu.svelte
function create_fragment2(ctx) {
  let iconbutton;
  let current;
  iconbutton = new icon_button_default({ props: { icon: "lucide-more-vertical" } });
  iconbutton.$on(
    "click",
    /*showMenu*/
    ctx[1]
  );
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current) return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $columnTagTableStore, $$unsubscribe_columnTagTableStore = noop, $$subscribe_columnTagTableStore = () => ($$unsubscribe_columnTagTableStore(), $$unsubscribe_columnTagTableStore = subscribe(columnTagTableStore, ($$value) => $$invalidate(4, $columnTagTableStore = $$value)), columnTagTableStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_columnTagTableStore());
  let { task } = $$props;
  let { taskActions } = $$props;
  let { columnTagTableStore } = $$props;
  $$subscribe_columnTagTableStore();
  function showMenu(e) {
    const menu = new import_obsidian2.Menu();
    const target = e.target;
    if (!target) {
      return;
    }
    const boundingRect = target.getBoundingClientRect();
    const y = boundingRect.top + boundingRect.height / 2;
    const x = boundingRect.left + boundingRect.width / 2;
    menu.addItem((i) => {
      i.setTitle(`Go to file`).onClick(() => taskActions.viewFile(task.id));
    });
    menu.addSeparator();
    for (const [tag, label] of Object.entries($columnTagTableStore)) {
      menu.addItem((i) => {
        i.setTitle(`Move to ${label}`).onClick(() => taskActions.changeColumn(task.id, tag));
        if (task.column === tag) {
          i.setDisabled(true);
        }
      });
    }
    menu.addItem((i) => {
      i.setTitle(`Move to Done`).onClick(() => taskActions.markDone(task.id));
      if (task.done) {
        i.setDisabled(true);
      }
    });
    menu.addSeparator();
    menu.addItem((i) => {
      i.setTitle(`Archive task`).onClick(() => taskActions.archiveTasks([task.id]));
    });
    menu.addItem((i) => {
      i.setTitle(`Delete task`).onClick(() => taskActions.deleteTask(task.id));
    });
    menu.showAtPosition({ x, y });
  }
  $$self.$$set = ($$props2) => {
    if ("task" in $$props2) $$invalidate(2, task = $$props2.task);
    if ("taskActions" in $$props2) $$invalidate(3, taskActions = $$props2.taskActions);
    if ("columnTagTableStore" in $$props2) $$subscribe_columnTagTableStore($$invalidate(0, columnTagTableStore = $$props2.columnTagTableStore));
  };
  return [columnTagTableStore, showMenu, task, taskActions];
}
var Task_menu = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, {
      task: 2,
      taskActions: 3,
      columnTagTableStore: 0
    });
  }
};
var task_menu_default = Task_menu;

// src/ui/components/task.svelte
var import_obsidian3 = require("obsidian");
function add_css2(target) {
  append_styles(target, "svelte-7bmxzm", '.task.svelte-7bmxzm.svelte-7bmxzm{background-color:var(--background-secondary-alt);border-radius:var(--radius-m);border:var(--border-width) solid var(--background-modifier-border);cursor:grab}.task.is-dragging.svelte-7bmxzm.svelte-7bmxzm{opacity:0.15}.task.svelte-7bmxzm .task-body.svelte-7bmxzm{padding:var(--size-4-2);display:grid;gap:var(--size-4-2);grid-template-columns:1fr auto}.task.svelte-7bmxzm .task-body p.svelte-7bmxzm{word-break:break-word;margin:0}.task.svelte-7bmxzm .task-body .task-content.svelte-7bmxzm{display:grid}.task.svelte-7bmxzm .task-body .task-content textarea.svelte-7bmxzm{cursor:text;background-color:var(--color-base-25);width:100%}.task.svelte-7bmxzm .task-body .task-content .content-preview.svelte-7bmxzm:focus-within{box-shadow:0 0 0 3px var(--background-modifier-border-focus)}.task.svelte-7bmxzm .task-footer.svelte-7bmxzm{border-top:var(--border-width) solid var(--background-modifier-border);padding:var(--size-4-2);padding-top:0}.task.svelte-7bmxzm .task-footer p.svelte-7bmxzm{margin:0;font-size:var(--font-ui-smaller)}.task.svelte-7bmxzm .task-tags.svelte-7bmxzm{display:flex;flex-wrap:wrap;gap:var(--size-4-1) var(--size-2-1);padding:var(--size-4-2) var(--size-2-2);padding-top:0}.task-content *{word-break:break-word;margin:0}.task-content img{max-width:100%;max-height:160px;object-fit:contain}.task-content code{white-space:pre-wrap}.task-content input[type="checkbox"]{pointer-events:none}');
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[23] = list[i];
  return child_ctx;
}
function create_else_block(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      attr(div, "role", "button");
      attr(div, "class", "content-preview markdown-rendered svelte-7bmxzm");
      attr(div, "tabindex", "0");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[18](div);
      if (!mounted) {
        dispose = [
          listen(
            div,
            "mouseup",
            /*handleFocus*/
            ctx[14]
          ),
          listen(
            div,
            "keypress",
            /*handleOpenKeypress*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      ctx[18](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_2(ctx) {
  let textarea;
  let textarea_value_value;
  let mounted;
  let dispose;
  return {
    c() {
      textarea = element("textarea");
      textarea.value = textarea_value_value = /*task*/
      ctx[0].content.replaceAll("<br />", "\n");
      attr(textarea, "class", "svelte-7bmxzm");
      toggle_class(
        textarea,
        "editing",
        /*isEditing*/
        ctx[4]
      );
    },
    m(target, anchor) {
      insert(target, textarea, anchor);
      ctx[17](textarea);
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "keypress",
            /*handleKeypress*/
            ctx[10]
          ),
          listen(
            textarea,
            "blur",
            /*handleContentBlur*/
            ctx[9]
          ),
          listen(textarea, "input", onInput)
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*task*/
      1 && textarea_value_value !== (textarea_value_value = /*task*/
      ctx2[0].content.replaceAll("<br />", "\n"))) {
        textarea.value = textarea_value_value;
      }
      if (dirty & /*isEditing*/
      16) {
        toggle_class(
          textarea,
          "editing",
          /*isEditing*/
          ctx2[4]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(textarea);
      }
      ctx[17](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_1(ctx) {
  let div;
  let p;
  let t_value = (
    /*task*/
    ctx[0].path + ""
  );
  let t;
  return {
    c() {
      div = element("div");
      p = element("p");
      t = text(t_value);
      attr(p, "class", "svelte-7bmxzm");
      attr(div, "class", "task-footer svelte-7bmxzm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, p);
      append(p, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*task*/
      1 && t_value !== (t_value = /*task*/
      ctx2[0].path + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_if_block(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*task*/
    ctx[0].tags
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "task-tags svelte-7bmxzm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*task*/
      1) {
        each_value = ensure_array_like(
          /*task*/
          ctx2[0].tags
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block(ctx) {
  let span2;
  let span0;
  let span1;
  let t1_value = (
    /*tag*/
    ctx[23] + ""
  );
  let t1;
  let t2;
  return {
    c() {
      span2 = element("span");
      span0 = element("span");
      span0.textContent = "#";
      span1 = element("span");
      t1 = text(t1_value);
      t2 = space();
      attr(span0, "class", "cm-formatting cm-formatting-hashtag cm-hashtag cm-hashtag-begin cm-list-1");
      attr(span1, "class", "cm-hashtag cm-hashtag-end cm-list-1");
    },
    m(target, anchor) {
      insert(target, span2, anchor);
      append(span2, span0);
      append(span2, span1);
      append(span1, t1);
      append(span2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*task*/
      1 && t1_value !== (t1_value = /*tag*/
      ctx2[23] + "")) set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span2);
      }
    }
  };
}
function create_fragment3(ctx) {
  let div2;
  let div1;
  let div0;
  let t0;
  let taskmenu;
  let t1;
  let t2;
  let div2_draggable_value;
  let current;
  let mounted;
  let dispose;
  function select_block_type(ctx2, dirty) {
    if (
      /*isEditing*/
      ctx2[4]
    ) return create_if_block_2;
    return create_else_block;
  }
  let current_block_type = select_block_type(ctx, -1);
  let if_block0 = current_block_type(ctx);
  taskmenu = new task_menu_default({
    props: {
      task: (
        /*task*/
        ctx[0]
      ),
      taskActions: (
        /*taskActions*/
        ctx[1]
      ),
      columnTagTableStore: (
        /*columnTagTableStore*/
        ctx[2]
      )
    }
  });
  let if_block1 = (
    /*showFilepath*/
    ctx[3] && create_if_block_1(ctx)
  );
  let if_block2 = (
    /*shouldconsolidateTags*/
    ctx[8] && create_if_block(ctx)
  );
  return {
    c() {
      div2 = element("div");
      div1 = element("div");
      div0 = element("div");
      if_block0.c();
      t0 = space();
      create_component(taskmenu.$$.fragment);
      t1 = space();
      if (if_block1) if_block1.c();
      t2 = space();
      if (if_block2) if_block2.c();
      attr(div0, "class", "task-content svelte-7bmxzm");
      attr(div1, "class", "task-body svelte-7bmxzm");
      attr(div2, "class", "task svelte-7bmxzm");
      attr(div2, "role", "group");
      attr(div2, "draggable", div2_draggable_value = !/*isEditing*/
      ctx[4]);
      toggle_class(
        div2,
        "is-dragging",
        /*isDragging*/
        ctx[7]
      );
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div1);
      append(div1, div0);
      if_block0.m(div0, null);
      append(div1, t0);
      mount_component(taskmenu, div1, null);
      append(div2, t1);
      if (if_block1) if_block1.m(div2, null);
      append(div2, t2);
      if (if_block2) if_block2.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div2,
            "dragstart",
            /*handleDragStart*/
            ctx[12]
          ),
          listen(
            div2,
            "dragend",
            /*handleDragEnd*/
            ctx[13]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (current_block_type === (current_block_type = select_block_type(ctx2, dirty)) && if_block0) {
        if_block0.p(ctx2, dirty);
      } else {
        if_block0.d(1);
        if_block0 = current_block_type(ctx2);
        if (if_block0) {
          if_block0.c();
          if_block0.m(div0, null);
        }
      }
      const taskmenu_changes = {};
      if (dirty & /*task*/
      1) taskmenu_changes.task = /*task*/
      ctx2[0];
      if (dirty & /*taskActions*/
      2) taskmenu_changes.taskActions = /*taskActions*/
      ctx2[1];
      if (dirty & /*columnTagTableStore*/
      4) taskmenu_changes.columnTagTableStore = /*columnTagTableStore*/
      ctx2[2];
      taskmenu.$set(taskmenu_changes);
      if (
        /*showFilepath*/
        ctx2[3]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_1(ctx2);
          if_block1.c();
          if_block1.m(div2, t2);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (
        /*shouldconsolidateTags*/
        ctx2[8]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
        } else {
          if_block2 = create_if_block(ctx2);
          if_block2.c();
          if_block2.m(div2, null);
        }
      } else if (if_block2) {
        if_block2.d(1);
        if_block2 = null;
      }
      if (!current || dirty & /*isEditing*/
      16 && div2_draggable_value !== (div2_draggable_value = !/*isEditing*/
      ctx2[4])) {
        attr(div2, "draggable", div2_draggable_value);
      }
      if (!current || dirty & /*isDragging*/
      128) {
        toggle_class(
          div2,
          "is-dragging",
          /*isDragging*/
          ctx2[7]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(taskmenu.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskmenu.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      if_block0.d();
      destroy_component(taskmenu);
      if (if_block1) if_block1.d();
      if (if_block2) if_block2.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function onInput(e) {
  e.currentTarget.style.height = `0px`;
  e.currentTarget.style.height = `${e.currentTarget.scrollHeight}px`;
}
function instance3($$self, $$props, $$invalidate) {
  let shouldconsolidateTags;
  let { app } = $$props;
  let { task } = $$props;
  let { taskActions } = $$props;
  let { columnTagTableStore } = $$props;
  let { showFilepath } = $$props;
  let { consolidateTags } = $$props;
  function handleContentBlur() {
    $$invalidate(4, isEditing = false);
    const content = textAreaEl == null ? void 0 : textAreaEl.value;
    if (!content) return;
    const updatedContent = content.replaceAll("\n", "<br />");
    taskActions.updateContent(task.id, updatedContent);
  }
  function handleKeypress(e) {
    if (e.key === "Enter" && !e.shiftKey || e.key === "Escape") {
      textAreaEl == null ? void 0 : textAreaEl.blur();
    }
  }
  function handleOpenKeypress(e) {
    if (e.key === "Enter" || e.key === " ") {
      handleFocus();
    }
  }
  let isDragging = false;
  let isEditing = false;
  function handleDragStart(e) {
    handleContentBlur();
    $$invalidate(7, isDragging = true);
    isDraggingStore.set({ fromColumn: task.column });
    if (e.dataTransfer) {
      e.dataTransfer.setData("text/plain", task.id);
      e.dataTransfer.dropEffect = "move";
    }
  }
  function handleDragEnd() {
    $$invalidate(7, isDragging = false);
    isDraggingStore.set(null);
  }
  let textAreaEl;
  let previewContainerEl;
  let markdownComponent;
  function handleFocus(e) {
    const path = (e == null ? void 0 : e.composedPath()) || [];
    for (const element2 of path) {
      if (element2 instanceof HTMLElement && element2.tagName.toLowerCase() === "a") {
        return;
      }
    }
    $$invalidate(4, isEditing = true);
    setTimeout(
      () => {
        textAreaEl == null ? void 0 : textAreaEl.focus();
      },
      100
    );
  }
  async function renderMarkdown() {
    if (!previewContainerEl) return;
    if (markdownComponent) {
      markdownComponent.unload();
    }
    previewContainerEl.empty();
    markdownComponent = new import_obsidian3.Component();
    const contentToRender = (task.content + (task.blockLink ? ` ^${task.blockLink}` : "")).replaceAll("<br />", "\n");
    await import_obsidian3.MarkdownRenderer.render(app, contentToRender, previewContainerEl, task.path, markdownComponent);
    setupLinkHandlers();
    postProcessRenderedContent();
  }
  function setupLinkHandlers() {
    if (!previewContainerEl) return;
    const internalLinks = previewContainerEl.querySelectorAll("a.internal-link");
    internalLinks.forEach((link) => {
      const anchorEl = link;
      anchorEl.addEventListener("click", (e) => {
        e.preventDefault();
        e.stopPropagation();
        const linkTarget = anchorEl.getAttribute("data-href");
        if (linkTarget && app) {
          app.workspace.openLinkText(linkTarget, task.path, true);
        }
      });
      anchorEl.addEventListener("mouseover", (e) => {
        const linkTarget = anchorEl.getAttribute("data-href");
        if (linkTarget && app && previewContainerEl) {
          app.workspace.trigger("hover-link", {
            event: e,
            source: "kanban-view",
            hoverParent: previewContainerEl,
            targetEl: anchorEl,
            linktext: linkTarget,
            sourcePath: task.path
          });
        }
      });
    });
  }
  function postProcessRenderedContent() {
    if (!previewContainerEl) return;
    previewContainerEl.querySelectorAll("a:not(.internal-link)").forEach((a) => {
      const anchor = a;
      anchor.target = "_blank";
      anchor.rel = "noopener noreferrer";
      anchor.addEventListener("click", (e) => e.stopPropagation());
      anchor.addEventListener("keypress", (e) => e.stopPropagation());
    });
    previewContainerEl.querySelectorAll('input[type="checkbox"]').forEach((cb) => {
      const el = cb;
      el.disabled = true;
    });
    previewContainerEl.querySelectorAll("iframe, audio, video").forEach((el) => {
      el.remove();
    });
  }
  onDestroy(() => {
    if (markdownComponent) {
      markdownComponent.unload();
    }
  });
  function textarea_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      textAreaEl = $$value;
      $$invalidate(5, textAreaEl);
    });
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      previewContainerEl = $$value;
      $$invalidate(6, previewContainerEl);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2) $$invalidate(15, app = $$props2.app);
    if ("task" in $$props2) $$invalidate(0, task = $$props2.task);
    if ("taskActions" in $$props2) $$invalidate(1, taskActions = $$props2.taskActions);
    if ("columnTagTableStore" in $$props2) $$invalidate(2, columnTagTableStore = $$props2.columnTagTableStore);
    if ("showFilepath" in $$props2) $$invalidate(3, showFilepath = $$props2.showFilepath);
    if ("consolidateTags" in $$props2) $$invalidate(16, consolidateTags = $$props2.consolidateTags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*task, isEditing, previewContainerEl*/
    81) {
      $: if (task && !isEditing && previewContainerEl) {
        renderMarkdown();
      }
    }
    if ($$self.$$.dirty & /*textAreaEl*/
    32) {
      $: {
        if (textAreaEl) {
          $$invalidate(5, textAreaEl.style.height = `0px`, textAreaEl);
          $$invalidate(5, textAreaEl.style.height = `${textAreaEl.scrollHeight}px`, textAreaEl);
        }
      }
    }
    if ($$self.$$.dirty & /*consolidateTags, task*/
    65537) {
      $: $$invalidate(8, shouldconsolidateTags = consolidateTags && task.tags.size > 0);
    }
  };
  return [
    task,
    taskActions,
    columnTagTableStore,
    showFilepath,
    isEditing,
    textAreaEl,
    previewContainerEl,
    isDragging,
    shouldconsolidateTags,
    handleContentBlur,
    handleKeypress,
    handleOpenKeypress,
    handleDragStart,
    handleDragEnd,
    handleFocus,
    app,
    consolidateTags,
    textarea_binding,
    div_binding
  ];
}
var Task = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance3,
      create_fragment3,
      safe_not_equal,
      {
        app: 15,
        task: 0,
        taskActions: 1,
        columnTagTableStore: 2,
        showFilepath: 3,
        consolidateTags: 16
      },
      add_css2
    );
  }
};
var task_default = Task;

// src/ui/components/column.svelte
function add_css3(target) {
  append_styles(target, "svelte-1k2d6h5", ".column.svelte-1k2d6h5.svelte-1k2d6h5{display:flex;flex-direction:column;align-self:flex-start;width:300px;flex-shrink:0;padding:var(--size-4-3);border-radius:var(--radius-m);border:var(--border-width) solid var(--background-modifier-border);background-color:var(--background-secondary)}.column.drop-active.svelte-1k2d6h5 .tasks-wrapper .tasks.svelte-1k2d6h5{opacity:0.4}.column.drop-active.drop-hover.svelte-1k2d6h5 .tasks-wrapper.svelte-1k2d6h5{border-color:var(--color-base-70)}.column.svelte-1k2d6h5 .header.svelte-1k2d6h5{display:flex;justify-content:space-between;align-items:center;height:24px;flex-shrink:0}.column.svelte-1k2d6h5 .header h2.svelte-1k2d6h5{font-size:var(--font-ui-larger);font-weight:var(--font-bold);margin:0}.column.svelte-1k2d6h5 .divide.svelte-1k2d6h5{width:calc(100% + 2 * var(--size-4-3));border-bottom:var(--border-width) solid var(--column-color, var(--background-modifier-border));margin:var(--size-4-3) calc(-1 * var(--size-4-3))}.column.svelte-1k2d6h5 .tasks-wrapper.svelte-1k2d6h5{height:100%;min-height:50px;border:var(--border-width) dashed transparent;border-radius:var(--radius-m)}.column.svelte-1k2d6h5 .tasks-wrapper .tasks.svelte-1k2d6h5{display:flex;flex-direction:column;gap:var(--size-4-2)}.column.svelte-1k2d6h5 .tasks-wrapper .tasks button.svelte-1k2d6h5{display:flex;align-items:center;cursor:pointer}.column.svelte-1k2d6h5 .tasks-wrapper .tasks button span.svelte-1k2d6h5{height:18px}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[25] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div4;
  let div0;
  let h2;
  let t0;
  let t1;
  let t2;
  let div1;
  let t3;
  let div3;
  let div2;
  let t4;
  let show_if = isColumnTag(
    /*column*/
    ctx[1],
    /*columnTagTableStore*/
    ctx[5]
  );
  let div4_style_value;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*column*/
    ctx[1] === "done" && create_if_block_22(ctx)
  );
  let each_value = ensure_array_like(
    /*sortedTasks*/
    ctx[12]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = show_if && create_if_block_12(ctx);
  return {
    c() {
      div4 = element("div");
      div0 = element("div");
      h2 = element("h2");
      t0 = text(
        /*columnTitle*/
        ctx[14]
      );
      t1 = space();
      if (if_block0) if_block0.c();
      t2 = space();
      div1 = element("div");
      t3 = space();
      div3 = element("div");
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t4 = space();
      if (if_block1) if_block1.c();
      attr(h2, "class", "svelte-1k2d6h5");
      attr(div0, "class", "header svelte-1k2d6h5");
      attr(div1, "class", "divide svelte-1k2d6h5");
      attr(div2, "class", "tasks svelte-1k2d6h5");
      attr(div3, "class", "tasks-wrapper svelte-1k2d6h5");
      attr(div4, "role", "group");
      attr(div4, "class", "column svelte-1k2d6h5");
      attr(div4, "style", div4_style_value = /*columnColor*/
      ctx[13] ? `background-color: ${/*columnColor*/
      ctx[13]};` : "");
      toggle_class(div4, "drop-active", !!/*draggingData*/
      ctx[10]);
      toggle_class(
        div4,
        "drop-hover",
        /*isDraggedOver*/
        ctx[11]
      );
      set_style(
        div4,
        "--column-color",
        /*columnColor*/
        ctx[13]
      );
    },
    m(target, anchor) {
      insert(target, div4, anchor);
      append(div4, div0);
      append(div0, h2);
      append(h2, t0);
      append(div0, t1);
      if (if_block0) if_block0.m(div0, null);
      append(div4, t2);
      append(div4, div1);
      append(div4, t3);
      append(div4, div3);
      append(div3, div2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append(div2, t4);
      if (if_block1) if_block1.m(div2, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div4,
            "dragover",
            /*handleDragOver*/
            ctx[16]
          ),
          listen(
            div4,
            "dragleave",
            /*handleDragLeave*/
            ctx[17]
          ),
          listen(
            div4,
            "drop",
            /*handleDrop*/
            ctx[18]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*columnTitle*/
      16384) set_data(
        t0,
        /*columnTitle*/
        ctx2[14]
      );
      if (
        /*column*/
        ctx2[1] === "done"
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty & /*column*/
          2) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_22(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div0, null);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (dirty & /*app, sortedTasks, taskActions, columnTagTableStore, showFilepath, consolidateTags*/
      4529) {
        each_value = ensure_array_like(
          /*sortedTasks*/
          ctx2[12]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, t4);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty & /*column, columnTagTableStore*/
      34) show_if = isColumnTag(
        /*column*/
        ctx2[1],
        /*columnTagTableStore*/
        ctx2[5]
      );
      if (show_if) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_12(ctx2);
          if_block1.c();
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty & /*columnColor*/
      8192 && div4_style_value !== (div4_style_value = /*columnColor*/
      ctx2[13] ? `background-color: ${/*columnColor*/
      ctx2[13]};` : "")) {
        attr(div4, "style", div4_style_value);
      }
      if (!current || dirty & /*draggingData*/
      1024) {
        toggle_class(div4, "drop-active", !!/*draggingData*/
        ctx2[10]);
      }
      if (!current || dirty & /*isDraggedOver*/
      2048) {
        toggle_class(
          div4,
          "drop-hover",
          /*isDraggedOver*/
          ctx2[11]
        );
      }
      const style_changed = dirty & /*columnColor*/
      8192;
      if (dirty & /*columnColor*/
      8192 || style_changed) {
        set_style(
          div4,
          "--column-color",
          /*columnColor*/
          ctx2[13]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div4);
      }
      if (if_block0) if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_22(ctx) {
  let iconbutton;
  let current;
  iconbutton = new icon_button_default({ props: { icon: "lucide-more-vertical" } });
  iconbutton.$on(
    "click",
    /*showMenu*/
    ctx[15]
  );
  return {
    c() {
      create_component(iconbutton.$$.fragment);
    },
    m(target, anchor) {
      mount_component(iconbutton, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current) return;
      transition_in(iconbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(iconbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(iconbutton, detaching);
    }
  };
}
function create_each_block2(ctx) {
  let taskcomponent;
  let current;
  taskcomponent = new task_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      task: (
        /*task*/
        ctx[25]
      ),
      taskActions: (
        /*taskActions*/
        ctx[4]
      ),
      columnTagTableStore: (
        /*columnTagTableStore*/
        ctx[5]
      ),
      showFilepath: (
        /*showFilepath*/
        ctx[7]
      ),
      consolidateTags: (
        /*consolidateTags*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(taskcomponent.$$.fragment);
    },
    m(target, anchor) {
      mount_component(taskcomponent, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const taskcomponent_changes = {};
      if (dirty & /*app*/
      1) taskcomponent_changes.app = /*app*/
      ctx2[0];
      if (dirty & /*sortedTasks*/
      4096) taskcomponent_changes.task = /*task*/
      ctx2[25];
      if (dirty & /*taskActions*/
      16) taskcomponent_changes.taskActions = /*taskActions*/
      ctx2[4];
      if (dirty & /*columnTagTableStore*/
      32) taskcomponent_changes.columnTagTableStore = /*columnTagTableStore*/
      ctx2[5];
      if (dirty & /*showFilepath*/
      128) taskcomponent_changes.showFilepath = /*showFilepath*/
      ctx2[7];
      if (dirty & /*consolidateTags*/
      256) taskcomponent_changes.consolidateTags = /*consolidateTags*/
      ctx2[8];
      taskcomponent.$set(taskcomponent_changes);
    },
    i(local) {
      if (current) return;
      transition_in(taskcomponent.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(taskcomponent.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(taskcomponent, detaching);
    }
  };
}
function create_if_block_12(ctx) {
  let button;
  let span;
  let t;
  let mounted;
  let dispose;
  return {
    c() {
      button = element("button");
      span = element("span");
      t = text("\n						Add new");
      attr(span, "class", "svelte-1k2d6h5");
      attr(button, "class", "svelte-1k2d6h5");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, span);
      ctx[22](span);
      append(button, t);
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[23]
        );
        mounted = true;
      }
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      ctx[22](null);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (!/*hideOnEmpty*/
  ctx[2] || /*tasks*/
  ctx[3].length) && create_if_block2(ctx);
  return {
    c() {
      if (if_block) if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if (if_block) if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!/*hideOnEmpty*/
      ctx2[2] || /*tasks*/
      ctx2[3].length) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*hideOnEmpty, tasks*/
          12) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block) if_block.d(detaching);
    }
  };
}
function getColumnTitle(column, columnTagTable) {
  switch (column) {
    case "done":
      return "Done";
    case "uncategorised":
      return "Uncategorised";
    default:
      return columnTagTable[column];
  }
}
function instance4($$self, $$props, $$invalidate) {
  let columnTitle;
  let columnColor;
  let sortedTasks;
  let draggingData;
  let canDrop;
  let $isDraggingStore;
  let $columnColourTableStore, $$unsubscribe_columnColourTableStore = noop, $$subscribe_columnColourTableStore = () => ($$unsubscribe_columnColourTableStore(), $$unsubscribe_columnColourTableStore = subscribe(columnColourTableStore, ($$value) => $$invalidate(20, $columnColourTableStore = $$value)), columnColourTableStore);
  let $columnTagTableStore, $$unsubscribe_columnTagTableStore = noop, $$subscribe_columnTagTableStore = () => ($$unsubscribe_columnTagTableStore(), $$unsubscribe_columnTagTableStore = subscribe(columnTagTableStore, ($$value) => $$invalidate(21, $columnTagTableStore = $$value)), columnTagTableStore);
  component_subscribe($$self, isDraggingStore, ($$value) => $$invalidate(19, $isDraggingStore = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_columnColourTableStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_columnTagTableStore());
  let { app } = $$props;
  let { column } = $$props;
  let { hideOnEmpty = false } = $$props;
  let { tasks } = $$props;
  let { taskActions } = $$props;
  let { columnTagTableStore } = $$props;
  $$subscribe_columnTagTableStore();
  let { columnColourTableStore } = $$props;
  $$subscribe_columnColourTableStore();
  let { showFilepath } = $$props;
  let { consolidateTags } = $$props;
  function showMenu(e) {
    const menu = new import_obsidian4.Menu();
    menu.addItem((i) => {
      i.setTitle(`Archive all`).onClick(() => taskActions.archiveTasks(tasks.map(({ id }) => id)));
    });
    menu.showAtMouseEvent(e);
  }
  let isDraggedOver = false;
  function handleDragOver(e) {
    e.preventDefault();
    if (!canDrop) {
      if (e.dataTransfer) {
        e.dataTransfer.dropEffect = "none";
      }
      return;
    }
    $$invalidate(11, isDraggedOver = true);
    if (e.dataTransfer) {
      e.dataTransfer.dropEffect = "move";
    }
  }
  function handleDragLeave(e) {
    $$invalidate(11, isDraggedOver = false);
  }
  function handleDrop(e) {
    var _a;
    e.preventDefault();
    if (!canDrop) {
      return;
    }
    const droppedId = (_a = e.dataTransfer) == null ? void 0 : _a.getData("text/plain");
    if (droppedId) {
      switch (column) {
        case "uncategorised":
          break;
        case "done":
          taskActions.markDone(droppedId);
          break;
        default:
          taskActions.changeColumn(droppedId, column);
          break;
      }
    }
  }
  let buttonEl;
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      buttonEl = $$value;
      $$invalidate(9, buttonEl);
    });
  }
  const click_handler = async (e) => {
    if (isColumnTag(column, columnTagTableStore)) {
      await taskActions.addNew(column, e);
    }
  };
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2) $$invalidate(0, app = $$props2.app);
    if ("column" in $$props2) $$invalidate(1, column = $$props2.column);
    if ("hideOnEmpty" in $$props2) $$invalidate(2, hideOnEmpty = $$props2.hideOnEmpty);
    if ("tasks" in $$props2) $$invalidate(3, tasks = $$props2.tasks);
    if ("taskActions" in $$props2) $$invalidate(4, taskActions = $$props2.taskActions);
    if ("columnTagTableStore" in $$props2) $$subscribe_columnTagTableStore($$invalidate(5, columnTagTableStore = $$props2.columnTagTableStore));
    if ("columnColourTableStore" in $$props2) $$subscribe_columnColourTableStore($$invalidate(6, columnColourTableStore = $$props2.columnColourTableStore));
    if ("showFilepath" in $$props2) $$invalidate(7, showFilepath = $$props2.showFilepath);
    if ("consolidateTags" in $$props2) $$invalidate(8, consolidateTags = $$props2.consolidateTags);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*column, $columnTagTableStore*/
    2097154) {
      $: $$invalidate(14, columnTitle = getColumnTitle(column, $columnTagTableStore));
    }
    if ($$self.$$.dirty & /*column, columnTagTableStore, $columnColourTableStore*/
    1048610) {
      $: $$invalidate(13, columnColor = isColumnTag(column, columnTagTableStore) ? $columnColourTableStore[column] : void 0);
    }
    if ($$self.$$.dirty & /*tasks*/
    8) {
      $: $$invalidate(12, sortedTasks = tasks.sort((a, b) => {
        if (a.path === b.path) {
          return a.rowIndex - b.rowIndex;
        } else {
          return a.path.localeCompare(b.path);
        }
      }));
    }
    if ($$self.$$.dirty & /*$isDraggingStore*/
    524288) {
      $: $$invalidate(10, draggingData = $isDraggingStore);
    }
    if ($$self.$$.dirty & /*draggingData, column*/
    1026) {
      $: canDrop = draggingData && draggingData.fromColumn !== column;
    }
    if ($$self.$$.dirty & /*buttonEl*/
    512) {
      $: {
        if (buttonEl) {
          (0, import_obsidian4.setIcon)(buttonEl, "lucide-plus");
        }
      }
    }
  };
  return [
    app,
    column,
    hideOnEmpty,
    tasks,
    taskActions,
    columnTagTableStore,
    columnColourTableStore,
    showFilepath,
    consolidateTags,
    buttonEl,
    draggingData,
    isDraggedOver,
    sortedTasks,
    columnColor,
    columnTitle,
    showMenu,
    handleDragOver,
    handleDragLeave,
    handleDrop,
    $isDraggingStore,
    $columnColourTableStore,
    $columnTagTableStore,
    span_binding,
    click_handler
  ];
}
var Column = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance4,
      create_fragment4,
      safe_not_equal,
      {
        app: 0,
        column: 1,
        hideOnEmpty: 2,
        tasks: 3,
        taskActions: 4,
        columnTagTableStore: 5,
        columnColourTableStore: 6,
        showFilepath: 7,
        consolidateTags: 8
      },
      add_css3
    );
  }
};
var column_default = Column;

// node_modules/@floating-ui/utils/dist/floating-ui.utils.mjs
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = (v) => ({
  x: v,
  y: v
});
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return ["top", "bottom"].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  const alignment = getAlignment(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const length = getAxisLength(alignmentAxis);
  let mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [mainAlignmentSide, getOppositePlacement(mainAlignmentSide)];
}
function getExpandedPlacements(placement) {
  const oppositePlacement = getOppositePlacement(placement);
  return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, (alignment) => oppositeAlignmentMap[alignment]);
}
function getSideList(side, isStart, rtl) {
  const lr = ["left", "right"];
  const rl = ["right", "left"];
  const tb = ["top", "bottom"];
  const bt = ["bottom", "top"];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl) return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  const alignment = getAlignment(placement);
  let list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map((side) => side + "-" + alignment);
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, (side) => oppositeSideMap[side]);
}
function expandPaddingObject(padding) {
  return {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0,
    ...padding
  };
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return {
    ...rect,
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  };
}

// node_modules/@floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  let {
    reference,
    floating
  } = _ref;
  const sideAxis = getSideAxis(placement);
  const alignmentAxis = getAlignmentAxis(placement);
  const alignLength = getAxisLength(alignmentAxis);
  const side = getSide(placement);
  const isVertical = sideAxis === "y";
  const commonX = reference.x + reference.width / 2 - floating.width / 2;
  const commonY = reference.y + reference.height / 2 - floating.height / 2;
  const commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  let coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = async (reference, floating, config) => {
  const {
    placement = "bottom",
    strategy = "absolute",
    middleware = [],
    platform: platform2
  } = config;
  const validMiddleware = middleware.filter(Boolean);
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(floating));
  let rects = await platform2.getElementRects({
    reference,
    floating,
    strategy
  });
  let {
    x,
    y
  } = computeCoordsFromPlacement(rects, placement, rtl);
  let statefulPlacement = placement;
  let middlewareData = {};
  let resetCount = 0;
  for (let i = 0; i < validMiddleware.length; i++) {
    const {
      name,
      fn
    } = validMiddleware[i];
    const {
      x: nextX,
      y: nextY,
      data,
      reset
    } = await fn({
      x,
      y,
      initialPlacement: placement,
      placement: statefulPlacement,
      strategy,
      middlewareData,
      rects,
      platform: platform2,
      elements: {
        reference,
        floating
      }
    });
    x = nextX != null ? nextX : x;
    y = nextY != null ? nextY : y;
    middlewareData = {
      ...middlewareData,
      [name]: {
        ...middlewareData[name],
        ...data
      }
    };
    if (reset && resetCount <= 50) {
      resetCount++;
      if (typeof reset === "object") {
        if (reset.placement) {
          statefulPlacement = reset.placement;
        }
        if (reset.rects) {
          rects = reset.rects === true ? await platform2.getElementRects({
            reference,
            floating,
            strategy
          }) : reset.rects;
        }
        ({
          x,
          y
        } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
      }
      i = -1;
    }
  }
  return {
    x,
    y,
    placement: statefulPlacement,
    strategy,
    middlewareData
  };
};
async function detectOverflow(state, options) {
  var _await$platform$isEle;
  if (options === void 0) {
    options = {};
  }
  const {
    x,
    y,
    platform: platform2,
    rects,
    elements,
    strategy
  } = state;
  const {
    boundary = "clippingAncestors",
    rootBoundary = "viewport",
    elementContext = "floating",
    altBoundary = false,
    padding = 0
  } = evaluate(options, state);
  const paddingObject = getPaddingObject(padding);
  const altContext = elementContext === "floating" ? "reference" : "floating";
  const element2 = elements[altBoundary ? altContext : elementContext];
  const clippingClientRect = rectToClientRect(await platform2.getClippingRect({
    element: ((_await$platform$isEle = await (platform2.isElement == null ? void 0 : platform2.isElement(element2))) != null ? _await$platform$isEle : true) ? element2 : element2.contextElement || await (platform2.getDocumentElement == null ? void 0 : platform2.getDocumentElement(elements.floating)),
    boundary,
    rootBoundary,
    strategy
  }));
  const rect = elementContext === "floating" ? {
    ...rects.floating,
    x,
    y
  } : rects.reference;
  const offsetParent = await (platform2.getOffsetParent == null ? void 0 : platform2.getOffsetParent(elements.floating));
  const offsetScale = await (platform2.isElement == null ? void 0 : platform2.isElement(offsetParent)) ? await (platform2.getScale == null ? void 0 : platform2.getScale(offsetParent)) || {
    x: 1,
    y: 1
  } : {
    x: 1,
    y: 1
  };
  const elementClientRect = rectToClientRect(platform2.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform2.convertOffsetParentRelativeRectToViewportRelativeRect({
    elements,
    rect,
    offsetParent,
    strategy
  }) : rect);
  return {
    top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
    bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
    left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
    right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
  };
}
var flip = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    async fn(state) {
      var _middlewareData$arrow, _middlewareData$flip;
      const {
        placement,
        middlewareData,
        rects,
        initialPlacement,
        platform: platform2,
        elements
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = true,
        fallbackPlacements: specifiedFallbackPlacements,
        fallbackStrategy = "bestFit",
        fallbackAxisSideDirection = "none",
        flipAlignment = true,
        ...detectOverflowOptions
      } = evaluate(options, state);
      if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      const side = getSide(placement);
      const isBasePlacement = getSide(initialPlacement) === initialPlacement;
      const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
      const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
      if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
        fallbackPlacements.push(...getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl));
      }
      const placements2 = [initialPlacement, ...fallbackPlacements];
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const overflows = [];
      let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
      if (checkMainAxis) {
        overflows.push(overflow[side]);
      }
      if (checkCrossAxis) {
        const sides2 = getAlignmentSides(placement, rects, rtl);
        overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
      }
      overflowsData = [...overflowsData, {
        placement,
        overflows
      }];
      if (!overflows.every((side2) => side2 <= 0)) {
        var _middlewareData$flip2, _overflowsData$filter;
        const nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
        const nextPlacement = placements2[nextIndex];
        if (nextPlacement) {
          return {
            data: {
              index: nextIndex,
              overflows: overflowsData
            },
            reset: {
              placement: nextPlacement
            }
          };
        }
        let resetPlacement = (_overflowsData$filter = overflowsData.filter((d) => d.overflows[0] <= 0).sort((a, b) => a.overflows[1] - b.overflows[1])[0]) == null ? void 0 : _overflowsData$filter.placement;
        if (!resetPlacement) {
          switch (fallbackStrategy) {
            case "bestFit": {
              var _overflowsData$map$so;
              const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d.placement, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0];
              if (placement2) {
                resetPlacement = placement2;
              }
              break;
            }
            case "initialPlacement":
              resetPlacement = initialPlacement;
              break;
          }
        }
        if (placement !== resetPlacement) {
          return {
            reset: {
              placement: resetPlacement
            }
          };
        }
      }
      return {};
    }
  };
};
async function convertValueToCoords(state, options) {
  const {
    placement,
    platform: platform2,
    elements
  } = state;
  const rtl = await (platform2.isRTL == null ? void 0 : platform2.isRTL(elements.floating));
  const side = getSide(placement);
  const alignment = getAlignment(placement);
  const isVertical = getSideAxis(placement) === "y";
  const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
  const crossAxisMulti = rtl && isVertical ? -1 : 1;
  const rawValue = evaluate(options, state);
  let {
    mainAxis,
    crossAxis,
    alignmentAxis
  } = typeof rawValue === "number" ? {
    mainAxis: rawValue,
    crossAxis: 0,
    alignmentAxis: null
  } : {
    mainAxis: 0,
    crossAxis: 0,
    alignmentAxis: null,
    ...rawValue
  };
  if (alignment && typeof alignmentAxis === "number") {
    crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
  }
  return isVertical ? {
    x: crossAxis * crossAxisMulti,
    y: mainAxis * mainAxisMulti
  } : {
    x: mainAxis * mainAxisMulti,
    y: crossAxis * crossAxisMulti
  };
}
var offset = function(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    async fn(state) {
      var _middlewareData$offse, _middlewareData$arrow;
      const {
        x,
        y,
        placement,
        middlewareData
      } = state;
      const diffCoords = await convertValueToCoords(state, options);
      if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
        return {};
      }
      return {
        x: x + diffCoords.x,
        y: y + diffCoords.y,
        data: {
          ...diffCoords,
          placement
        }
      };
    }
  };
};
var shift = function(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    async fn(state) {
      const {
        x,
        y,
        placement
      } = state;
      const {
        mainAxis: checkMainAxis = true,
        crossAxis: checkCrossAxis = false,
        limiter = {
          fn: (_ref) => {
            let {
              x: x2,
              y: y2
            } = _ref;
            return {
              x: x2,
              y: y2
            };
          }
        },
        ...detectOverflowOptions
      } = evaluate(options, state);
      const coords = {
        x,
        y
      };
      const overflow = await detectOverflow(state, detectOverflowOptions);
      const crossAxis = getSideAxis(getSide(placement));
      const mainAxis = getOppositeAxis(crossAxis);
      let mainAxisCoord = coords[mainAxis];
      let crossAxisCoord = coords[crossAxis];
      if (checkMainAxis) {
        const minSide = mainAxis === "y" ? "top" : "left";
        const maxSide = mainAxis === "y" ? "bottom" : "right";
        const min2 = mainAxisCoord + overflow[minSide];
        const max2 = mainAxisCoord - overflow[maxSide];
        mainAxisCoord = clamp(min2, mainAxisCoord, max2);
      }
      if (checkCrossAxis) {
        const minSide = crossAxis === "y" ? "top" : "left";
        const maxSide = crossAxis === "y" ? "bottom" : "right";
        const min2 = crossAxisCoord + overflow[minSide];
        const max2 = crossAxisCoord - overflow[maxSide];
        crossAxisCoord = clamp(min2, crossAxisCoord, max2);
      }
      const limitedCoords = limiter.fn({
        ...state,
        [mainAxis]: mainAxisCoord,
        [crossAxis]: crossAxisCoord
      });
      return {
        ...limitedCoords,
        data: {
          x: limitedCoords.x - x,
          y: limitedCoords.y - y
        }
      };
    }
  };
};

// node_modules/@floating-ui/utils/dist/floating-ui.utils.dom.mjs
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return value instanceof Node || value instanceof getWindow(value).Node;
}
function isElement(value) {
  return value instanceof Element || value instanceof getWindow(value).Element;
}
function isHTMLElement(value) {
  return value instanceof HTMLElement || value instanceof getWindow(value).HTMLElement;
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return value instanceof ShadowRoot || value instanceof getWindow(value).ShadowRoot;
}
function isOverflowElement(element2) {
  const {
    overflow,
    overflowX,
    overflowY,
    display
  } = getComputedStyle2(element2);
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && !["inline", "contents"].includes(display);
}
function isTableElement(element2) {
  return ["table", "td", "th"].includes(getNodeName(element2));
}
function isContainingBlock(element2) {
  const webkit = isWebKit();
  const css = getComputedStyle2(element2);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || ["transform", "perspective", "filter"].some((value) => (css.willChange || "").includes(value)) || ["paint", "layout", "strict", "content"].some((value) => (css.contain || "").includes(value));
}
function getContainingBlock(element2) {
  let currentNode = getParentNode(element2);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports) return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return ["html", "body", "#document"].includes(getNodeName(node));
}
function getComputedStyle2(element2) {
  return getWindow(element2).getComputedStyle(element2);
}
function getNodeScroll(element2) {
  if (isElement(element2)) {
    return {
      scrollLeft: element2.scrollLeft,
      scrollTop: element2.scrollTop
    };
  }
  return {
    scrollLeft: element2.pageXOffset,
    scrollTop: element2.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  const result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  const parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  const scrollableAncestor = getNearestOverflowAncestor(node);
  const isBody = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  const win = getWindow(scrollableAncestor);
  if (isBody) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element2) {
  const css = getComputedStyle2(element2);
  let width = parseFloat(css.width) || 0;
  let height = parseFloat(css.height) || 0;
  const hasOffset = isHTMLElement(element2);
  const offsetWidth = hasOffset ? element2.offsetWidth : width;
  const offsetHeight = hasOffset ? element2.offsetHeight : height;
  const shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element2) {
  return !isElement(element2) ? element2.contextElement : element2;
}
function getScale(element2) {
  const domElement = unwrapElement(element2);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  const rect = domElement.getBoundingClientRect();
  const {
    width,
    height,
    $
  } = getCssDimensions(domElement);
  let x = ($ ? round(rect.width) : rect.width) / width;
  let y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = /* @__PURE__ */ createCoords(0);
function getVisualOffsets(element2) {
  const win = getWindow(element2);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element2, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element2)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect(element2, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  const clientRect = element2.getBoundingClientRect();
  const domElement = unwrapElement(element2);
  let scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element2);
    }
  }
  const visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  let x = (clientRect.left + visualOffsets.x) / scale.x;
  let y = (clientRect.top + visualOffsets.y) / scale.y;
  let width = clientRect.width / scale.x;
  let height = clientRect.height / scale.y;
  if (domElement) {
    const win = getWindow(domElement);
    const offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    let currentWin = win;
    let currentIFrame = currentWin.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== currentWin) {
      const iframeScale = getScale(currentIFrame);
      const iframeRect = currentIFrame.getBoundingClientRect();
      const css = getComputedStyle2(currentIFrame);
      const left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      const top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentWin = getWindow(currentIFrame);
      currentIFrame = currentWin.frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [":popover-open", ":modal"];
function isTopLayer(element2) {
  return topLayerSelectors.some((selector) => {
    try {
      return element2.matches(selector);
    } catch (e) {
      return false;
    }
  });
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  let {
    elements,
    rect,
    offsetParent,
    strategy
  } = _ref;
  const isFixed = strategy === "fixed";
  const documentElement = getDocumentElement(offsetParent);
  const topLayer = elements ? isTopLayer(elements.floating) : false;
  if (offsetParent === documentElement || topLayer && isFixed) {
    return rect;
  }
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  let scale = createCoords(1);
  const offsets = createCoords(0);
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      const offsetRect = getBoundingClientRect(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element2) {
  return Array.from(element2.getClientRects());
}
function getWindowScrollBarX(element2) {
  return getBoundingClientRect(getDocumentElement(element2)).left + getNodeScroll(element2).scrollLeft;
}
function getDocumentRect(element2) {
  const html = getDocumentElement(element2);
  const scroll = getNodeScroll(element2);
  const body = element2.ownerDocument.body;
  const width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  const height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  let x = -scroll.scrollLeft + getWindowScrollBarX(element2);
  const y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element2, strategy) {
  const win = getWindow(element2);
  const html = getDocumentElement(element2);
  const visualViewport = win.visualViewport;
  let width = html.clientWidth;
  let height = html.clientHeight;
  let x = 0;
  let y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    const visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element2, strategy) {
  const clientRect = getBoundingClientRect(element2, true, strategy === "fixed");
  const top = clientRect.top + element2.clientTop;
  const left = clientRect.left + element2.clientLeft;
  const scale = isHTMLElement(element2) ? getScale(element2) : createCoords(1);
  const width = element2.clientWidth * scale.x;
  const height = element2.clientHeight * scale.y;
  const x = left * scale.x;
  const y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element2, clippingAncestor, strategy) {
  let rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element2, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element2));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    const visualOffsets = getVisualOffsets(element2);
    rect = {
      ...clippingAncestor,
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    };
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element2, stopNode) {
  const parentNode = getParentNode(element2);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element2, cache) {
  const cachedResult = cache.get(element2);
  if (cachedResult) {
    return cachedResult;
  }
  let result = getOverflowAncestors(element2, [], false).filter((el) => isElement(el) && getNodeName(el) !== "body");
  let currentContainingBlockComputedStyle = null;
  const elementIsFixed = getComputedStyle2(element2).position === "fixed";
  let currentNode = elementIsFixed ? getParentNode(element2) : element2;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    const computedStyle = getComputedStyle2(currentNode);
    const currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    const shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && ["absolute", "fixed"].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element2, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter((ancestor) => ancestor !== currentNode);
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element2, result);
  return result;
}
function getClippingRect(_ref) {
  let {
    element: element2,
    boundary,
    rootBoundary,
    strategy
  } = _ref;
  const elementClippingAncestors = boundary === "clippingAncestors" ? isTopLayer(element2) ? [] : getClippingElementAncestors(element2, this._c) : [].concat(boundary);
  const clippingAncestors = [...elementClippingAncestors, rootBoundary];
  const firstClippingAncestor = clippingAncestors[0];
  const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
    const rect = getClientRectFromClippingAncestor(element2, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element2, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element2) {
  const {
    width,
    height
  } = getCssDimensions(element2);
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element2, offsetParent, strategy) {
  const isOffsetParentAnElement = isHTMLElement(offsetParent);
  const documentElement = getDocumentElement(offsetParent);
  const isFixed = strategy === "fixed";
  const rect = getBoundingClientRect(element2, true, isFixed, offsetParent);
  let scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  const offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      const offsetRect = getBoundingClientRect(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  const x = rect.left + scroll.scrollLeft - offsets.x;
  const y = rect.top + scroll.scrollTop - offsets.y;
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function isStaticPositioned(element2) {
  return getComputedStyle2(element2).position === "static";
}
function getTrueOffsetParent(element2, polyfill) {
  if (!isHTMLElement(element2) || getComputedStyle2(element2).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element2);
  }
  return element2.offsetParent;
}
function getOffsetParent(element2, polyfill) {
  const win = getWindow(element2);
  if (isTopLayer(element2)) {
    return win;
  }
  if (!isHTMLElement(element2)) {
    let svgOffsetParent = getParentNode(element2);
    while (svgOffsetParent && !isLastTraversableNode(svgOffsetParent)) {
      if (isElement(svgOffsetParent) && !isStaticPositioned(svgOffsetParent)) {
        return svgOffsetParent;
      }
      svgOffsetParent = getParentNode(svgOffsetParent);
    }
    return win;
  }
  let offsetParent = getTrueOffsetParent(element2, polyfill);
  while (offsetParent && isTableElement(offsetParent) && isStaticPositioned(offsetParent)) {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && isLastTraversableNode(offsetParent) && isStaticPositioned(offsetParent) && !isContainingBlock(offsetParent)) {
    return win;
  }
  return offsetParent || getContainingBlock(element2) || win;
}
var getElementRects = async function(data) {
  const getOffsetParentFn = this.getOffsetParent || getOffsetParent;
  const getDimensionsFn = this.getDimensions;
  const floatingDimensions = await getDimensionsFn(data.floating);
  return {
    reference: getRectRelativeToOffsetParent(data.reference, await getOffsetParentFn(data.floating), data.strategy),
    floating: {
      x: 0,
      y: 0,
      width: floatingDimensions.width,
      height: floatingDimensions.height
    }
  };
};
function isRTL(element2) {
  return getComputedStyle2(element2).direction === "rtl";
}
var platform = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element2, onMove) {
  let io = null;
  let timeoutId;
  const root = getDocumentElement(element2);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    const {
      left,
      top,
      width,
      height
    } = element2.getBoundingClientRect();
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    const insetTop = floor(top);
    const insetRight = floor(root.clientWidth - (left + width));
    const insetBottom = floor(root.clientHeight - (top + height));
    const insetLeft = floor(left);
    const rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    const options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    let isFirstUpdate = true;
    function handleObserve(entries) {
      const ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(() => {
            refresh(false, 1e-7);
          }, 1e3);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, {
        ...options,
        // Handle <iframe>s
        root: root.ownerDocument
      });
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element2);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update2, options) {
  if (options === void 0) {
    options = {};
  }
  const {
    ancestorScroll = true,
    ancestorResize = true,
    elementResize = typeof ResizeObserver === "function",
    layoutShift = typeof IntersectionObserver === "function",
    animationFrame = false
  } = options;
  const referenceEl = unwrapElement(reference);
  const ancestors = ancestorScroll || ancestorResize ? [...referenceEl ? getOverflowAncestors(referenceEl) : [], ...getOverflowAncestors(floating)] : [];
  ancestors.forEach((ancestor) => {
    ancestorScroll && ancestor.addEventListener("scroll", update2, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update2);
  });
  const cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update2) : null;
  let reobserveFrame = -1;
  let resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver((_ref) => {
      let [firstEntry] = _ref;
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(() => {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update2();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  let frameId;
  let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    const nextRefRect = getBoundingClientRect(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update2();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update2();
  return () => {
    var _resizeObserver2;
    ancestors.forEach((ancestor) => {
      ancestorScroll && ancestor.removeEventListener("scroll", update2);
      ancestorResize && ancestor.removeEventListener("resize", update2);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var offset2 = offset;
var shift2 = shift;
var flip2 = flip;
var computePosition2 = (reference, floating, options) => {
  const cache = /* @__PURE__ */ new Map();
  const mergedOptions = {
    platform,
    ...options
  };
  const platformWithCache = {
    ...mergedOptions.platform,
    _c: cache
  };
  return computePosition(reference, floating, {
    ...mergedOptions,
    platform: platformWithCache
  });
};

// node_modules/svelte-floating-ui/index.js
function createFloatingActions(initOptions) {
  let referenceElement;
  let floatingElement;
  const defaultOptions = {
    autoUpdate: true
  };
  let options = initOptions;
  const getOptions = (mixin) => {
    return { ...defaultOptions, ...initOptions || {}, ...mixin || {} };
  };
  const updatePosition = (updateOptions) => {
    if (referenceElement && floatingElement) {
      options = getOptions(updateOptions);
      computePosition2(referenceElement, floatingElement, options).then((v) => {
        Object.assign(floatingElement.style, {
          position: v.strategy,
          left: `${v.x}px`,
          top: `${v.y}px`
        });
        (options == null ? void 0 : options.onComputed) && options.onComputed(v);
      });
    }
  };
  const referenceAction = (node) => {
    if ("subscribe" in node) {
      setupVirtualElementObserver(node);
      return {};
    } else {
      referenceElement = node;
      updatePosition();
    }
  };
  const contentAction = (node, contentOptions) => {
    let autoUpdateDestroy;
    floatingElement = node;
    options = getOptions(contentOptions);
    setTimeout(() => updatePosition(contentOptions), 0);
    updatePosition(contentOptions);
    const destroyAutoUpdate = () => {
      if (autoUpdateDestroy) {
        autoUpdateDestroy();
        autoUpdateDestroy = void 0;
      }
    };
    const initAutoUpdate = ({ autoUpdate: autoUpdate2 } = options || {}) => {
      destroyAutoUpdate();
      if (autoUpdate2 !== false) {
        tick().then(() => {
          return autoUpdate(referenceElement, floatingElement, () => updatePosition(options), autoUpdate2 === true ? {} : autoUpdate2);
        });
      }
      return;
    };
    autoUpdateDestroy = initAutoUpdate();
    return {
      update(contentOptions2) {
        updatePosition(contentOptions2);
        autoUpdateDestroy = initAutoUpdate(contentOptions2);
      },
      destroy() {
        destroyAutoUpdate();
      }
    };
  };
  const setupVirtualElementObserver = (node) => {
    const unsubscribe = node.subscribe(($node) => {
      if (referenceElement === void 0) {
        referenceElement = $node;
        updatePosition();
      } else {
        Object.assign(referenceElement, $node);
        updatePosition();
      }
    });
    onDestroy(unsubscribe);
  };
  return [
    referenceAction,
    contentAction,
    updatePosition
  ];
}

// node_modules/svelte-select/filter.js
function filter({
  loadOptions,
  filterText,
  items,
  multiple,
  value,
  itemId,
  groupBy,
  filterSelectedItems,
  itemFilter,
  convertStringItemsToObjects: convertStringItemsToObjects2,
  filterGroupedItems,
  label
}) {
  if (items && loadOptions) return items;
  if (!items) return [];
  if (items && items.length > 0 && typeof items[0] !== "object") {
    items = convertStringItemsToObjects2(items);
  }
  let filterResults = items.filter((item) => {
    let matchesFilter = itemFilter(item[label], filterText, item);
    if (matchesFilter && multiple && (value == null ? void 0 : value.length)) {
      matchesFilter = !value.some((x) => {
        return filterSelectedItems ? x[itemId] === item[itemId] : false;
      });
    }
    return matchesFilter;
  });
  if (groupBy) {
    filterResults = filterGroupedItems(filterResults);
  }
  return filterResults;
}

// node_modules/svelte-select/get-items.js
async function getItems({ dispatch, loadOptions, convertStringItemsToObjects: convertStringItemsToObjects2, filterText }) {
  let res = await loadOptions(filterText).catch((err) => {
    console.warn("svelte-select loadOptions error :>> ", err);
    dispatch("error", { type: "loadOptions", details: err });
  });
  if (res && !res.cancelled) {
    if (res) {
      if (res && res.length > 0 && typeof res[0] !== "object") {
        res = convertStringItemsToObjects2(res);
      }
      dispatch("loaded", { items: res });
    } else {
      res = [];
    }
    return {
      filteredItems: res,
      loading: false,
      focused: true,
      listOpen: true
    };
  }
}

// node_modules/svelte-select/ChevronIcon.svelte
function add_css4(target) {
  append_styles(target, "svelte-qbd276", "svg.svelte-qbd276{width:var(--chevron-icon-width, 20px);height:var(--chevron-icon-width, 20px);color:var(--chevron-icon-colour, currentColor)}");
}
function create_fragment5(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M4.516 7.548c0.436-0.446 1.043-0.481 1.576 0l3.908 3.747\n          3.908-3.747c0.533-0.481 1.141-0.446 1.574 0 0.436 0.445 0.408 1.197 0\n          1.615-0.406 0.418-4.695 4.502-4.695 4.502-0.217 0.223-0.502\n          0.335-0.787 0.335s-0.57-0.112-0.789-0.335c0\n          0-4.287-4.084-4.695-4.502s-0.436-1.17 0-1.615z");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "0 0 20 20");
      attr(svg, "focusable", "false");
      attr(svg, "aria-hidden", "true");
      attr(svg, "class", "svelte-qbd276");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
var ChevronIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment5, safe_not_equal, {}, add_css4);
  }
};
var ChevronIcon_default = ChevronIcon;

// node_modules/svelte-select/ClearIcon.svelte
function add_css5(target) {
  append_styles(target, "svelte-whdbu1", "svg.svelte-whdbu1{width:var(--clear-icon-width, 20px);height:var(--clear-icon-width, 20px);color:var(--clear-icon-color, currentColor)}");
}
function create_fragment6(ctx) {
  let svg;
  let path;
  return {
    c() {
      svg = svg_element("svg");
      path = svg_element("path");
      attr(path, "fill", "currentColor");
      attr(path, "d", "M34.923,37.251L24,26.328L13.077,37.251L9.436,33.61l10.923-10.923L9.436,11.765l3.641-3.641L24,19.047L34.923,8.124\n    l3.641,3.641L27.641,22.688L38.564,33.61L34.923,37.251z");
      attr(svg, "width", "100%");
      attr(svg, "height", "100%");
      attr(svg, "viewBox", "-2 -2 50 50");
      attr(svg, "focusable", "false");
      attr(svg, "aria-hidden", "true");
      attr(svg, "role", "presentation");
      attr(svg, "class", "svelte-whdbu1");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, path);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
var ClearIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment6, safe_not_equal, {}, add_css5);
  }
};
var ClearIcon_default = ClearIcon;

// node_modules/svelte-select/LoadingIcon.svelte
function add_css6(target) {
  append_styles(target, "svelte-1p3nqvd", ".loading.svelte-1p3nqvd{width:var(--spinner-width, 20px);height:var(--spinner-height, 20px);color:var(--spinner-color, var(--icons-color));animation:svelte-1p3nqvd-rotate 0.75s linear infinite;transform-origin:center center;transform:none}.circle_path.svelte-1p3nqvd{stroke-dasharray:90;stroke-linecap:round}@keyframes svelte-1p3nqvd-rotate{100%{transform:rotate(360deg)}}");
}
function create_fragment7(ctx) {
  let svg;
  let circle;
  return {
    c() {
      svg = svg_element("svg");
      circle = svg_element("circle");
      attr(circle, "class", "circle_path svelte-1p3nqvd");
      attr(circle, "cx", "50");
      attr(circle, "cy", "50");
      attr(circle, "r", "20");
      attr(circle, "fill", "none");
      attr(circle, "stroke", "currentColor");
      attr(circle, "stroke-width", "5");
      attr(circle, "stroke-miterlimit", "10");
      attr(svg, "class", "loading svelte-1p3nqvd");
      attr(svg, "viewBox", "25 25 50 50");
    },
    m(target, anchor) {
      insert(target, svg, anchor);
      append(svg, circle);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(svg);
      }
    }
  };
}
var LoadingIcon = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, null, create_fragment7, safe_not_equal, {}, add_css6);
  }
};
var LoadingIcon_default = LoadingIcon;

// node_modules/svelte-select/Select.svelte
function add_css7(target) {
  append_styles(target, "svelte-82qwg8", ".svelte-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{--borderRadius:var(--border-radius);--clearSelectColor:var(--clear-select-color);--clearSelectWidth:var(--clear-select-width);--disabledBackground:var(--disabled-background);--disabledBorderColor:var(--disabled-border-color);--disabledColor:var(--disabled-color);--disabledPlaceholderColor:var(--disabled-placeholder-color);--disabledPlaceholderOpacity:var(--disabled-placeholder-opacity);--errorBackground:var(--error-background);--errorBorder:var(--error-border);--groupItemPaddingLeft:var(--group-item-padding-left);--groupTitleColor:var(--group-title-color);--groupTitleFontSize:var(--group-title-font-size);--groupTitleFontWeight:var(--group-title-font-weight);--groupTitlePadding:var(--group-title-padding);--groupTitleTextTransform:var(--group-title-text-transform);--groupTitleBorderColor:var(--group-title-border-color);--groupTitleBorderWidth:var(--group-title-border-width);--groupTitleBorderStyle:var(--group-title-border-style);--indicatorColor:var(--chevron-color);--indicatorHeight:var(--chevron-height);--indicatorWidth:var(--chevron-width);--inputColor:var(--input-color);--inputLeft:var(--input-left);--inputLetterSpacing:var(--input-letter-spacing);--inputMargin:var(--input-margin);--inputPadding:var(--input-padding);--itemActiveBackground:var(--item-active-background);--itemColor:var(--item-color);--itemFirstBorderRadius:var(--item-first-border-radius);--itemHoverBG:var(--item-hover-bg);--itemHoverColor:var(--item-hover-color);--itemIsActiveBG:var(--item-is-active-bg);--itemIsActiveColor:var(--item-is-active-color);--itemIsNotSelectableColor:var(--item-is-not-selectable-color);--itemPadding:var(--item-padding);--listBackground:var(--list-background);--listBorder:var(--list-border);--listBorderRadius:var(--list-border-radius);--listEmptyColor:var(--list-empty-color);--listEmptyPadding:var(--list-empty-padding);--listEmptyTextAlign:var(--list-empty-text-align);--listMaxHeight:var(--list-max-height);--listPosition:var(--list-position);--listShadow:var(--list-shadow);--listZIndex:var(--list-z-index);--multiItemBG:var(--multi-item-bg);--multiItemBorderRadius:var(--multi-item-border-radius);--multiItemDisabledHoverBg:var(--multi-item-disabled-hover-bg);--multiItemDisabledHoverColor:var(--multi-item-disabled-hover-color);--multiItemHeight:var(--multi-item-height);--multiItemMargin:var(--multi-item-margin);--multiItemPadding:var(--multi-item-padding);--multiSelectInputMargin:var(--multi-select-input-margin);--multiSelectInputPadding:var(--multi-select-input-padding);--multiSelectPadding:var(--multi-select-padding);--placeholderColor:var(--placeholder-color);--placeholderOpacity:var(--placeholder-opacity);--selectedItemPadding:var(--selected-item-padding);--spinnerColor:var(--spinner-color);--spinnerHeight:var(--spinner-height);--spinnerWidth:var(--spinner-width);--internal-padding:0 0 0 16px;border:var(--border, 1px solid #d8dbdf);border-radius:var(--border-radius, 6px);min-height:var(--height, 42px);position:relative;display:flex;align-items:stretch;padding:var(--padding, var(--internal-padding));background:var(--background, #fff);margin:var(--margin, 0);width:var(--width, 100%);font-size:var(--font-size, 16px);max-height:var(--max-height)}.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{box-sizing:var(--box-sizing, border-box)}.svelte-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:hover{border:var(--border-hover, 1px solid #b2b8bf)}.value-container.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;flex:1 1 0%;flex-wrap:wrap;align-items:center;gap:5px 10px;padding:var(--value-container-padding, 5px 0);position:relative;overflow:var(--value-container-overflow, hidden);align-self:stretch}.prepend.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.indicators.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;flex-shrink:0;align-items:center}.indicators.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:var(--indicators-position);top:var(--indicators-top);right:var(--indicators-right);bottom:var(--indicators-bottom)}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:absolute;cursor:default;border:none;color:var(--input-color, var(--item-color));padding:var(--input-padding, 0);letter-spacing:var(--input-letter-spacing, inherit);margin:var(--input-margin, 0);min-width:10px;top:0;right:0;bottom:0;left:0;background:transparent;font-size:var(--font-size, 16px)}.svelte-82qwg8:not(.multi)>.value-container.svelte-82qwg8>input.svelte-82qwg8{width:100%;height:100%}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8::placeholder{color:var(--placeholder-color, #78848f);opacity:var(--placeholder-opacity, 1)}input.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:none}.svelte-select.focused.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border:var(--border-focused, 1px solid #006fe8);border-radius:var(--border-radius-focused, var(--border-radius, 6px))}.disabled.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--disabled-background, #ebedef);border-color:var(--disabled-border-color, #ebedef);color:var(--disabled-color, #c1c6cc)}.disabled.svelte-82qwg8 input.svelte-82qwg8.svelte-82qwg8::placeholder{color:var(--disabled-placeholder-color, #c1c6cc);opacity:var(--disabled-placeholder-opacity, 1)}.selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{position:relative;overflow:var(--selected-item-overflow, hidden);padding:var(--selected-item-padding, 0 20px 0 0);text-overflow:ellipsis;white-space:nowrap;color:var(--selected-item-color, inherit);font-size:var(--font-size, 16px)}.multi.svelte-82qwg8 .selected-item.svelte-82qwg8.svelte-82qwg8{position:absolute;line-height:var(--height, 42px);height:var(--height, 42px)}.selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:none}.hide-selected-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0}.icon.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;align-items:center;justify-content:center}.clear-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{all:unset;display:flex;align-items:center;justify-content:center;width:var(--clear-select-width, 40px);height:var(--clear-select-height, 100%);color:var(--clear-select-color, var(--icons-color));margin:var(--clear-select-margin, 0);pointer-events:all;flex-shrink:0}.clear-select.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:focus{outline:var(--clear-select-focus-outline, 1px solid #006fe8)}.loading.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{width:var(--loading-width, 40px);height:var(--loading-height);color:var(--loading-color, var(--icons-color));margin:var(--loading--margin, 0);flex-shrink:0}.chevron.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{width:var(--chevron-width, 40px);height:var(--chevron-height, 40px);background:var(--chevron-background, transparent);pointer-events:var(--chevron-pointer-events, none);color:var(--chevron-color, var(--icons-color));border:var(--chevron-border, 0 0 0 1px solid #d8dbdf);flex-shrink:0}.multi.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{padding:var(--multi-select-padding, var(--internal-padding))}.multi.svelte-82qwg8 input.svelte-82qwg8.svelte-82qwg8{padding:var(--multi-select-input-padding, 0);position:relative;margin:var(--multi-select-input-margin, 5px 0);flex:1 1 40px}.svelte-select.error.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border:var(--error-border, 1px solid #ff2d55);background:var(--error-background, #fff)}.a11y-text.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{z-index:9999;border:0px;clip:rect(1px, 1px, 1px, 1px);height:1px;width:1px;position:absolute;overflow:hidden;padding:0px;white-space:nowrap}.multi-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--multi-item-bg, #ebedef);margin:var(--multi-item-margin, 0);outline:var(--multi-item-outline, 1px solid #ddd);border-radius:var(--multi-item-border-radius, 4px);height:var(--multi-item-height, 25px);line-height:var(--multi-item-height, 25px);display:flex;cursor:default;padding:var(--multi-item-padding, 0 5px);overflow:hidden;gap:var(--multi-item-gap, 4px);outline-offset:-1px;max-width:var(--multi-max-width, none);color:var(--multi-item-color, var(--item-color))}.multi-item.disabled.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:hover{background:var(--multi-item-disabled-hover-bg, #ebedef);color:var(--multi-item-disabled-hover-color, #c1c6cc)}.multi-item-text.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.multi-item-clear.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{display:flex;align-items:center;justify-content:center;--clear-icon-color:var(--multi-item-clear-icon-color, #000)}.multi-item.active.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{outline:var(--multi-item-active-outline, 1px solid #006fe8)}.svelte-select-list.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{box-shadow:var(--list-shadow, 0 2px 3px 0 rgba(44, 62, 80, 0.24));border-radius:var(--list-border-radius, 4px);max-height:var(--list-max-height, 252px);overflow-y:auto;background:var(--list-background, #fff);position:var(--list-position, absolute);z-index:var(--list-z-index, 2);border:var(--list-border)}.prefloat.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0;pointer-events:none}.list-group-title.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{color:var(--group-title-color, #8f8f8f);cursor:default;font-size:var(--group-title-font-size, 16px);font-weight:var(--group-title-font-weight, 600);height:var(--height, 42px);line-height:var(--height, 42px);padding:var(--group-title-padding, 0 20px);text-overflow:ellipsis;overflow-x:hidden;white-space:nowrap;text-transform:var(--group-title-text-transform, uppercase);border-width:var(--group-title-border-width, medium);border-style:var(--group-title-border-style, none);border-color:var(--group-title-border-color, color)}.empty.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{text-align:var(--list-empty-text-align, center);padding:var(--list-empty-padding, 20px 0);color:var(--list-empty-color, #78848f)}.item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{cursor:default;height:var(--item-height, var(--height, 42px));line-height:var(--item-line-height, var(--height, 42px));padding:var(--item-padding, 0 20px);color:var(--item-color, inherit);text-overflow:ellipsis;overflow:hidden;white-space:nowrap;transition:var(--item-transition, all 0.2s);align-items:center;width:100%}.item.group-item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{padding-left:var(--group-item-padding-left, 40px)}.item.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:active{background:var(--item-active-background, #b9daff)}.item.active.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{background:var(--item-is-active-bg, #007aff);color:var(--item-is-active-color, #fff)}.item.first.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{border-radius:var(--item-first-border-radius, 4px 4px 0 0)}.item.hover.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:not(.active){background:var(--item-hover-bg, #e7f2ff);color:var(--item-hover-color, inherit)}.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.hover.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.active.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8,.item.not-selectable.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8:active{color:var(--item-is-not-selectable-color, #999);background:transparent}.required.svelte-82qwg8.svelte-82qwg8.svelte-82qwg8{opacity:0;z-index:-1;position:absolute;top:0;left:0;bottom:0;right:0}");
}
var get_required_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
8 });
var get_required_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[3]
) });
var get_input_hidden_slot_changes = (dirty) => ({ value: dirty[0] & /*value*/
8 });
var get_input_hidden_slot_context = (ctx) => ({ value: (
  /*value*/
  ctx[3]
) });
var get_chevron_icon_slot_changes = (dirty) => ({ listOpen: dirty[0] & /*listOpen*/
64 });
var get_chevron_icon_slot_context = (ctx) => ({ listOpen: (
  /*listOpen*/
  ctx[6]
) });
var get_clear_icon_slot_changes = (dirty) => ({});
var get_clear_icon_slot_context = (ctx) => ({});
var get_loading_icon_slot_changes = (dirty) => ({});
var get_loading_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes_1 = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context_1 = (ctx) => ({ selection: (
  /*value*/
  ctx[3]
) });
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[126] = list[i];
  child_ctx[128] = i;
  return child_ctx;
}
var get_multi_clear_icon_slot_changes = (dirty) => ({});
var get_multi_clear_icon_slot_context = (ctx) => ({});
var get_selection_slot_changes = (dirty) => ({ selection: dirty[0] & /*value*/
8 });
var get_selection_slot_context = (ctx) => ({
  selection: (
    /*item*/
    ctx[126]
  ),
  index: (
    /*i*/
    ctx[128]
  )
});
var get_prepend_slot_changes = (dirty) => ({});
var get_prepend_slot_context = (ctx) => ({});
var get_list_append_slot_changes = (dirty) => ({});
var get_list_append_slot_context = (ctx) => ({});
var get_empty_slot_changes = (dirty) => ({});
var get_empty_slot_context = (ctx) => ({});
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[126] = list[i];
  child_ctx[128] = i;
  return child_ctx;
}
var get_item_slot_changes = (dirty) => ({
  item: dirty[0] & /*filteredItems*/
  16777216
});
var get_item_slot_context = (ctx) => ({
  item: (
    /*item*/
    ctx[126]
  ),
  index: (
    /*i*/
    ctx[128]
  )
});
var get_list_slot_changes = (dirty) => ({
  filteredItems: dirty[0] & /*filteredItems*/
  16777216
});
var get_list_slot_context = (ctx) => ({ filteredItems: (
  /*filteredItems*/
  ctx[24]
) });
var get_list_prepend_slot_changes = (dirty) => ({});
var get_list_prepend_slot_context = (ctx) => ({});
function create_if_block_8(ctx) {
  let div;
  let t0;
  let current_block_type_index;
  let if_block1;
  let t1;
  let floatingContent_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*$$slots*/
    ctx[50]["list-prepend"] && create_if_block_13(ctx)
  );
  const if_block_creators = [create_if_block_10, create_if_block_11, create_if_block_122];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*$$slots*/
      ctx2[50].list
    ) return 0;
    if (
      /*filteredItems*/
      ctx2[24].length > 0
    ) return 1;
    if (!/*hideEmptyState*/
    ctx2[19]) return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, [-1, -1, -1, -1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  let if_block2 = (
    /*$$slots*/
    ctx[50]["list-append"] && create_if_block_9(ctx)
  );
  return {
    c() {
      div = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      if (if_block1) if_block1.c();
      t1 = space();
      if (if_block2) if_block2.c();
      attr(div, "class", "svelte-select-list svelte-82qwg8");
      attr(div, "role", "none");
      toggle_class(
        div,
        "prefloat",
        /*prefloat*/
        ctx[28]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (if_block0) if_block0.m(div, null);
      append(div, t0);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div, null);
      }
      append(div, t1);
      if (if_block2) if_block2.m(div, null);
      ctx[91](div);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(floatingContent_action = /*floatingContent*/
          ctx[49].call(null, div)),
          listen(
            div,
            "scroll",
            /*handleListScroll*/
            ctx[41]
          ),
          listen(div, "pointerup", stop_propagation(prevent_default(
            /*pointerup_handler*/
            ctx[85]
          ))),
          listen(div, "mousedown", stop_propagation(prevent_default(
            /*mousedown_handler*/
            ctx[86]
          )))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*$$slots*/
        ctx2[50]["list-prepend"]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_13(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block1.c();
          } else {
            if_block1.p(ctx2, dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div, t1);
        } else {
          if_block1 = null;
        }
      }
      if (
        /*$$slots*/
        ctx2[50]["list-append"]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[1] & /*$$slots*/
          524288) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_9(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*prefloat*/
      268435456) {
        toggle_class(
          div,
          "prefloat",
          /*prefloat*/
          ctx2[28]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(if_block1);
      transition_in(if_block2);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      transition_out(if_block2);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (if_block0) if_block0.d();
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      if (if_block2) if_block2.d();
      ctx[91](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_13(ctx) {
  let current;
  const list_prepend_slot_template = (
    /*#slots*/
    ctx[83]["list-prepend"]
  );
  const list_prepend_slot = create_slot(
    list_prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_prepend_slot_context
  );
  return {
    c() {
      if (list_prepend_slot) list_prepend_slot.c();
    },
    m(target, anchor) {
      if (list_prepend_slot) {
        list_prepend_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (list_prepend_slot) {
        if (list_prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_prepend_slot,
            list_prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_prepend_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_prepend_slot_changes
            ),
            get_list_prepend_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(list_prepend_slot, local);
      current = true;
    },
    o(local) {
      transition_out(list_prepend_slot, local);
      current = false;
    },
    d(detaching) {
      if (list_prepend_slot) list_prepend_slot.d(detaching);
    }
  };
}
function create_if_block_122(ctx) {
  let current;
  const empty_slot_template = (
    /*#slots*/
    ctx[83].empty
  );
  const empty_slot = create_slot(
    empty_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_empty_slot_context
  );
  const empty_slot_or_fallback = empty_slot || fallback_block_9(ctx);
  return {
    c() {
      if (empty_slot_or_fallback) empty_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (empty_slot_or_fallback) {
        empty_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (empty_slot) {
        if (empty_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            empty_slot,
            empty_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              empty_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_empty_slot_changes
            ),
            get_empty_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(empty_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(empty_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (empty_slot_or_fallback) empty_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_11(ctx) {
  let each_1_anchor;
  let current;
  let each_value_1 = ensure_array_like(
    /*filteredItems*/
    ctx[24]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*filteredItems, value, itemId, listDom, scrollToHoverItem, hoverItemIndex, label*/
      1627402376 | dirty[1] & /*handleHover, handleItemClick, isItemActive*/
      28672 | dirty[2] & /*$$scope*/
      1048576) {
        each_value_1 = ensure_array_like(
          /*filteredItems*/
          ctx2[24]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_1(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let current;
  const list_slot_template = (
    /*#slots*/
    ctx[83].list
  );
  const list_slot = create_slot(
    list_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_slot_context
  );
  return {
    c() {
      if (list_slot) list_slot.c();
    },
    m(target, anchor) {
      if (list_slot) {
        list_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (list_slot) {
        if (list_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_slot,
            list_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_slot_changes
            ),
            get_list_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(list_slot, local);
      current = true;
    },
    o(local) {
      transition_out(list_slot, local);
      current = false;
    },
    d(detaching) {
      if (list_slot) list_slot.d(detaching);
    }
  };
}
function fallback_block_9(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.textContent = "No options";
      attr(div, "class", "empty svelte-82qwg8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function fallback_block_8(ctx) {
  var _a;
  let t_value = (
    /*item*/
    ((_a = ctx[126]) == null ? void 0 : _a[
      /*label*/
      ctx[12]
    ]) + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      var _a2;
      if (dirty[0] & /*filteredItems, label*/
      16781312 && t_value !== (t_value = /*item*/
      ((_a2 = ctx2[126]) == null ? void 0 : _a2[
        /*label*/
        ctx2[12]
      ]) + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block_1(ctx) {
  let div1;
  let div0;
  let activeScroll_action;
  let hoverScroll_action;
  let t;
  let current;
  let mounted;
  let dispose;
  const item_slot_template = (
    /*#slots*/
    ctx[83].item
  );
  const item_slot = create_slot(
    item_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_item_slot_context
  );
  const item_slot_or_fallback = item_slot || fallback_block_8(ctx);
  function mouseover_handler() {
    return (
      /*mouseover_handler*/
      ctx[88](
        /*i*/
        ctx[128]
      )
    );
  }
  function focus_handler() {
    return (
      /*focus_handler*/
      ctx[89](
        /*i*/
        ctx[128]
      )
    );
  }
  function click_handler() {
    return (
      /*click_handler*/
      ctx[90](
        /*item*/
        ctx[126],
        /*i*/
        ctx[128]
      )
    );
  }
  return {
    c() {
      var _a;
      div1 = element("div");
      div0 = element("div");
      if (item_slot_or_fallback) item_slot_or_fallback.c();
      t = space();
      attr(div0, "class", "item svelte-82qwg8");
      toggle_class(
        div0,
        "list-group-title",
        /*item*/
        ctx[126].groupHeader
      );
      toggle_class(
        div0,
        "active",
        /*isItemActive*/
        ctx[45](
          /*item*/
          ctx[126],
          /*value*/
          ctx[3],
          /*itemId*/
          ctx[13]
        )
      );
      toggle_class(div0, "first", isItemFirst(
        /*i*/
        ctx[128]
      ));
      toggle_class(
        div0,
        "hover",
        /*hoverItemIndex*/
        ctx[7] === /*i*/
        ctx[128]
      );
      toggle_class(
        div0,
        "group-item",
        /*item*/
        ctx[126].groupItem
      );
      toggle_class(
        div0,
        "not-selectable",
        /*item*/
        ((_a = ctx[126]) == null ? void 0 : _a.selectable) === false
      );
      attr(div1, "class", "list-item svelte-82qwg8");
      attr(div1, "tabindex", "-1");
      attr(div1, "role", "none");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      if (item_slot_or_fallback) {
        item_slot_or_fallback.m(div0, null);
      }
      append(div1, t);
      current = true;
      if (!mounted) {
        dispose = [
          action_destroyer(activeScroll_action = /*activeScroll*/
          ctx[46].call(null, div0, {
            scroll: (
              /*isItemActive*/
              ctx[45](
                /*item*/
                ctx[126],
                /*value*/
                ctx[3],
                /*itemId*/
                ctx[13]
              )
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          action_destroyer(hoverScroll_action = /*hoverScroll*/
          ctx[47].call(null, div0, {
            scroll: (
              /*scrollToHoverItem*/
              ctx[29] === /*i*/
              ctx[128]
            ),
            listDom: (
              /*listDom*/
              ctx[30]
            )
          })),
          listen(div1, "mouseover", mouseover_handler),
          listen(div1, "focus", focus_handler),
          listen(div1, "click", stop_propagation(click_handler)),
          listen(div1, "keydown", stop_propagation(prevent_default(
            /*keydown_handler*/
            ctx[87]
          )))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (item_slot) {
        if (item_slot.p && (!current || dirty[0] & /*filteredItems*/
        16777216 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            item_slot,
            item_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              item_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_item_slot_changes
            ),
            get_item_slot_context
          );
        }
      } else {
        if (item_slot_or_fallback && item_slot_or_fallback.p && (!current || dirty[0] & /*filteredItems, label*/
        16781312)) {
          item_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (activeScroll_action && is_function(activeScroll_action.update) && dirty[0] & /*filteredItems, value, itemId, listDom*/
      1090527240) activeScroll_action.update.call(null, {
        scroll: (
          /*isItemActive*/
          ctx[45](
            /*item*/
            ctx[126],
            /*value*/
            ctx[3],
            /*itemId*/
            ctx[13]
          )
        ),
        listDom: (
          /*listDom*/
          ctx[30]
        )
      });
      if (hoverScroll_action && is_function(hoverScroll_action.update) && dirty[0] & /*scrollToHoverItem, listDom*/
      1610612736) hoverScroll_action.update.call(null, {
        scroll: (
          /*scrollToHoverItem*/
          ctx[29] === /*i*/
          ctx[128]
        ),
        listDom: (
          /*listDom*/
          ctx[30]
        )
      });
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "list-group-title",
          /*item*/
          ctx[126].groupHeader
        );
      }
      if (!current || dirty[0] & /*filteredItems, value, itemId*/
      16785416 | dirty[1] & /*isItemActive*/
      16384) {
        toggle_class(
          div0,
          "active",
          /*isItemActive*/
          ctx[45](
            /*item*/
            ctx[126],
            /*value*/
            ctx[3],
            /*itemId*/
            ctx[13]
          )
        );
      }
      if (!current || dirty[0] & /*hoverItemIndex*/
      128) {
        toggle_class(
          div0,
          "hover",
          /*hoverItemIndex*/
          ctx[7] === /*i*/
          ctx[128]
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "group-item",
          /*item*/
          ctx[126].groupItem
        );
      }
      if (!current || dirty[0] & /*filteredItems*/
      16777216) {
        toggle_class(
          div0,
          "not-selectable",
          /*item*/
          ((_a = ctx[126]) == null ? void 0 : _a.selectable) === false
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(item_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(item_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      if (item_slot_or_fallback) item_slot_or_fallback.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_9(ctx) {
  let current;
  const list_append_slot_template = (
    /*#slots*/
    ctx[83]["list-append"]
  );
  const list_append_slot = create_slot(
    list_append_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_list_append_slot_context
  );
  return {
    c() {
      if (list_append_slot) list_append_slot.c();
    },
    m(target, anchor) {
      if (list_append_slot) {
        list_append_slot.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (list_append_slot) {
        if (list_append_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            list_append_slot,
            list_append_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              list_append_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_list_append_slot_changes
            ),
            get_list_append_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(list_append_slot, local);
      current = true;
    },
    o(local) {
      transition_out(list_append_slot, local);
      current = false;
    },
    d(detaching) {
      if (list_append_slot) list_append_slot.d(detaching);
    }
  };
}
function create_if_block_7(ctx) {
  let span0;
  let t0;
  let t1;
  let span1;
  let t2;
  return {
    c() {
      span0 = element("span");
      t0 = text(
        /*ariaSelection*/
        ctx[32]
      );
      t1 = space();
      span1 = element("span");
      t2 = text(
        /*ariaContext*/
        ctx[31]
      );
      attr(span0, "id", "aria-selection");
      attr(span0, "class", "svelte-82qwg8");
      attr(span1, "id", "aria-context");
      attr(span1, "class", "svelte-82qwg8");
    },
    m(target, anchor) {
      insert(target, span0, anchor);
      append(span0, t0);
      insert(target, t1, anchor);
      insert(target, span1, anchor);
      append(span1, t2);
    },
    p(ctx2, dirty) {
      if (dirty[1] & /*ariaSelection*/
      2) set_data(
        t0,
        /*ariaSelection*/
        ctx2[32]
      );
      if (dirty[1] & /*ariaContext*/
      1) set_data(
        t2,
        /*ariaContext*/
        ctx2[31]
      );
    },
    d(detaching) {
      if (detaching) {
        detach(span0);
        detach(t1);
        detach(span1);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block_5, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*multiple*/
      ctx2[9]
    ) return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1, -1, -1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      if_block.c();
      if_block_anchor = empty();
    },
    m(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
}
function create_else_block2(ctx) {
  let div;
  let current;
  const selection_slot_template = (
    /*#slots*/
    ctx[83].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_selection_slot_context_1
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_7(ctx);
  return {
    c() {
      div = element("div");
      if (selection_slot_or_fallback) selection_slot_or_fallback.c();
      attr(div, "class", "selected-item svelte-82qwg8");
      toggle_class(
        div,
        "hide-selected-item",
        /*hideSelectedItem*/
        ctx[35]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_selection_slot_changes_1
            ),
            get_selection_slot_context_1
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!current || dirty[1] & /*hideSelectedItem*/
      16) {
        toggle_class(
          div,
          "hide-selected-item",
          /*hideSelectedItem*/
          ctx2[35]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(selection_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(selection_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
    }
  };
}
function create_if_block_5(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*value*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*activeValue, disabled, multiFullItemClearable, value, label*/
      67116040 | dirty[1] & /*handleMultiItemClear*/
      32 | dirty[2] & /*$$scope*/
      1048576) {
        each_value = ensure_array_like(
          /*value*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function fallback_block_7(ctx) {
  let t_value = (
    /*value*/
    ctx[3][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*value*/
      ctx2[3][
        /*label*/
        ctx2[12]
      ] + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function fallback_block_6(ctx) {
  let t_value = (
    /*item*/
    ctx[126][
      /*label*/
      ctx[12]
    ] + ""
  );
  let t;
  return {
    c() {
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*value, label*/
      4104 && t_value !== (t_value = /*item*/
      ctx2[126][
        /*label*/
        ctx2[12]
      ] + "")) set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_6(ctx) {
  let div;
  let current;
  let mounted;
  let dispose;
  const multi_clear_icon_slot_template = (
    /*#slots*/
    ctx[83]["multi-clear-icon"]
  );
  const multi_clear_icon_slot = create_slot(
    multi_clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_multi_clear_icon_slot_context
  );
  const multi_clear_icon_slot_or_fallback = multi_clear_icon_slot || fallback_block_5(ctx);
  function pointerup_handler_1() {
    return (
      /*pointerup_handler_1*/
      ctx[92](
        /*i*/
        ctx[128]
      )
    );
  }
  return {
    c() {
      div = element("div");
      if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.c();
      attr(div, "class", "multi-item-clear svelte-82qwg8");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (multi_clear_icon_slot_or_fallback) {
        multi_clear_icon_slot_or_fallback.m(div, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(div, "pointerup", stop_propagation(prevent_default(pointerup_handler_1)));
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (multi_clear_icon_slot) {
        if (multi_clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            multi_clear_icon_slot,
            multi_clear_icon_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              multi_clear_icon_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_multi_clear_icon_slot_changes
            ),
            get_multi_clear_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(multi_clear_icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(multi_clear_icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (multi_clear_icon_slot_or_fallback) multi_clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block_5(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({});
  return {
    c() {
      create_component(clearicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
}
function create_each_block3(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let current;
  let mounted;
  let dispose;
  const selection_slot_template = (
    /*#slots*/
    ctx[83].selection
  );
  const selection_slot = create_slot(
    selection_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_selection_slot_context
  );
  const selection_slot_or_fallback = selection_slot || fallback_block_6(ctx);
  let if_block = !/*disabled*/
  ctx[11] && !/*multiFullItemClearable*/
  ctx[10] && ClearIcon_default && create_if_block_6(ctx);
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[93](
        /*i*/
        ctx[128]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      if (selection_slot_or_fallback) selection_slot_or_fallback.c();
      t0 = space();
      if (if_block) if_block.c();
      t1 = space();
      attr(span, "class", "multi-item-text svelte-82qwg8");
      attr(div, "class", "multi-item svelte-82qwg8");
      attr(div, "role", "none");
      toggle_class(
        div,
        "active",
        /*activeValue*/
        ctx[26] === /*i*/
        ctx[128]
      );
      toggle_class(
        div,
        "disabled",
        /*disabled*/
        ctx[11]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append(div, span);
      if (selection_slot_or_fallback) {
        selection_slot_or_fallback.m(span, null);
      }
      append(div, t0);
      if (if_block) if_block.m(div, null);
      append(div, t1);
      current = true;
      if (!mounted) {
        dispose = [
          listen(div, "click", prevent_default(click_handler_1)),
          listen(div, "keydown", stop_propagation(prevent_default(
            /*keydown_handler_1*/
            ctx[84]
          )))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (selection_slot) {
        if (selection_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            selection_slot,
            selection_slot_template,
            ctx,
            /*$$scope*/
            ctx[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx[82]
            ) : get_slot_changes(
              selection_slot_template,
              /*$$scope*/
              ctx[82],
              dirty,
              get_selection_slot_changes
            ),
            get_selection_slot_context
          );
        }
      } else {
        if (selection_slot_or_fallback && selection_slot_or_fallback.p && (!current || dirty[0] & /*value, label*/
        4104)) {
          selection_slot_or_fallback.p(ctx, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (!/*disabled*/
      ctx[11] && !/*multiFullItemClearable*/
      ctx[10] && ClearIcon_default) {
        if (if_block) {
          if_block.p(ctx, dirty);
          if (dirty[0] & /*disabled, multiFullItemClearable*/
          3072) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_6(ctx);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, t1);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*activeValue*/
      67108864) {
        toggle_class(
          div,
          "active",
          /*activeValue*/
          ctx[26] === /*i*/
          ctx[128]
        );
      }
      if (!current || dirty[0] & /*disabled*/
      2048) {
        toggle_class(
          div,
          "disabled",
          /*disabled*/
          ctx[11]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(selection_slot_or_fallback, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(selection_slot_or_fallback, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (selection_slot_or_fallback) selection_slot_or_fallback.d(detaching);
      if (if_block) if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_3(ctx) {
  let div;
  let current;
  const loading_icon_slot_template = (
    /*#slots*/
    ctx[83]["loading-icon"]
  );
  const loading_icon_slot = create_slot(
    loading_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_loading_icon_slot_context
  );
  const loading_icon_slot_or_fallback = loading_icon_slot || fallback_block_4(ctx);
  return {
    c() {
      div = element("div");
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.c();
      attr(div, "class", "icon loading svelte-82qwg8");
      attr(div, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (loading_icon_slot_or_fallback) {
        loading_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (loading_icon_slot) {
        if (loading_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            loading_icon_slot,
            loading_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              loading_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_loading_icon_slot_changes
            ),
            get_loading_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(loading_icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(loading_icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (loading_icon_slot_or_fallback) loading_icon_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_4(ctx) {
  let loadingicon;
  let current;
  loadingicon = new LoadingIcon_default({});
  return {
    c() {
      create_component(loadingicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(loadingicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(loadingicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(loadingicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(loadingicon, detaching);
    }
  };
}
function create_if_block_23(ctx) {
  let button;
  let current;
  let mounted;
  let dispose;
  const clear_icon_slot_template = (
    /*#slots*/
    ctx[83]["clear-icon"]
  );
  const clear_icon_slot = create_slot(
    clear_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_clear_icon_slot_context
  );
  const clear_icon_slot_or_fallback = clear_icon_slot || fallback_block_3(ctx);
  return {
    c() {
      button = element("button");
      if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.c();
      attr(button, "type", "button");
      attr(button, "class", "icon clear-select svelte-82qwg8");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (clear_icon_slot_or_fallback) {
        clear_icon_slot_or_fallback.m(button, null);
      }
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*handleClear*/
          ctx[22]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (clear_icon_slot) {
        if (clear_icon_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            clear_icon_slot,
            clear_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              clear_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_clear_icon_slot_changes
            ),
            get_clear_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(clear_icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(clear_icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      if (clear_icon_slot_or_fallback) clear_icon_slot_or_fallback.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function fallback_block_3(ctx) {
  let clearicon;
  let current;
  clearicon = new ClearIcon_default({});
  return {
    c() {
      create_component(clearicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(clearicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(clearicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(clearicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(clearicon, detaching);
    }
  };
}
function create_if_block_14(ctx) {
  let div;
  let current;
  const chevron_icon_slot_template = (
    /*#slots*/
    ctx[83]["chevron-icon"]
  );
  const chevron_icon_slot = create_slot(
    chevron_icon_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_chevron_icon_slot_context
  );
  const chevron_icon_slot_or_fallback = chevron_icon_slot || fallback_block_2(ctx);
  return {
    c() {
      div = element("div");
      if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.c();
      attr(div, "class", "icon chevron svelte-82qwg8");
      attr(div, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (chevron_icon_slot_or_fallback) {
        chevron_icon_slot_or_fallback.m(div, null);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (chevron_icon_slot) {
        if (chevron_icon_slot.p && (!current || dirty[0] & /*listOpen*/
        64 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            chevron_icon_slot,
            chevron_icon_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              chevron_icon_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_chevron_icon_slot_changes
            ),
            get_chevron_icon_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(chevron_icon_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(chevron_icon_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (chevron_icon_slot_or_fallback) chevron_icon_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block_2(ctx) {
  let chevronicon;
  let current;
  chevronicon = new ChevronIcon_default({});
  return {
    c() {
      create_component(chevronicon.$$.fragment);
    },
    m(target, anchor) {
      mount_component(chevronicon, target, anchor);
      current = true;
    },
    i(local) {
      if (current) return;
      transition_in(chevronicon.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(chevronicon.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(chevronicon, detaching);
    }
  };
}
function fallback_block_1(ctx) {
  let input_1;
  let input_1_value_value;
  return {
    c() {
      input_1 = element("input");
      attr(
        input_1,
        "name",
        /*name*/
        ctx[8]
      );
      attr(input_1, "type", "hidden");
      input_1.value = input_1_value_value = /*value*/
      ctx[3] ? JSON.stringify(
        /*value*/
        ctx[3]
      ) : null;
      attr(input_1, "class", "svelte-82qwg8");
    },
    m(target, anchor) {
      insert(target, input_1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*name*/
      256) {
        attr(
          input_1,
          "name",
          /*name*/
          ctx2[8]
        );
      }
      if (dirty[0] & /*value*/
      8 && input_1_value_value !== (input_1_value_value = /*value*/
      ctx2[3] ? JSON.stringify(
        /*value*/
        ctx2[3]
      ) : null)) {
        input_1.value = input_1_value_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input_1);
      }
    }
  };
}
function create_if_block3(ctx) {
  let current;
  const required_slot_template = (
    /*#slots*/
    ctx[83].required
  );
  const required_slot = create_slot(
    required_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_required_slot_context
  );
  const required_slot_or_fallback = required_slot || fallback_block(ctx);
  return {
    c() {
      if (required_slot_or_fallback) required_slot_or_fallback.c();
    },
    m(target, anchor) {
      if (required_slot_or_fallback) {
        required_slot_or_fallback.m(target, anchor);
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (required_slot) {
        if (required_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            required_slot,
            required_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              required_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_required_slot_changes
            ),
            get_required_slot_context
          );
        }
      }
    },
    i(local) {
      if (current) return;
      transition_in(required_slot_or_fallback, local);
      current = true;
    },
    o(local) {
      transition_out(required_slot_or_fallback, local);
      current = false;
    },
    d(detaching) {
      if (required_slot_or_fallback) required_slot_or_fallback.d(detaching);
    }
  };
}
function fallback_block(ctx) {
  let select;
  return {
    c() {
      select = element("select");
      attr(select, "class", "required svelte-82qwg8");
      select.required = true;
      attr(select, "tabindex", "-1");
      attr(select, "aria-hidden", "true");
    },
    m(target, anchor) {
      insert(target, select, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(select);
      }
    }
  };
}
function create_fragment8(ctx) {
  let div3;
  let t0;
  let span;
  let t1;
  let div0;
  let t2;
  let div1;
  let t3;
  let input_1;
  let input_1_readonly_value;
  let t4;
  let div2;
  let t5;
  let t6;
  let t7;
  let t8;
  let div3_class_value;
  let floatingRef_action;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*listOpen*/
    ctx[6] && create_if_block_8(ctx)
  );
  let if_block1 = (
    /*focused*/
    ctx[2] && create_if_block_7(ctx)
  );
  const prepend_slot_template = (
    /*#slots*/
    ctx[83].prepend
  );
  const prepend_slot = create_slot(
    prepend_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_prepend_slot_context
  );
  let if_block2 = (
    /*hasValue*/
    ctx[25] && create_if_block_4(ctx)
  );
  let input_1_levels = [
    {
      readOnly: input_1_readonly_value = !/*searchable*/
      ctx[17]
    },
    /*_inputAttributes*/
    ctx[27],
    { placeholder: (
      /*placeholderText*/
      ctx[33]
    ) },
    { style: (
      /*inputStyles*/
      ctx[18]
    ) },
    { disabled: (
      /*disabled*/
      ctx[11]
    ) }
  ];
  let input_data = {};
  for (let i = 0; i < input_1_levels.length; i += 1) {
    input_data = assign(input_data, input_1_levels[i]);
  }
  let if_block3 = (
    /*loading*/
    ctx[5] && create_if_block_3(ctx)
  );
  let if_block4 = (
    /*showClear*/
    ctx[34] && create_if_block_23(ctx)
  );
  let if_block5 = (
    /*showChevron*/
    ctx[20] && create_if_block_14(ctx)
  );
  const input_hidden_slot_template = (
    /*#slots*/
    ctx[83]["input-hidden"]
  );
  const input_hidden_slot = create_slot(
    input_hidden_slot_template,
    ctx,
    /*$$scope*/
    ctx[82],
    get_input_hidden_slot_context
  );
  const input_hidden_slot_or_fallback = input_hidden_slot || fallback_block_1(ctx);
  let if_block6 = (
    /*required*/
    ctx[16] && (!/*value*/
    ctx[3] || /*value*/
    ctx[3].length === 0) && create_if_block3(ctx)
  );
  return {
    c() {
      div3 = element("div");
      if (if_block0) if_block0.c();
      t0 = space();
      span = element("span");
      if (if_block1) if_block1.c();
      t1 = space();
      div0 = element("div");
      if (prepend_slot) prepend_slot.c();
      t2 = space();
      div1 = element("div");
      if (if_block2) if_block2.c();
      t3 = space();
      input_1 = element("input");
      t4 = space();
      div2 = element("div");
      if (if_block3) if_block3.c();
      t5 = space();
      if (if_block4) if_block4.c();
      t6 = space();
      if (if_block5) if_block5.c();
      t7 = space();
      if (input_hidden_slot_or_fallback) input_hidden_slot_or_fallback.c();
      t8 = space();
      if (if_block6) if_block6.c();
      attr(span, "aria-live", "polite");
      attr(span, "aria-atomic", "false");
      attr(span, "aria-relevant", "additions text");
      attr(span, "class", "a11y-text svelte-82qwg8");
      attr(div0, "class", "prepend svelte-82qwg8");
      set_attributes(input_1, input_data);
      toggle_class(input_1, "svelte-82qwg8", true);
      attr(div1, "class", "value-container svelte-82qwg8");
      attr(div2, "class", "indicators svelte-82qwg8");
      attr(div3, "class", div3_class_value = "svelte-select " + /*containerClasses*/
      ctx[21] + " svelte-82qwg8");
      attr(
        div3,
        "style",
        /*containerStyles*/
        ctx[14]
      );
      attr(div3, "role", "none");
      toggle_class(
        div3,
        "multi",
        /*multiple*/
        ctx[9]
      );
      toggle_class(
        div3,
        "disabled",
        /*disabled*/
        ctx[11]
      );
      toggle_class(
        div3,
        "focused",
        /*focused*/
        ctx[2]
      );
      toggle_class(
        div3,
        "list-open",
        /*listOpen*/
        ctx[6]
      );
      toggle_class(
        div3,
        "show-chevron",
        /*showChevron*/
        ctx[20]
      );
      toggle_class(
        div3,
        "error",
        /*hasError*/
        ctx[15]
      );
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      if (if_block0) if_block0.m(div3, null);
      append(div3, t0);
      append(div3, span);
      if (if_block1) if_block1.m(span, null);
      append(div3, t1);
      append(div3, div0);
      if (prepend_slot) {
        prepend_slot.m(div0, null);
      }
      append(div3, t2);
      append(div3, div1);
      if (if_block2) if_block2.m(div1, null);
      append(div1, t3);
      append(div1, input_1);
      if (input_1.autofocus) input_1.focus();
      ctx[94](input_1);
      set_input_value(
        input_1,
        /*filterText*/
        ctx[4]
      );
      append(div3, t4);
      append(div3, div2);
      if (if_block3) if_block3.m(div2, null);
      append(div2, t5);
      if (if_block4) if_block4.m(div2, null);
      append(div2, t6);
      if (if_block5) if_block5.m(div2, null);
      append(div3, t7);
      if (input_hidden_slot_or_fallback) {
        input_hidden_slot_or_fallback.m(div3, null);
      }
      append(div3, t8);
      if (if_block6) if_block6.m(div3, null);
      ctx[96](div3);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "click",
            /*handleClickOutside*/
            ctx[42]
          ),
          listen(
            window,
            "keydown",
            /*handleKeyDown*/
            ctx[37]
          ),
          listen(
            input_1,
            "keydown",
            /*handleKeyDown*/
            ctx[37]
          ),
          listen(
            input_1,
            "blur",
            /*handleBlur*/
            ctx[39]
          ),
          listen(
            input_1,
            "focus",
            /*handleFocus*/
            ctx[38]
          ),
          listen(
            input_1,
            "input",
            /*input_1_input_handler*/
            ctx[95]
          ),
          listen(div3, "pointerup", prevent_default(
            /*handleClick*/
            ctx[40]
          )),
          action_destroyer(floatingRef_action = /*floatingRef*/
          ctx[48].call(null, div3))
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*listOpen*/
        ctx2[6]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*listOpen*/
          64) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t0);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*focused*/
        ctx2[2]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_7(ctx2);
          if_block1.c();
          if_block1.m(span, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (prepend_slot) {
        if (prepend_slot.p && (!current || dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            prepend_slot,
            prepend_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              prepend_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_prepend_slot_changes
            ),
            get_prepend_slot_context
          );
        }
      }
      if (
        /*hasValue*/
        ctx2[25]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*hasValue*/
          33554432) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_4(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, t3);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      set_attributes(input_1, input_data = get_spread_update(input_1_levels, [
        (!current || dirty[0] & /*searchable*/
        131072 && input_1_readonly_value !== (input_1_readonly_value = !/*searchable*/
        ctx2[17])) && { readOnly: input_1_readonly_value },
        dirty[0] & /*_inputAttributes*/
        134217728 && /*_inputAttributes*/
        ctx2[27],
        (!current || dirty[1] & /*placeholderText*/
        4) && { placeholder: (
          /*placeholderText*/
          ctx2[33]
        ) },
        (!current || dirty[0] & /*inputStyles*/
        262144) && { style: (
          /*inputStyles*/
          ctx2[18]
        ) },
        (!current || dirty[0] & /*disabled*/
        2048) && { disabled: (
          /*disabled*/
          ctx2[11]
        ) }
      ]));
      if (dirty[0] & /*filterText*/
      16 && input_1.value !== /*filterText*/
      ctx2[4]) {
        set_input_value(
          input_1,
          /*filterText*/
          ctx2[4]
        );
      }
      toggle_class(input_1, "svelte-82qwg8", true);
      if (
        /*loading*/
        ctx2[5]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*loading*/
          32) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block_3(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(div2, t5);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
      if (
        /*showClear*/
        ctx2[34]
      ) {
        if (if_block4) {
          if_block4.p(ctx2, dirty);
          if (dirty[1] & /*showClear*/
          8) {
            transition_in(if_block4, 1);
          }
        } else {
          if_block4 = create_if_block_23(ctx2);
          if_block4.c();
          transition_in(if_block4, 1);
          if_block4.m(div2, t6);
        }
      } else if (if_block4) {
        group_outros();
        transition_out(if_block4, 1, 1, () => {
          if_block4 = null;
        });
        check_outros();
      }
      if (
        /*showChevron*/
        ctx2[20]
      ) {
        if (if_block5) {
          if_block5.p(ctx2, dirty);
          if (dirty[0] & /*showChevron*/
          1048576) {
            transition_in(if_block5, 1);
          }
        } else {
          if_block5 = create_if_block_14(ctx2);
          if_block5.c();
          transition_in(if_block5, 1);
          if_block5.m(div2, null);
        }
      } else if (if_block5) {
        group_outros();
        transition_out(if_block5, 1, 1, () => {
          if_block5 = null;
        });
        check_outros();
      }
      if (input_hidden_slot) {
        if (input_hidden_slot.p && (!current || dirty[0] & /*value*/
        8 | dirty[2] & /*$$scope*/
        1048576)) {
          update_slot_base(
            input_hidden_slot,
            input_hidden_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[82],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[82]
            ) : get_slot_changes(
              input_hidden_slot_template,
              /*$$scope*/
              ctx2[82],
              dirty,
              get_input_hidden_slot_changes
            ),
            get_input_hidden_slot_context
          );
        }
      } else {
        if (input_hidden_slot_or_fallback && input_hidden_slot_or_fallback.p && (!current || dirty[0] & /*name, value*/
        264)) {
          input_hidden_slot_or_fallback.p(ctx2, !current ? [-1, -1, -1, -1, -1] : dirty);
        }
      }
      if (
        /*required*/
        ctx2[16] && (!/*value*/
        ctx2[3] || /*value*/
        ctx2[3].length === 0)
      ) {
        if (if_block6) {
          if_block6.p(ctx2, dirty);
          if (dirty[0] & /*required, value*/
          65544) {
            transition_in(if_block6, 1);
          }
        } else {
          if_block6 = create_if_block3(ctx2);
          if_block6.c();
          transition_in(if_block6, 1);
          if_block6.m(div3, null);
        }
      } else if (if_block6) {
        group_outros();
        transition_out(if_block6, 1, 1, () => {
          if_block6 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*containerClasses*/
      2097152 && div3_class_value !== (div3_class_value = "svelte-select " + /*containerClasses*/
      ctx2[21] + " svelte-82qwg8")) {
        attr(div3, "class", div3_class_value);
      }
      if (!current || dirty[0] & /*containerStyles*/
      16384) {
        attr(
          div3,
          "style",
          /*containerStyles*/
          ctx2[14]
        );
      }
      if (!current || dirty[0] & /*containerClasses, multiple*/
      2097664) {
        toggle_class(
          div3,
          "multi",
          /*multiple*/
          ctx2[9]
        );
      }
      if (!current || dirty[0] & /*containerClasses, disabled*/
      2099200) {
        toggle_class(
          div3,
          "disabled",
          /*disabled*/
          ctx2[11]
        );
      }
      if (!current || dirty[0] & /*containerClasses, focused*/
      2097156) {
        toggle_class(
          div3,
          "focused",
          /*focused*/
          ctx2[2]
        );
      }
      if (!current || dirty[0] & /*containerClasses, listOpen*/
      2097216) {
        toggle_class(
          div3,
          "list-open",
          /*listOpen*/
          ctx2[6]
        );
      }
      if (!current || dirty[0] & /*containerClasses, showChevron*/
      3145728) {
        toggle_class(
          div3,
          "show-chevron",
          /*showChevron*/
          ctx2[20]
        );
      }
      if (!current || dirty[0] & /*containerClasses, hasError*/
      2129920) {
        toggle_class(
          div3,
          "error",
          /*hasError*/
          ctx2[15]
        );
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(prepend_slot, local);
      transition_in(if_block2);
      transition_in(if_block3);
      transition_in(if_block4);
      transition_in(if_block5);
      transition_in(input_hidden_slot_or_fallback, local);
      transition_in(if_block6);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(prepend_slot, local);
      transition_out(if_block2);
      transition_out(if_block3);
      transition_out(if_block4);
      transition_out(if_block5);
      transition_out(input_hidden_slot_or_fallback, local);
      transition_out(if_block6);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block0) if_block0.d();
      if (if_block1) if_block1.d();
      if (prepend_slot) prepend_slot.d(detaching);
      if (if_block2) if_block2.d();
      ctx[94](null);
      if (if_block3) if_block3.d();
      if (if_block4) if_block4.d();
      if (if_block5) if_block5.d();
      if (input_hidden_slot_or_fallback) input_hidden_slot_or_fallback.d(detaching);
      if (if_block6) if_block6.d();
      ctx[96](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function convertStringItemsToObjects(_items) {
  return _items.map((item, index) => {
    return { index, value: item, label: `${item}` };
  });
}
function isItemFirst(itemIndex) {
  return itemIndex === 0;
}
function isItemSelectable(item) {
  return item.groupHeader && item.selectable || item.selectable || !item.hasOwnProperty("selectable");
}
function instance5($$self, $$props, $$invalidate) {
  let hasValue;
  let hideSelectedItem;
  let showClear;
  let placeholderText;
  let ariaSelection;
  let ariaContext;
  let filteredItems;
  let listDom;
  let scrollToHoverItem;
  let { $$slots: slots = {}, $$scope } = $$props;
  const $$slots = compute_slots(slots);
  const dispatch = createEventDispatcher();
  let { justValue = null } = $$props;
  let { filter: filter2 = filter } = $$props;
  let { getItems: getItems2 = getItems } = $$props;
  let { id = null } = $$props;
  let { name = null } = $$props;
  let { container = void 0 } = $$props;
  let { input = void 0 } = $$props;
  let { multiple = false } = $$props;
  let { multiFullItemClearable = false } = $$props;
  let { disabled = false } = $$props;
  let { focused = false } = $$props;
  let { value = null } = $$props;
  let { filterText = "" } = $$props;
  let { placeholder = "Please select" } = $$props;
  let { placeholderAlwaysShow = false } = $$props;
  let { items = null } = $$props;
  let { label = "label" } = $$props;
  let { itemFilter = (label2, filterText2, option) => `${label2}`.toLowerCase().includes(filterText2.toLowerCase()) } = $$props;
  let { groupBy = void 0 } = $$props;
  let { groupFilter = (groups) => groups } = $$props;
  let { groupHeaderSelectable = false } = $$props;
  let { itemId = "value" } = $$props;
  let { loadOptions = void 0 } = $$props;
  let { containerStyles = "" } = $$props;
  let { hasError = false } = $$props;
  let { filterSelectedItems = true } = $$props;
  let { required = false } = $$props;
  let { closeListOnChange = true } = $$props;
  let { clearFilterTextOnBlur = true } = $$props;
  let { createGroupHeaderItem = (groupValue, item) => {
    return { value: groupValue, [label]: groupValue };
  } } = $$props;
  const getFilteredItems = () => {
    return filteredItems;
  };
  let { searchable = true } = $$props;
  let { inputStyles = "" } = $$props;
  let { clearable = true } = $$props;
  let { loading = false } = $$props;
  let { listOpen = false } = $$props;
  let timeout;
  let { debounce = (fn, wait = 1) => {
    clearTimeout(timeout);
    timeout = setTimeout(fn, wait);
  } } = $$props;
  let { debounceWait = 300 } = $$props;
  let { hideEmptyState = false } = $$props;
  let { inputAttributes = {} } = $$props;
  let { listAutoWidth = true } = $$props;
  let { showChevron = false } = $$props;
  let { listOffset = 5 } = $$props;
  let { hoverItemIndex = 0 } = $$props;
  let { floatingConfig = {} } = $$props;
  let { class: containerClasses = "" } = $$props;
  let activeValue;
  let prev_value;
  let prev_filterText;
  let prev_multiple;
  function setValue() {
    if (typeof value === "string") {
      let item = (items || []).find((item2) => item2[itemId] === value);
      $$invalidate(3, value = item || { [itemId]: value, label: value });
    } else if (multiple && Array.isArray(value) && value.length > 0) {
      $$invalidate(3, value = value.map((item) => typeof item === "string" ? { value: item, label: item } : item));
    }
  }
  let _inputAttributes;
  function assignInputAttributes() {
    $$invalidate(27, _inputAttributes = Object.assign(
      {
        autocapitalize: "none",
        autocomplete: "off",
        autocorrect: "off",
        spellcheck: false,
        tabindex: 0,
        type: "text",
        "aria-autocomplete": "list"
      },
      inputAttributes
    ));
    if (id) {
      $$invalidate(27, _inputAttributes["id"] = id, _inputAttributes);
    }
    if (!searchable) {
      $$invalidate(27, _inputAttributes["readonly"] = true, _inputAttributes);
    }
  }
  function filterGroupedItems(_items) {
    const groupValues = [];
    const groups = {};
    _items.forEach((item) => {
      const groupValue = groupBy(item);
      if (!groupValues.includes(groupValue)) {
        groupValues.push(groupValue);
        groups[groupValue] = [];
        if (groupValue) {
          groups[groupValue].push(Object.assign(createGroupHeaderItem(groupValue, item), {
            id: groupValue,
            groupHeader: true,
            selectable: groupHeaderSelectable
          }));
        }
      }
      groups[groupValue].push(Object.assign({ groupItem: !!groupValue }, item));
    });
    const sortedGroupedItems = [];
    groupFilter(groupValues).forEach((groupValue) => {
      if (groups[groupValue]) sortedGroupedItems.push(...groups[groupValue]);
    });
    return sortedGroupedItems;
  }
  function dispatchSelectedItem() {
    if (multiple) {
      if (JSON.stringify(value) !== JSON.stringify(prev_value)) {
        if (checkValueForDuplicates()) {
          dispatch("input", value);
        }
      }
      return;
    }
    if (!prev_value || JSON.stringify(value[itemId]) !== JSON.stringify(prev_value[itemId])) {
      dispatch("input", value);
    }
  }
  function setupMulti() {
    if (value) {
      if (Array.isArray(value)) {
        $$invalidate(3, value = [...value]);
      } else {
        $$invalidate(3, value = [value]);
      }
    }
  }
  function setupSingle() {
    if (value) $$invalidate(3, value = null);
  }
  function setValueIndexAsHoverIndex() {
    const valueIndex = filteredItems.findIndex((i) => {
      return i[itemId] === value[itemId];
    });
    checkHoverSelectable(valueIndex, true);
  }
  function dispatchHover(i) {
    dispatch("hoverItem", i);
  }
  function checkHoverSelectable(startingIndex = 0, ignoreGroup) {
    $$invalidate(7, hoverItemIndex = startingIndex < 0 ? 0 : startingIndex);
    if (!ignoreGroup && groupBy && filteredItems[hoverItemIndex] && !filteredItems[hoverItemIndex].selectable) {
      setHoverIndex(1);
    }
  }
  function setupFilterText() {
    if (!loadOptions && filterText.length === 0) return;
    if (loadOptions) {
      debounce(
        async function() {
          $$invalidate(5, loading = true);
          let res = await getItems2({
            dispatch,
            loadOptions,
            convertStringItemsToObjects,
            filterText
          });
          if (res) {
            $$invalidate(5, loading = res.loading);
            $$invalidate(6, listOpen = listOpen ? res.listOpen : filterText.length > 0 ? true : false);
            $$invalidate(2, focused = listOpen && res.focused);
            $$invalidate(51, items = groupBy ? filterGroupedItems(res.filteredItems) : res.filteredItems);
          } else {
            $$invalidate(5, loading = false);
            $$invalidate(2, focused = true);
            $$invalidate(6, listOpen = true);
          }
        },
        debounceWait
      );
    } else {
      $$invalidate(6, listOpen = true);
      if (multiple) {
        $$invalidate(26, activeValue = void 0);
      }
    }
  }
  function handleFilterEvent(items2) {
    if (listOpen) dispatch("filter", items2);
  }
  beforeUpdate(async () => {
    $$invalidate(78, prev_value = value);
    $$invalidate(79, prev_filterText = filterText);
    $$invalidate(80, prev_multiple = multiple);
  });
  function computeJustValue() {
    if (multiple) return value ? value.map((item) => item[itemId]) : null;
    return value ? value[itemId] : value;
  }
  function checkValueForDuplicates() {
    let noDuplicates = true;
    if (value) {
      const ids = [];
      const uniqueValues = [];
      value.forEach((val) => {
        if (!ids.includes(val[itemId])) {
          ids.push(val[itemId]);
          uniqueValues.push(val);
        } else {
          noDuplicates = false;
        }
      });
      if (!noDuplicates) $$invalidate(3, value = uniqueValues);
    }
    return noDuplicates;
  }
  function findItem(selection) {
    let matchTo = selection ? selection[itemId] : value[itemId];
    return items.find((item) => item[itemId] === matchTo);
  }
  function updateValueDisplay(items2) {
    if (!items2 || items2.length === 0 || items2.some((item) => typeof item !== "object")) return;
    if (!value || (multiple ? value.some((selection) => !selection || !selection[itemId]) : !value[itemId])) return;
    if (Array.isArray(value)) {
      $$invalidate(3, value = value.map((selection) => findItem(selection) || selection));
    } else {
      $$invalidate(3, value = findItem() || value);
    }
  }
  async function handleMultiItemClear(i) {
    const itemToRemove = value[i];
    if (value.length === 1) {
      $$invalidate(3, value = void 0);
    } else {
      $$invalidate(3, value = value.filter((item) => {
        return item !== itemToRemove;
      }));
    }
    dispatch("clear", itemToRemove);
  }
  function handleKeyDown(e) {
    if (!focused) return;
    e.stopPropagation();
    switch (e.key) {
      case "Escape":
        e.preventDefault();
        closeList();
        break;
      case "Enter":
        e.preventDefault();
        if (listOpen) {
          if (filteredItems.length === 0) break;
          const hoverItem = filteredItems[hoverItemIndex];
          if (value && !multiple && value[itemId] === hoverItem[itemId]) {
            closeList();
            break;
          } else {
            handleSelect(filteredItems[hoverItemIndex]);
          }
        }
        break;
      case "ArrowDown":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "ArrowUp":
        e.preventDefault();
        if (listOpen) {
          setHoverIndex(-1);
        } else {
          $$invalidate(6, listOpen = true);
          $$invalidate(26, activeValue = void 0);
        }
        break;
      case "Tab":
        if (listOpen && focused) {
          if (filteredItems.length === 0 || value && value[itemId] === filteredItems[hoverItemIndex][itemId]) return closeList();
          e.preventDefault();
          handleSelect(filteredItems[hoverItemIndex]);
          closeList();
        }
        break;
      case "Backspace":
        if (!multiple || filterText.length > 0) return;
        if (multiple && value && value.length > 0) {
          handleMultiItemClear(activeValue !== void 0 ? activeValue : value.length - 1);
          if (activeValue === 0 || activeValue === void 0) break;
          $$invalidate(26, activeValue = value.length > activeValue ? activeValue - 1 : void 0);
        }
        break;
      case "ArrowLeft":
        if (!value || !multiple || filterText.length > 0) return;
        if (activeValue === void 0) {
          $$invalidate(26, activeValue = value.length - 1);
        } else if (value.length > activeValue && activeValue !== 0) {
          $$invalidate(26, activeValue -= 1);
        }
        break;
      case "ArrowRight":
        if (!value || !multiple || filterText.length > 0 || activeValue === void 0) return;
        if (activeValue === value.length - 1) {
          $$invalidate(26, activeValue = void 0);
        } else if (activeValue < value.length - 1) {
          $$invalidate(26, activeValue += 1);
        }
        break;
    }
  }
  function handleFocus(e) {
    if (focused && input === (document == null ? void 0 : document.activeElement)) return;
    if (e) dispatch("focus", e);
    input == null ? void 0 : input.focus();
    $$invalidate(2, focused = true);
  }
  async function handleBlur(e) {
    if (isScrolling) return;
    if (listOpen || focused) {
      dispatch("blur", e);
      closeList();
      $$invalidate(2, focused = false);
      $$invalidate(26, activeValue = void 0);
      input == null ? void 0 : input.blur();
    }
  }
  function handleClick() {
    if (disabled) return;
    if (filterText.length > 0) return $$invalidate(6, listOpen = true);
    $$invalidate(6, listOpen = !listOpen);
  }
  function handleClear() {
    dispatch("clear", value);
    $$invalidate(3, value = void 0);
    closeList();
    handleFocus();
  }
  onMount(() => {
    if (listOpen) $$invalidate(2, focused = true);
    if (focused && input) input.focus();
  });
  function itemSelected(selection) {
    if (selection) {
      $$invalidate(4, filterText = "");
      const item = Object.assign({}, selection);
      if (item.groupHeader && !item.selectable) return;
      $$invalidate(3, value = multiple ? value ? value.concat([item]) : [item] : $$invalidate(3, value = item));
      setTimeout(() => {
        if (closeListOnChange) closeList();
        $$invalidate(26, activeValue = void 0);
        dispatch("change", value);
        dispatch("select", selection);
      });
    }
  }
  function closeList() {
    if (clearFilterTextOnBlur) {
      $$invalidate(4, filterText = "");
    }
    $$invalidate(6, listOpen = false);
  }
  let { ariaValues = (values) => {
    return `Option ${values}, selected.`;
  } } = $$props;
  let { ariaListOpen = (label2, count) => {
    return `You are currently focused on option ${label2}. There are ${count} results available.`;
  } } = $$props;
  let { ariaFocused = () => {
    return `Select is focused, type to refine list, press down to open the menu.`;
  } } = $$props;
  function handleAriaSelection(_multiple) {
    let selected = void 0;
    if (_multiple && value.length > 0) {
      selected = value.map((v) => v[label]).join(", ");
    } else {
      selected = value[label];
    }
    return ariaValues(selected);
  }
  function handleAriaContent() {
    if (!filteredItems || filteredItems.length === 0) return "";
    let _item = filteredItems[hoverItemIndex];
    if (listOpen && _item) {
      let count = filteredItems ? filteredItems.length : 0;
      return ariaListOpen(_item[label], count);
    } else {
      return ariaFocused();
    }
  }
  let list = null;
  let isScrollingTimer;
  function handleListScroll() {
    clearTimeout(isScrollingTimer);
    isScrollingTimer = setTimeout(
      () => {
        isScrolling = false;
      },
      100
    );
  }
  function handleClickOutside(event) {
    if (!listOpen && !focused && container && !container.contains(event.target) && !(list == null ? void 0 : list.contains(event.target))) {
      handleBlur();
    }
  }
  onDestroy(() => {
    list == null ? void 0 : list.remove();
  });
  let isScrolling = false;
  function handleSelect(item) {
    if (!item || item.selectable === false) return;
    itemSelected(item);
  }
  function handleHover(i) {
    if (isScrolling) return;
    $$invalidate(7, hoverItemIndex = i);
  }
  function handleItemClick(args) {
    const { item, i } = args;
    if ((item == null ? void 0 : item.selectable) === false) return;
    if (value && !multiple && value[itemId] === item[itemId]) return closeList();
    if (isItemSelectable(item)) {
      $$invalidate(7, hoverItemIndex = i);
      handleSelect(item);
    }
  }
  function setHoverIndex(increment) {
    let selectableFilteredItems = filteredItems.filter((item) => !Object.hasOwn(item, "selectable") || item.selectable === true);
    if (selectableFilteredItems.length === 0) {
      return $$invalidate(7, hoverItemIndex = 0);
    }
    if (increment > 0 && hoverItemIndex === filteredItems.length - 1) {
      $$invalidate(7, hoverItemIndex = 0);
    } else if (increment < 0 && hoverItemIndex === 0) {
      $$invalidate(7, hoverItemIndex = filteredItems.length - 1);
    } else {
      $$invalidate(7, hoverItemIndex = hoverItemIndex + increment);
    }
    const hover = filteredItems[hoverItemIndex];
    if (hover && hover.selectable === false) {
      if (increment === 1 || increment === -1) setHoverIndex(increment);
      return;
    }
  }
  function isItemActive(item, value2, itemId2) {
    if (multiple) return;
    return value2 && value2[itemId2] === item[itemId2];
  }
  const activeScroll = scrollAction;
  const hoverScroll = scrollAction;
  function scrollAction(node) {
    return {
      update(args) {
        if (args.scroll) {
          handleListScroll();
          node.scrollIntoView({ behavior: "auto", block: "nearest" });
        }
      }
    };
  }
  function setListWidth() {
    const { width } = container.getBoundingClientRect();
    $$invalidate(23, list.style.width = listAutoWidth ? width + "px" : "auto", list);
  }
  let _floatingConfig = {
    strategy: "absolute",
    placement: "bottom-start",
    middleware: [offset2(listOffset), flip2(), shift2()],
    autoUpdate: false
  };
  const [floatingRef, floatingContent, floatingUpdate] = createFloatingActions(_floatingConfig);
  let prefloat = true;
  function listMounted(list2, listOpen2) {
    if (!list2 || !listOpen2) return $$invalidate(28, prefloat = true);
    setTimeout(
      () => {
        $$invalidate(28, prefloat = false);
      },
      0
    );
  }
  function keydown_handler_1(event) {
    bubble.call(this, $$self, event);
  }
  function pointerup_handler(event) {
    bubble.call(this, $$self, event);
  }
  function mousedown_handler(event) {
    bubble.call(this, $$self, event);
  }
  function keydown_handler(event) {
    bubble.call(this, $$self, event);
  }
  const mouseover_handler = (i) => handleHover(i);
  const focus_handler = (i) => handleHover(i);
  const click_handler = (item, i) => handleItemClick({ item, i });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      list = $$value;
      $$invalidate(23, list);
    });
  }
  const pointerup_handler_1 = (i) => handleMultiItemClear(i);
  const click_handler_1 = (i) => multiFullItemClearable ? handleMultiItemClear(i) : {};
  function input_1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      input = $$value;
      $$invalidate(1, input);
    });
  }
  function input_1_input_handler() {
    filterText = this.value;
    $$invalidate(4, filterText);
  }
  function div3_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      container = $$value;
      $$invalidate(0, container);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("justValue" in $$props2) $$invalidate(52, justValue = $$props2.justValue);
    if ("filter" in $$props2) $$invalidate(53, filter2 = $$props2.filter);
    if ("getItems" in $$props2) $$invalidate(54, getItems2 = $$props2.getItems);
    if ("id" in $$props2) $$invalidate(55, id = $$props2.id);
    if ("name" in $$props2) $$invalidate(8, name = $$props2.name);
    if ("container" in $$props2) $$invalidate(0, container = $$props2.container);
    if ("input" in $$props2) $$invalidate(1, input = $$props2.input);
    if ("multiple" in $$props2) $$invalidate(9, multiple = $$props2.multiple);
    if ("multiFullItemClearable" in $$props2) $$invalidate(10, multiFullItemClearable = $$props2.multiFullItemClearable);
    if ("disabled" in $$props2) $$invalidate(11, disabled = $$props2.disabled);
    if ("focused" in $$props2) $$invalidate(2, focused = $$props2.focused);
    if ("value" in $$props2) $$invalidate(3, value = $$props2.value);
    if ("filterText" in $$props2) $$invalidate(4, filterText = $$props2.filterText);
    if ("placeholder" in $$props2) $$invalidate(56, placeholder = $$props2.placeholder);
    if ("placeholderAlwaysShow" in $$props2) $$invalidate(57, placeholderAlwaysShow = $$props2.placeholderAlwaysShow);
    if ("items" in $$props2) $$invalidate(51, items = $$props2.items);
    if ("label" in $$props2) $$invalidate(12, label = $$props2.label);
    if ("itemFilter" in $$props2) $$invalidate(58, itemFilter = $$props2.itemFilter);
    if ("groupBy" in $$props2) $$invalidate(59, groupBy = $$props2.groupBy);
    if ("groupFilter" in $$props2) $$invalidate(60, groupFilter = $$props2.groupFilter);
    if ("groupHeaderSelectable" in $$props2) $$invalidate(61, groupHeaderSelectable = $$props2.groupHeaderSelectable);
    if ("itemId" in $$props2) $$invalidate(13, itemId = $$props2.itemId);
    if ("loadOptions" in $$props2) $$invalidate(62, loadOptions = $$props2.loadOptions);
    if ("containerStyles" in $$props2) $$invalidate(14, containerStyles = $$props2.containerStyles);
    if ("hasError" in $$props2) $$invalidate(15, hasError = $$props2.hasError);
    if ("filterSelectedItems" in $$props2) $$invalidate(63, filterSelectedItems = $$props2.filterSelectedItems);
    if ("required" in $$props2) $$invalidate(16, required = $$props2.required);
    if ("closeListOnChange" in $$props2) $$invalidate(64, closeListOnChange = $$props2.closeListOnChange);
    if ("clearFilterTextOnBlur" in $$props2) $$invalidate(65, clearFilterTextOnBlur = $$props2.clearFilterTextOnBlur);
    if ("createGroupHeaderItem" in $$props2) $$invalidate(66, createGroupHeaderItem = $$props2.createGroupHeaderItem);
    if ("searchable" in $$props2) $$invalidate(17, searchable = $$props2.searchable);
    if ("inputStyles" in $$props2) $$invalidate(18, inputStyles = $$props2.inputStyles);
    if ("clearable" in $$props2) $$invalidate(68, clearable = $$props2.clearable);
    if ("loading" in $$props2) $$invalidate(5, loading = $$props2.loading);
    if ("listOpen" in $$props2) $$invalidate(6, listOpen = $$props2.listOpen);
    if ("debounce" in $$props2) $$invalidate(69, debounce = $$props2.debounce);
    if ("debounceWait" in $$props2) $$invalidate(70, debounceWait = $$props2.debounceWait);
    if ("hideEmptyState" in $$props2) $$invalidate(19, hideEmptyState = $$props2.hideEmptyState);
    if ("inputAttributes" in $$props2) $$invalidate(71, inputAttributes = $$props2.inputAttributes);
    if ("listAutoWidth" in $$props2) $$invalidate(72, listAutoWidth = $$props2.listAutoWidth);
    if ("showChevron" in $$props2) $$invalidate(20, showChevron = $$props2.showChevron);
    if ("listOffset" in $$props2) $$invalidate(73, listOffset = $$props2.listOffset);
    if ("hoverItemIndex" in $$props2) $$invalidate(7, hoverItemIndex = $$props2.hoverItemIndex);
    if ("floatingConfig" in $$props2) $$invalidate(74, floatingConfig = $$props2.floatingConfig);
    if ("class" in $$props2) $$invalidate(21, containerClasses = $$props2.class);
    if ("ariaValues" in $$props2) $$invalidate(75, ariaValues = $$props2.ariaValues);
    if ("ariaListOpen" in $$props2) $$invalidate(76, ariaListOpen = $$props2.ariaListOpen);
    if ("ariaFocused" in $$props2) $$invalidate(77, ariaFocused = $$props2.ariaFocused);
    if ("$$scope" in $$props2) $$invalidate(82, $$scope = $$props2.$$scope);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*value*/
    8 | $$self.$$.dirty[1] & /*items*/
    1048576) {
      $: if (items, value) setValue();
    }
    if ($$self.$$.dirty[0] & /*searchable*/
    131072 | $$self.$$.dirty[2] & /*inputAttributes*/
    512) {
      $: if (inputAttributes || !searchable) assignInputAttributes();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512) {
      $: if (multiple) setupMulti();
    }
    if ($$self.$$.dirty[0] & /*multiple*/
    512 | $$self.$$.dirty[2] & /*prev_multiple*/
    262144) {
      $: if (prev_multiple && !multiple) setupSingle();
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $: if (multiple && value && value.length > 1) checkValueForDuplicates();
    }
    if ($$self.$$.dirty[0] & /*value*/
    8) {
      $: if (value) dispatchSelectedItem();
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    65536) {
      $: if (!value && multiple && prev_value) dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*focused, input*/
    6) {
      $: if (!focused && input) closeList();
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16 | $$self.$$.dirty[2] & /*prev_filterText*/
    131072) {
      $: if (filterText !== prev_filterText) setupFilterText();
    }
    if ($$self.$$.dirty[0] & /*filterText, multiple, value, itemId, label*/
    12824 | $$self.$$.dirty[1] & /*filter, items, groupBy, itemFilter*/
    407896064 | $$self.$$.dirty[2] & /*loadOptions, filterSelectedItems*/
    3) {
      $: $$invalidate(24, filteredItems = filter2({
        loadOptions,
        filterText,
        items,
        multiple,
        value,
        itemId,
        groupBy,
        label,
        filterSelectedItems,
        itemFilter,
        convertStringItemsToObjects,
        filterGroupedItems
      }));
    }
    if ($$self.$$.dirty[0] & /*multiple, listOpen, value, filteredItems*/
    16777800) {
      $: if (!multiple && listOpen && value && filteredItems) setValueIndexAsHoverIndex();
    }
    if ($$self.$$.dirty[0] & /*listOpen, multiple*/
    576) {
      $: if (listOpen && multiple) $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    16) {
      $: if (filterText) $$invalidate(7, hoverItemIndex = 0);
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $: dispatchHover(hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520) {
      $: $$invalidate(25, hasValue = multiple ? value && value.length > 0 : value);
    }
    if ($$self.$$.dirty[0] & /*hasValue, filterText*/
    33554448) {
      $: $$invalidate(35, hideSelectedItem = hasValue && filterText.length > 0);
    }
    if ($$self.$$.dirty[0] & /*hasValue, disabled, loading*/
    33556512 | $$self.$$.dirty[2] & /*clearable*/
    64) {
      $: $$invalidate(34, showClear = hasValue && clearable && !disabled && !loading);
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[1] & /*placeholderAlwaysShow, placeholder*/
    100663296) {
      $: $$invalidate(33, placeholderText = placeholderAlwaysShow && multiple ? placeholder : multiple && (value == null ? void 0 : value.length) === 0 ? placeholder : value ? "" : placeholder);
    }
    if ($$self.$$.dirty[0] & /*value, multiple*/
    520) {
      $: $$invalidate(32, ariaSelection = value ? handleAriaSelection(multiple) : "");
    }
    if ($$self.$$.dirty[0] & /*filteredItems, hoverItemIndex, focused, listOpen*/
    16777412) {
      $: $$invalidate(31, ariaContext = handleAriaContent({
        filteredItems,
        hoverItemIndex,
        focused,
        listOpen
      }));
    }
    if ($$self.$$.dirty[1] & /*items*/
    1048576) {
      $: updateValueDisplay(items);
    }
    if ($$self.$$.dirty[0] & /*multiple, value, itemId*/
    8712) {
      $: $$invalidate(52, justValue = computeJustValue(multiple, value, itemId));
    }
    if ($$self.$$.dirty[0] & /*multiple, value*/
    520 | $$self.$$.dirty[2] & /*prev_value*/
    65536) {
      $: if (!multiple && prev_value && !value) dispatch("input", value);
    }
    if ($$self.$$.dirty[0] & /*listOpen, filteredItems, multiple, value*/
    16777800) {
      $: if (listOpen && filteredItems && !multiple && !value) checkHoverSelectable();
    }
    if ($$self.$$.dirty[0] & /*filteredItems*/
    16777216) {
      $: handleFilterEvent(filteredItems);
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig*/
    4096) {
      $: if (container && (floatingConfig == null ? void 0 : floatingConfig.autoUpdate) === void 0) {
        $$invalidate(81, _floatingConfig.autoUpdate = true, _floatingConfig);
      }
    }
    if ($$self.$$.dirty[0] & /*container*/
    1 | $$self.$$.dirty[2] & /*floatingConfig, _floatingConfig*/
    528384) {
      $: if (container && floatingConfig) floatingUpdate(Object.assign(_floatingConfig, floatingConfig));
    }
    if ($$self.$$.dirty[0] & /*list*/
    8388608) {
      $: $$invalidate(30, listDom = !!list);
    }
    if ($$self.$$.dirty[0] & /*list, listOpen*/
    8388672) {
      $: listMounted(list, listOpen);
    }
    if ($$self.$$.dirty[0] & /*listOpen, container, list*/
    8388673) {
      $: if (listOpen && container && list) setListWidth();
    }
    if ($$self.$$.dirty[0] & /*hoverItemIndex*/
    128) {
      $: $$invalidate(29, scrollToHoverItem = hoverItemIndex);
    }
    if ($$self.$$.dirty[0] & /*input, listOpen, focused*/
    70) {
      $: if (input && listOpen && !focused) handleFocus();
    }
  };
  return [
    container,
    input,
    focused,
    value,
    filterText,
    loading,
    listOpen,
    hoverItemIndex,
    name,
    multiple,
    multiFullItemClearable,
    disabled,
    label,
    itemId,
    containerStyles,
    hasError,
    required,
    searchable,
    inputStyles,
    hideEmptyState,
    showChevron,
    containerClasses,
    handleClear,
    list,
    filteredItems,
    hasValue,
    activeValue,
    _inputAttributes,
    prefloat,
    scrollToHoverItem,
    listDom,
    ariaContext,
    ariaSelection,
    placeholderText,
    showClear,
    hideSelectedItem,
    handleMultiItemClear,
    handleKeyDown,
    handleFocus,
    handleBlur,
    handleClick,
    handleListScroll,
    handleClickOutside,
    handleHover,
    handleItemClick,
    isItemActive,
    activeScroll,
    hoverScroll,
    floatingRef,
    floatingContent,
    $$slots,
    items,
    justValue,
    filter2,
    getItems2,
    id,
    placeholder,
    placeholderAlwaysShow,
    itemFilter,
    groupBy,
    groupFilter,
    groupHeaderSelectable,
    loadOptions,
    filterSelectedItems,
    closeListOnChange,
    clearFilterTextOnBlur,
    createGroupHeaderItem,
    getFilteredItems,
    clearable,
    debounce,
    debounceWait,
    inputAttributes,
    listAutoWidth,
    listOffset,
    floatingConfig,
    ariaValues,
    ariaListOpen,
    ariaFocused,
    prev_value,
    prev_filterText,
    prev_multiple,
    _floatingConfig,
    $$scope,
    slots,
    keydown_handler_1,
    pointerup_handler,
    mousedown_handler,
    keydown_handler,
    mouseover_handler,
    focus_handler,
    click_handler,
    div_binding,
    pointerup_handler_1,
    click_handler_1,
    input_1_binding,
    input_1_input_handler,
    div3_binding
  ];
}
var Select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment8,
      safe_not_equal,
      {
        justValue: 52,
        filter: 53,
        getItems: 54,
        id: 55,
        name: 8,
        container: 0,
        input: 1,
        multiple: 9,
        multiFullItemClearable: 10,
        disabled: 11,
        focused: 2,
        value: 3,
        filterText: 4,
        placeholder: 56,
        placeholderAlwaysShow: 57,
        items: 51,
        label: 12,
        itemFilter: 58,
        groupBy: 59,
        groupFilter: 60,
        groupHeaderSelectable: 61,
        itemId: 13,
        loadOptions: 62,
        containerStyles: 14,
        hasError: 15,
        filterSelectedItems: 63,
        required: 16,
        closeListOnChange: 64,
        clearFilterTextOnBlur: 65,
        createGroupHeaderItem: 66,
        getFilteredItems: 67,
        searchable: 17,
        inputStyles: 18,
        clearable: 68,
        loading: 5,
        listOpen: 6,
        debounce: 69,
        debounceWait: 70,
        hideEmptyState: 19,
        inputAttributes: 71,
        listAutoWidth: 72,
        showChevron: 20,
        listOffset: 73,
        hoverItemIndex: 7,
        floatingConfig: 74,
        class: 21,
        handleClear: 22,
        ariaValues: 75,
        ariaListOpen: 76,
        ariaFocused: 77
      },
      add_css7,
      [-1, -1, -1, -1, -1]
    );
  }
  get getFilteredItems() {
    return this.$$.ctx[67];
  }
  get handleClear() {
    return this.$$.ctx[22];
  }
};
var Select_default = Select;

// src/ui/components/select/base_select.svelte
function add_css8(target) {
  append_styles(target, "svelte-1kbmpno", "label.svelte-1kbmpno.svelte-1kbmpno{display:inline-block;margin-bottom:var(--size-4-1);font-weight:600}.saved-filters.svelte-1kbmpno.svelte-1kbmpno{margin-top:var(--size-4-1);font-size:var(--font-ui-small);align-self:flex-start}.saved-filters.svelte-1kbmpno details summary.svelte-1kbmpno{cursor:pointer;color:var(--text-muted);padding:var(--size-2-1) 0;user-select:none;transition:color 0.15s ease}.saved-filters.svelte-1kbmpno details summary.svelte-1kbmpno:hover{color:var(--text-normal)}.saved-filters.svelte-1kbmpno details ul.svelte-1kbmpno{margin:0;padding:0;list-style:none}.saved-filters.svelte-1kbmpno details ul li.svelte-1kbmpno{margin:0;display:flex;align-items:center;gap:var(--size-2-1)}.saved-filters.svelte-1kbmpno details ul li button.svelte-1kbmpno{text-align:left;padding:var(--size-2-1) var(--size-2-2);background:transparent;border:none;cursor:pointer;color:var(--text-normal);border-radius:var(--radius-s);white-space:nowrap;transition:background 0.15s ease, color 0.15s ease}.saved-filters.svelte-1kbmpno details ul li button.svelte-1kbmpno:hover{background:var(--background-modifier-hover)}.saved-filters.svelte-1kbmpno details ul li button.active.svelte-1kbmpno{font-weight:700;color:var(--interactive-accent)}.saved-filters.svelte-1kbmpno details ul li button.delete-btn.svelte-1kbmpno{padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:18px;line-height:1;color:var(--text-muted)}.saved-filters.svelte-1kbmpno details ul li button.delete-btn.svelte-1kbmpno:hover{color:var(--color-red);background:var(--background-modifier-error-hover)}.filter-actions.svelte-1kbmpno.svelte-1kbmpno{display:flex;gap:var(--size-4-2);margin-top:var(--size-4-2)}.filter-action-btn.svelte-1kbmpno.svelte-1kbmpno{padding:var(--size-2-2) var(--size-4-3);border-radius:var(--radius-s);cursor:pointer;font-size:var(--font-ui-small);transition:background 150ms ease, opacity 150ms ease}.filter-action-btn.save-btn.svelte-1kbmpno.svelte-1kbmpno{background:var(--interactive-accent);color:var(--text-on-accent);border:none}.filter-action-btn.save-btn.svelte-1kbmpno.svelte-1kbmpno:hover:not(:disabled){background:var(--interactive-accent-hover)}.filter-action-btn.clear-btn.svelte-1kbmpno.svelte-1kbmpno{background:transparent;color:var(--text-muted);border:1px solid var(--background-modifier-border)}.filter-action-btn.clear-btn.svelte-1kbmpno.svelte-1kbmpno:hover:not(:disabled){background:var(--background-modifier-hover)}.filter-action-btn.svelte-1kbmpno.svelte-1kbmpno:disabled{opacity:0.5;cursor:not-allowed}.svelte-select button > svg,.svelte-select .multi-item-clear > svg{cursor:pointer}.svelte-select .multi-item{border:var(--border-width) solid var(--pill-border-color) !important;outline:none !important}.svelte-select .svelte-select-list{z-index:5}.svelte-select .clear-select{display:none !important}.svelte-select.focused{transition:box-shadow 150ms ease}.svelte-select input:focus-visible{outline:none}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[19] = list[i];
  return child_ctx;
}
function create_if_block4(ctx) {
  let button;
  let t;
  let button_aria_label_value;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[16](
        /*option*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      button = element("button");
      t = text("\xD7");
      attr(button, "class", "delete-btn svelte-1kbmpno");
      attr(button, "aria-label", button_aria_label_value = "Delete filter: " + /*option*/
      ctx[19].displayText);
    },
    m(target, anchor) {
      insert(target, button, anchor);
      append(button, t);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*savedFilterOptions*/
      512 && button_aria_label_value !== (button_aria_label_value = "Delete filter: " + /*option*/
      ctx[19].displayText)) {
        attr(button, "aria-label", button_aria_label_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_each_block4(ctx) {
  let li;
  let t0;
  let button;
  let t1_value = (
    /*option*/
    ctx[19].displayText + ""
  );
  let t1;
  let button_aria_label_value;
  let button_aria_pressed_value;
  let t2;
  let mounted;
  let dispose;
  let if_block = (
    /*onDeleteClick*/
    ctx[7] && create_if_block4(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[17](
        /*option*/
        ctx[19]
      )
    );
  }
  return {
    c() {
      li = element("li");
      if (if_block) if_block.c();
      t0 = space();
      button = element("button");
      t1 = text(t1_value);
      t2 = space();
      attr(button, "aria-label", button_aria_label_value = "Load saved filter: " + /*option*/
      ctx[19].displayText);
      attr(button, "aria-pressed", button_aria_pressed_value = /*option*/
      ctx[19].filter.id === /*activeFilterId*/
      ctx[6]);
      attr(button, "class", "svelte-1kbmpno");
      toggle_class(
        button,
        "active",
        /*option*/
        ctx[19].filter.id === /*activeFilterId*/
        ctx[6]
      );
      attr(li, "class", "svelte-1kbmpno");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      if (if_block) if_block.m(li, null);
      append(li, t0);
      append(li, button);
      append(button, t1);
      append(li, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (
        /*onDeleteClick*/
        ctx[7]
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block4(ctx);
          if_block.c();
          if_block.m(li, t0);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*savedFilterOptions*/
      512 && t1_value !== (t1_value = /*option*/
      ctx[19].displayText + "")) set_data(t1, t1_value);
      if (dirty & /*savedFilterOptions*/
      512 && button_aria_label_value !== (button_aria_label_value = "Load saved filter: " + /*option*/
      ctx[19].displayText)) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (dirty & /*savedFilterOptions, activeFilterId*/
      576 && button_aria_pressed_value !== (button_aria_pressed_value = /*option*/
      ctx[19].filter.id === /*activeFilterId*/
      ctx[6])) {
        attr(button, "aria-pressed", button_aria_pressed_value);
      }
      if (dirty & /*savedFilterOptions, activeFilterId*/
      576) {
        toggle_class(
          button,
          "active",
          /*option*/
          ctx[19].filter.id === /*activeFilterId*/
          ctx[6]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block) if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let div3;
  let label_1;
  let t0;
  let t1;
  let t2;
  let div0;
  let details;
  let summary;
  let t4;
  let ul;
  let t5;
  let div1;
  let select;
  let div;
  let updating_value;
  let t6;
  let div2;
  let button0;
  let t7;
  let t8;
  let button1;
  let t9;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*savedFilterOptions*/
    ctx[9]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  function select_value_binding(value) {
    ctx[18](value);
  }
  let select_props = {
    name: (
      /*fieldName*/
      ctx[10]
    ),
    multiple: true,
    closeListOnChange: false,
    listAutoWidth: true,
    placeholder: "",
    items: (
      /*items*/
      ctx[1]
    )
  };
  if (
    /*selectedItems*/
    ctx[8] !== void 0
  ) {
    select_props.value = /*selectedItems*/
    ctx[8];
  }
  select = new Select_default({ props: select_props });
  binding_callbacks.push(() => bind(select, "value", select_value_binding));
  return {
    c() {
      div3 = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = text(":");
      t2 = space();
      div0 = element("div");
      details = element("details");
      summary = element("summary");
      summary.textContent = "Saved filters";
      t4 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      div1 = element("div");
      div = element("div");
      create_component(select.$$.fragment);
      t6 = space();
      div2 = element("div");
      button0 = element("button");
      t7 = text("Save");
      t8 = space();
      button1 = element("button");
      t9 = text("Clear");
      attr(
        label_1,
        "for",
        /*fieldName*/
        ctx[10]
      );
      attr(label_1, "class", "svelte-1kbmpno");
      attr(summary, "class", "svelte-1kbmpno");
      attr(ul, "role", "list");
      attr(ul, "class", "svelte-1kbmpno");
      attr(div0, "class", "saved-filters svelte-1kbmpno");
      set_style(div, "display", "contents");
      set_style(div, "--background", "var(--background-primary)");
      set_style(div, "--border", "var(--border-width) solid var(--background-modifier-border)");
      set_style(div, "--border-focused", "var(--border-width) solid var(--background-modifier-border-focus)");
      set_style(div, "--border-hover", "var(--border-width) solid var(--background-modifier-border-hover)");
      set_style(div, "--border-radius", "var(--input-radius)");
      set_style(div, "--item-hover-bg", "var(--background-modifier-hover)");
      set_style(div, "--list-background", "var(--background-primary)");
      set_style(div, "--list-border", "var(--border-width) solid var(--background-modifier-border)");
      set_style(div, "--multi-item-bg", "var(--pill-background)");
      set_style(div, "--multi-item-clear-icon-color", "var(--pill-color)");
      set_style(div, "--multi-item-color", "var(--pill-color)");
      set_style(div, "--multi-item-height", "auto");
      set_style(div, "--multi-item-outline", "var(--border-width) solid var(--pill-border-color)");
      set_style(div, "--multi-item-padding", "var(--pill-padding-y) var(--pill-padding-x)");
      set_style(div, "--multi-select-input-padding", "var(--size-4-2)");
      set_style(div, "--multi-select-input-margin", "var(--size-2-2) var(--size-4-4) var(--size-2-2) var(--size-2-2)");
      set_style(div, "--input-color", "var(--text-normal)");
      set_style(div, "--placeholder-color", "var(--text-muted)");
      attr(div1, "class", "select-wrapper");
      attr(button0, "class", "filter-action-btn save-btn svelte-1kbmpno");
      button0.disabled = /*addButtonDisabled*/
      ctx[2];
      attr(button0, "aria-label", "Save filter");
      attr(button1, "class", "filter-action-btn clear-btn svelte-1kbmpno");
      button1.disabled = /*clearButtonDisabled*/
      ctx[4];
      attr(button1, "aria-label", "Clear filter");
      attr(div2, "class", "filter-actions svelte-1kbmpno");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, label_1);
      append(label_1, t0);
      append(label_1, t1);
      append(div3, t2);
      append(div3, div0);
      append(div0, details);
      append(details, summary);
      append(details, t4);
      append(details, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      append(div3, t5);
      append(div3, div1);
      append(div1, div);
      mount_component(select, div, null);
      append(div3, t6);
      append(div3, div2);
      append(div2, button0);
      append(button0, t7);
      append(div2, t8);
      append(div2, button1);
      append(button1, t9);
      current = true;
      if (!mounted) {
        dispose = [
          listen(button0, "click", function() {
            if (is_function(
              /*onAddClick*/
              ctx[3]
            )) ctx[3].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*onClearClick*/
              ctx[5]
            )) ctx[5].apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (!current || dirty & /*label*/
      1) set_data(
        t0,
        /*label*/
        ctx[0]
      );
      if (!current || dirty & /*fieldName*/
      1024) {
        attr(
          label_1,
          "for",
          /*fieldName*/
          ctx[10]
        );
      }
      if (dirty & /*savedFilterOptions, activeFilterId, handleSavedFilterSelect, onDeleteClick*/
      2752) {
        each_value = ensure_array_like(
          /*savedFilterOptions*/
          ctx[9]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      const select_changes = {};
      if (dirty & /*fieldName*/
      1024) select_changes.name = /*fieldName*/
      ctx[10];
      if (dirty & /*items*/
      2) select_changes.items = /*items*/
      ctx[1];
      if (!updating_value && dirty & /*selectedItems*/
      256) {
        updating_value = true;
        select_changes.value = /*selectedItems*/
        ctx[8];
        add_flush_callback(() => updating_value = false);
      }
      select.$set(select_changes);
      if (!current || dirty & /*addButtonDisabled*/
      4) {
        button0.disabled = /*addButtonDisabled*/
        ctx[2];
      }
      if (!current || dirty & /*clearButtonDisabled*/
      16) {
        button1.disabled = /*clearButtonDisabled*/
        ctx[4];
      }
    },
    i(local) {
      if (current) return;
      transition_in(select.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(select.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(select);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let fieldName;
  let savedFilterOptions;
  let { label } = $$props;
  let { items } = $$props;
  let { value } = $$props;
  let { savedFilters = [] } = $$props;
  let { loadSavedFilter = void 0 } = $$props;
  let { addButtonDisabled = false } = $$props;
  let { onAddClick = void 0 } = $$props;
  let { clearButtonDisabled = false } = $$props;
  let { onClearClick = void 0 } = $$props;
  let { activeFilterId = void 0 } = $$props;
  let { onDeleteClick = void 0 } = $$props;
  let selectedItems = items.filter((item) => value.includes(item.value));
  function clearSelection() {
    $$invalidate(8, selectedItems = []);
  }
  async function handleSavedFilterSelect(option) {
    if (loadSavedFilter) {
      loadSavedFilter(option.filter);
      await tick();
      $$invalidate(8, selectedItems = items.filter((item) => value.includes(item.value)));
    }
  }
  const click_handler = (option) => onDeleteClick == null ? void 0 : onDeleteClick(option.filter.id, option.displayText);
  const click_handler_1 = (option) => handleSavedFilterSelect(option);
  function select_value_binding(value2) {
    selectedItems = value2;
    $$invalidate(8, selectedItems);
  }
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2) $$invalidate(0, label = $$props2.label);
    if ("items" in $$props2) $$invalidate(1, items = $$props2.items);
    if ("value" in $$props2) $$invalidate(12, value = $$props2.value);
    if ("savedFilters" in $$props2) $$invalidate(13, savedFilters = $$props2.savedFilters);
    if ("loadSavedFilter" in $$props2) $$invalidate(14, loadSavedFilter = $$props2.loadSavedFilter);
    if ("addButtonDisabled" in $$props2) $$invalidate(2, addButtonDisabled = $$props2.addButtonDisabled);
    if ("onAddClick" in $$props2) $$invalidate(3, onAddClick = $$props2.onAddClick);
    if ("clearButtonDisabled" in $$props2) $$invalidate(4, clearButtonDisabled = $$props2.clearButtonDisabled);
    if ("onClearClick" in $$props2) $$invalidate(5, onClearClick = $$props2.onClearClick);
    if ("activeFilterId" in $$props2) $$invalidate(6, activeFilterId = $$props2.activeFilterId);
    if ("onDeleteClick" in $$props2) $$invalidate(7, onDeleteClick = $$props2.onDeleteClick);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*label*/
    1) {
      $: $$invalidate(10, fieldName = `field=${label}`);
    }
    if ($$self.$$.dirty & /*selectedItems*/
    256) {
      $: $$invalidate(12, value = (selectedItems != null ? selectedItems : []).map(({ value: value2 }) => value2));
    }
    if ($$self.$$.dirty & /*savedFilters*/
    8192) {
      $: $$invalidate(9, savedFilterOptions = savedFilters.map((filter2) => {
        const displayText = filter2.tag ? filter2.tag.tags.join(", ") : "";
        return { filter: filter2, displayText };
      }));
    }
  };
  return [
    label,
    items,
    addButtonDisabled,
    onAddClick,
    clearButtonDisabled,
    onClearClick,
    activeFilterId,
    onDeleteClick,
    selectedItems,
    savedFilterOptions,
    fieldName,
    handleSavedFilterSelect,
    value,
    savedFilters,
    loadSavedFilter,
    clearSelection,
    click_handler,
    click_handler_1,
    select_value_binding
  ];
}
var Base_select = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance6,
      create_fragment9,
      safe_not_equal,
      {
        label: 0,
        items: 1,
        value: 12,
        savedFilters: 13,
        loadSavedFilter: 14,
        addButtonDisabled: 2,
        onAddClick: 3,
        clearButtonDisabled: 4,
        onClearClick: 5,
        activeFilterId: 6,
        onDeleteClick: 7,
        clearSelection: 15
      },
      add_css8
    );
  }
  get clearSelection() {
    return this.$$.ctx[15];
  }
};
var base_select_default = Base_select;

// src/ui/components/select/select_tag.svelte
function create_fragment10(ctx) {
  let baseselect;
  let updating_value;
  let current;
  function baseselect_value_binding(value) {
    ctx[14](value);
  }
  let baseselect_props = {
    items: (
      /*tags*/
      ctx[1].map(func)
    ),
    label: "Filter by tag",
    savedFilters: (
      /*savedFilters*/
      ctx[2]
    ),
    loadSavedFilter: (
      /*loadSavedFilter*/
      ctx[9]
    ),
    addButtonDisabled: (
      /*addButtonDisabled*/
      ctx[3]
    ),
    onAddClick: (
      /*onAddClick*/
      ctx[4]
    ),
    clearButtonDisabled: (
      /*clearButtonDisabled*/
      ctx[5]
    ),
    onClearClick: (
      /*handleClear*/
      ctx[10]
    ),
    activeFilterId: (
      /*activeFilterId*/
      ctx[6]
    ),
    onDeleteClick: (
      /*onDeleteClick*/
      ctx[7]
    )
  };
  if (
    /*value*/
    ctx[0] !== void 0
  ) {
    baseselect_props.value = /*value*/
    ctx[0];
  }
  baseselect = new base_select_default({ props: baseselect_props });
  ctx[13](baseselect);
  binding_callbacks.push(() => bind(baseselect, "value", baseselect_value_binding));
  return {
    c() {
      create_component(baseselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(baseselect, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const baseselect_changes = {};
      if (dirty & /*tags*/
      2) baseselect_changes.items = /*tags*/
      ctx2[1].map(func);
      if (dirty & /*savedFilters*/
      4) baseselect_changes.savedFilters = /*savedFilters*/
      ctx2[2];
      if (dirty & /*addButtonDisabled*/
      8) baseselect_changes.addButtonDisabled = /*addButtonDisabled*/
      ctx2[3];
      if (dirty & /*onAddClick*/
      16) baseselect_changes.onAddClick = /*onAddClick*/
      ctx2[4];
      if (dirty & /*clearButtonDisabled*/
      32) baseselect_changes.clearButtonDisabled = /*clearButtonDisabled*/
      ctx2[5];
      if (dirty & /*activeFilterId*/
      64) baseselect_changes.activeFilterId = /*activeFilterId*/
      ctx2[6];
      if (dirty & /*onDeleteClick*/
      128) baseselect_changes.onDeleteClick = /*onDeleteClick*/
      ctx2[7];
      if (!updating_value && dirty & /*value*/
      1) {
        updating_value = true;
        baseselect_changes.value = /*value*/
        ctx2[0];
        add_flush_callback(() => updating_value = false);
      }
      baseselect.$set(baseselect_changes);
    },
    i(local) {
      if (current) return;
      transition_in(baseselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(baseselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      ctx[13](null);
      destroy_component(baseselect, detaching);
    }
  };
}
var func = (tag) => ({ label: tag, value: tag });
function instance7($$self, $$props, $$invalidate) {
  let { tags } = $$props;
  let { value } = $$props;
  let { savedFilters = [] } = $$props;
  let { onLoadFilter = void 0 } = $$props;
  let { addButtonDisabled = false } = $$props;
  let { onAddClick = void 0 } = $$props;
  let { clearButtonDisabled = false } = $$props;
  let { onClearClick = void 0 } = $$props;
  let { activeFilterId = void 0 } = $$props;
  let { onDeleteClick = void 0 } = $$props;
  let baseSelectRef;
  function loadSavedFilter(filter2) {
    if (filter2.tag) {
      if (activeFilterId === filter2.id) {
        baseSelectRef == null ? void 0 : baseSelectRef.clearSelection();
      } else {
        $$invalidate(0, value = [...filter2.tag.tags]);
      }
      onLoadFilter == null ? void 0 : onLoadFilter(filter2.id);
    }
  }
  function handleClear() {
    baseSelectRef == null ? void 0 : baseSelectRef.clearSelection();
    onClearClick == null ? void 0 : onClearClick();
  }
  function baseselect_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      baseSelectRef = $$value;
      $$invalidate(8, baseSelectRef);
    });
  }
  function baseselect_value_binding(value$1) {
    value = value$1;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("tags" in $$props2) $$invalidate(1, tags = $$props2.tags);
    if ("value" in $$props2) $$invalidate(0, value = $$props2.value);
    if ("savedFilters" in $$props2) $$invalidate(2, savedFilters = $$props2.savedFilters);
    if ("onLoadFilter" in $$props2) $$invalidate(11, onLoadFilter = $$props2.onLoadFilter);
    if ("addButtonDisabled" in $$props2) $$invalidate(3, addButtonDisabled = $$props2.addButtonDisabled);
    if ("onAddClick" in $$props2) $$invalidate(4, onAddClick = $$props2.onAddClick);
    if ("clearButtonDisabled" in $$props2) $$invalidate(5, clearButtonDisabled = $$props2.clearButtonDisabled);
    if ("onClearClick" in $$props2) $$invalidate(12, onClearClick = $$props2.onClearClick);
    if ("activeFilterId" in $$props2) $$invalidate(6, activeFilterId = $$props2.activeFilterId);
    if ("onDeleteClick" in $$props2) $$invalidate(7, onDeleteClick = $$props2.onDeleteClick);
  };
  return [
    value,
    tags,
    savedFilters,
    addButtonDisabled,
    onAddClick,
    clearButtonDisabled,
    activeFilterId,
    onDeleteClick,
    baseSelectRef,
    loadSavedFilter,
    handleClear,
    onLoadFilter,
    onClearClick,
    baseselect_binding,
    baseselect_value_binding
  ];
}
var Select_tag = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment10, safe_not_equal, {
      tags: 1,
      value: 0,
      savedFilters: 2,
      onLoadFilter: 11,
      addButtonDisabled: 3,
      onAddClick: 4,
      clearButtonDisabled: 5,
      onClearClick: 12,
      activeFilterId: 6,
      onDeleteClick: 7
    });
  }
};
var select_tag_default = Select_tag;

// src/ui/components/delete_filter_modal.svelte
function add_css9(target) {
  append_styles(target, "svelte-tjv0og", ".modal-backdrop.svelte-tjv0og{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0, 0, 0, 0.5);display:flex;align-items:flex-start;justify-content:center;padding-top:20vh;z-index:1000}.modal.svelte-tjv0og{background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-m);padding:var(--size-4-4);min-width:300px;max-width:500px;box-shadow:var(--shadow-l);pointer-events:auto}h3.svelte-tjv0og{margin:0 0 var(--size-4-3) 0;font-size:var(--font-ui-medium);font-weight:var(--font-semibold)}.filter-preview.svelte-tjv0og{padding:var(--size-4-2);background:var(--background-secondary);border-radius:var(--radius-s);margin-bottom:var(--size-4-4);font-family:var(--font-monospace);font-size:var(--font-ui-small)}.modal-actions.svelte-tjv0og{display:flex;gap:var(--size-4-2);justify-content:flex-end}button.svelte-tjv0og{padding:var(--size-4-1) var(--size-4-3);border-radius:var(--radius-s);cursor:pointer;font-size:var(--font-ui-small);transition:background 100ms linear}.cancel-btn.svelte-tjv0og{background:var(--background-secondary);border:1px solid var(--background-modifier-border);color:var(--text-normal)}.cancel-btn.svelte-tjv0og:hover{background:var(--background-secondary-alt)}.delete-btn.svelte-tjv0og{background:var(--color-red);border:none;color:white}.delete-btn.svelte-tjv0og:hover{background:var(--color-red);opacity:0.8}");
}
function create_fragment11(ctx) {
  let div3;
  let div2;
  let h3;
  let t1;
  let div0;
  let t2;
  let t3;
  let div1;
  let button0;
  let t5;
  let button1;
  let mounted;
  let dispose;
  return {
    c() {
      div3 = element("div");
      div2 = element("div");
      h3 = element("h3");
      h3.textContent = "Delete saved filter?";
      t1 = space();
      div0 = element("div");
      t2 = text(
        /*filterText*/
        ctx[0]
      );
      t3 = space();
      div1 = element("div");
      button0 = element("button");
      button0.textContent = "Cancel";
      t5 = space();
      button1 = element("button");
      button1.textContent = "Delete";
      attr(h3, "id", "modal-title");
      attr(h3, "class", "svelte-tjv0og");
      attr(div0, "class", "filter-preview svelte-tjv0og");
      attr(button0, "class", "cancel-btn svelte-tjv0og");
      attr(button1, "class", "delete-btn svelte-tjv0og");
      attr(div1, "class", "modal-actions svelte-tjv0og");
      attr(div2, "class", "modal svelte-tjv0og");
      attr(div2, "role", "dialog");
      attr(div2, "aria-modal", "true");
      attr(div2, "aria-labelledby", "modal-title");
      attr(div3, "class", "modal-backdrop svelte-tjv0og");
      attr(div3, "role", "presentation");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append(div3, div2);
      append(div2, h3);
      append(div2, t1);
      append(div2, div0);
      append(div0, t2);
      append(div2, t3);
      append(div2, div1);
      append(div1, button0);
      append(div1, t5);
      append(div1, button1);
      ctx[6](button1);
      ctx[7](div2);
      if (!mounted) {
        dispose = [
          listen(
            window,
            "keydown",
            /*handleKeydown*/
            ctx[5]
          ),
          listen(button0, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[2]
            )) ctx[2].apply(this, arguments);
          }),
          listen(button1, "click", function() {
            if (is_function(
              /*onConfirm*/
              ctx[1]
            )) ctx[1].apply(this, arguments);
          }),
          listen(
            div3,
            "click",
            /*click_handler*/
            ctx[8]
          )
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*filterText*/
      1) set_data(
        t2,
        /*filterText*/
        ctx[0]
      );
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      ctx[6](null);
      ctx[7](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let { filterText } = $$props;
  let { onConfirm } = $$props;
  let { onCancel } = $$props;
  let modalElement;
  let deleteButton;
  function handleKeydown(event) {
    if (event.key === "Escape") {
      onCancel();
    }
  }
  onMount(() => {
    deleteButton == null ? void 0 : deleteButton.focus();
    const focusableElements = modalElement.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    const firstElement = focusableElements[0];
    const lastElement = focusableElements[focusableElements.length - 1];
    const handleTabKey = (e) => {
      if (e.key === "Tab") {
        if (e.shiftKey && document.activeElement === firstElement) {
          e.preventDefault();
          lastElement == null ? void 0 : lastElement.focus();
        } else if (!e.shiftKey && document.activeElement === lastElement) {
          e.preventDefault();
          firstElement == null ? void 0 : firstElement.focus();
        }
      }
    };
    modalElement.addEventListener("keydown", handleTabKey);
    return () => modalElement.removeEventListener("keydown", handleTabKey);
  });
  function button1_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      deleteButton = $$value;
      $$invalidate(4, deleteButton);
    });
  }
  function div2_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      modalElement = $$value;
      $$invalidate(3, modalElement);
    });
  }
  const click_handler = (e) => e.target === e.currentTarget && onCancel();
  $$self.$$set = ($$props2) => {
    if ("filterText" in $$props2) $$invalidate(0, filterText = $$props2.filterText);
    if ("onConfirm" in $$props2) $$invalidate(1, onConfirm = $$props2.onConfirm);
    if ("onCancel" in $$props2) $$invalidate(2, onCancel = $$props2.onCancel);
  };
  return [
    filterText,
    onConfirm,
    onCancel,
    modalElement,
    deleteButton,
    handleKeydown,
    button1_binding,
    div2_binding,
    click_handler
  ];
}
var Delete_filter_modal = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment11, safe_not_equal, { filterText: 0, onConfirm: 1, onCancel: 2 }, add_css9);
  }
};
var delete_filter_modal_default = Delete_filter_modal;

// node_modules/zod/lib/index.mjs
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error();
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return void 0;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
      // second overwrites first
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};
var ZodError = class _ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  static assert(value) {
    if (!(value instanceof _ZodError)) {
      throw new Error(`Not a ZodError: ${value}`);
    }
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
};
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  if (issueData.message !== void 0) {
    return {
      ...issueData,
      path: fullPath,
      message: issueData.message
    };
  }
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: errorMessage
  };
};
var EMPTY_PATH = [];
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      overrideMap,
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
var ParseStatus = class _ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      const key = await pair.key;
      const value = await pair.value;
      syncPairs.push({
        key,
        value
      });
    }
    return _ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
};
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
})(errorUtil || (errorUtil = {}));
var _ZodEnum_cache;
var _ZodNativeEnum_cache;
var ParseInputLazyPath = class {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
};
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (iss, ctx) => {
    var _a, _b;
    const { message } = params;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a = message !== null && message !== void 0 ? message : required_error) !== null && _a !== void 0 ? _a : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b !== void 0 ? _b : ctx.defaultError };
  };
  return { errorMap: customMap, description };
}
var ZodType = class {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus(),
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === void 0 ? void 0 : params.async) !== null && _a !== void 0 ? _a : false,
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === void 0 ? void 0 : params.errorMap,
        async: true
      },
      path: (params === null || params === void 0 ? void 0 : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(void 0).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
};
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[0-9a-z]+$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var nanoidRegex = /^[a-z0-9_-]{21}$/i;
var durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
var emojiRegex;
var ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
var dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
var dateRegex = new RegExp(`^${dateRegexSource}$`);
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
var ZodString = class _ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "nanoid") {
        if (!nanoidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "nanoid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "date") {
        const regex = dateRegex;
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "date",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "time") {
        const regex = timeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "time",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "duration") {
        if (!durationRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "duration",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "base64") {
        if (!base64Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "base64",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  nanoid(message) {
    return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  base64(message) {
    return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a, _b;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        local: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      offset: (_a = options === null || options === void 0 ? void 0 : options.offset) !== null && _a !== void 0 ? _a : false,
      local: (_b = options === null || options === void 0 ? void 0 : options.local) !== null && _b !== void 0 ? _b : false,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  date(message) {
    return this._addCheck({ kind: "date", message });
  }
  time(options) {
    if (typeof options === "string") {
      return this._addCheck({
        kind: "time",
        precision: null,
        message: options
      });
    }
    return this._addCheck({
      kind: "time",
      precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  duration(message) {
    return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === void 0 ? void 0 : options.position,
      ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  /**
   * @deprecated Use z.string().min(1) instead.
   * @see {@link ZodString.min}
   */
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new _ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isDate() {
    return !!this._def.checks.find((ch) => ch.kind === "date");
  }
  get isTime() {
    return !!this._def.checks.find((ch) => ch.kind === "time");
  }
  get isDuration() {
    return !!this._def.checks.find((ch) => ch.kind === "duration");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isNANOID() {
    return !!this._def.checks.find((ch) => ch.kind === "nanoid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get isBase64() {
    return !!this._def.checks.find((ch) => ch.kind === "base64");
  }
  get minLength() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxLength() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
var ZodNumber = class _ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max2 = null, min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      } else if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return Number.isFinite(min2) && Number.isFinite(max2);
  }
};
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodBigInt = class _ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = void 0;
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new _ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new _ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2;
  }
  get maxValue() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2;
  }
};
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === void 0 ? void 0 : params.coerce) !== null && _a !== void 0 ? _a : false,
    ...processCreateParams(params)
  });
};
var ZodBoolean = class extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    ...processCreateParams(params)
  });
};
var ZodDate = class _ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus();
    let ctx = void 0;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new _ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min2 === null || ch.value > min2)
          min2 = ch.value;
      }
    }
    return min2 != null ? new Date(min2) : null;
  }
  get maxDate() {
    let max2 = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max2 === null || ch.value < max2)
          max2 = ch.value;
      }
    }
    return max2 != null ? new Date(max2) : null;
  }
};
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === void 0 ? void 0 : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};
var ZodSymbol = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};
var ZodUndefined = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};
var ZodNull = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};
var ZodAny = class extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};
var ZodUnknown = class extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
};
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};
var ZodNever = class extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
};
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};
var ZodVoid = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
};
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};
var ZodArray = class _ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : void 0,
          maximum: tooBig ? def.exactLength.value : void 0,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new _ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new _ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new _ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
var ZodObject = class _ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip") ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(
            new ParseInputLazyPath(ctx, value, ctx.path, key)
            //, ctx.child(key), value, getParsedType(value)
          ),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          syncPairs.push({
            key,
            value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== void 0 ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === void 0 ? void 0 : _b.call(_a, issue, ctx).message) !== null && _c !== void 0 ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new _ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  // const AugmentFactory =
  //   <Def extends ZodObjectDef>(def: Def) =>
  //   <Augmentation extends ZodRawShape>(
  //     augmentation: Augmentation
  //   ): ZodObject<
  //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
  //     Def["unknownKeys"],
  //     Def["catchall"]
  //   > => {
  //     return new ZodObject({
  //       ...def,
  //       shape: () => ({
  //         ...def.shape(),
  //         ...augmentation,
  //       }),
  //     }) as any;
  //   };
  extend(augmentation) {
    return new _ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  /**
   * Prior to zod@1.0.12 there was a bug in the
   * inferred type of merged objects. Please
   * upgrade if you are experiencing issues.
   */
  merge(merging) {
    const merged = new _ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  // merge<
  //   Incoming extends AnyZodObject,
  //   Augmentation extends Incoming["shape"],
  //   NewOutput extends {
  //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
  //       ? Augmentation[k]["_output"]
  //       : k extends keyof Output
  //       ? Output[k]
  //       : never;
  //   },
  //   NewInput extends {
  //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
  //       ? Augmentation[k]["_input"]
  //       : k extends keyof Input
  //       ? Input[k]
  //       : never;
  //   }
  // >(
  //   merging: Incoming
  // ): ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"],
  //   NewOutput,
  //   NewInput
  // > {
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  // merge<Incoming extends AnyZodObject>(
  //   merging: Incoming
  // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
  // ZodObject<
  //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
  //   Incoming["_def"]["unknownKeys"],
  //   Incoming["_def"]["catchall"]
  // > {
  //   // const mergedShape = objectUtil.mergeShapes(
  //   //   this._def.shape(),
  //   //   merging._def.shape()
  //   // );
  //   const merged: any = new ZodObject({
  //     unknownKeys: merging._def.unknownKeys,
  //     catchall: merging._def.catchall,
  //     shape: () =>
  //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
  //     typeName: ZodFirstPartyTypeKind.ZodObject,
  //   }) as any;
  //   return merged;
  // }
  catchall(index) {
    return new _ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  /**
   * @deprecated
   */
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new _ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
};
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
var ZodUnion = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = void 0;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
};
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return util.objectValues(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [void 0];
  } else if (type instanceof ZodNull) {
    return [null];
  } else if (type instanceof ZodOptional) {
    return [void 0, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodNullable) {
    return [null, ...getDiscriminator(type.unwrap())];
  } else if (type instanceof ZodBranded) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodReadonly) {
    return getDiscriminator(type.unwrap());
  } else if (type instanceof ZodCatch) {
    return getDiscriminator(type._def.innerType);
  } else {
    return [];
  }
};
var ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  /**
   * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
   * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
   * have a different value for each object in the union.
   * @param discriminator the name of the discriminator property
   * @param types an array of object schemas
   * @param params
   */
  static create(discriminator, options, params) {
    const optionsMap = /* @__PURE__ */ new Map();
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues.length) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new _ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
};
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
var ZodIntersection = class extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
};
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};
var ZodTuple = class _ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new _ZodTuple({
      ...this._def,
      rest
    });
  }
};
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};
var ZodRecord = class _ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new _ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new _ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
};
var ZodMap = class extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = /* @__PURE__ */ new Map();
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = /* @__PURE__ */ new Map();
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
};
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};
var ZodSet = class _ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = /* @__PURE__ */ new Set();
      for (const element2 of elements2) {
        if (element2.status === "aborted")
          return INVALID;
        if (element2.status === "dirty")
          status.dirty();
        parsedSet.add(element2.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new _ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new _ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size2, message) {
    return this.min(size2, message).max(size2, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
};
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};
var ZodFunction = class _ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new _ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new _ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  strictImplement(func2) {
    const validatedFunc = this.parse(func2);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new _ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
};
var ZodLazy = class extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
};
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};
var ZodLiteral = class extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
};
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};
function createZodEnum(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
}
var ZodEnum = class _ZodEnum extends ZodType {
  constructor() {
    super(...arguments);
    _ZodEnum_cache.set(this, void 0);
  }
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodEnum_cache, new Set(this._def.values), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodEnum_cache, "f").has(input.data)) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values, newDef = this._def) {
    return _ZodEnum.create(values, {
      ...this._def,
      ...newDef
    });
  }
  exclude(values, newDef = this._def) {
    return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
      ...this._def,
      ...newDef
    });
  }
};
_ZodEnum_cache = /* @__PURE__ */ new WeakMap();
ZodEnum.create = createZodEnum;
var ZodNativeEnum = class extends ZodType {
  constructor() {
    super(...arguments);
    _ZodNativeEnum_cache.set(this, void 0);
  }
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f")) {
      __classPrivateFieldSet(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
    }
    if (!__classPrivateFieldGet(this, _ZodNativeEnum_cache, "f").has(input.data)) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
};
_ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};
var ZodPromise = class extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
};
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};
var ZodEffects = class extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.async) {
        return Promise.resolve(processed).then(async (processed2) => {
          if (status.value === "aborted")
            return INVALID;
          const result = await this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
          if (result.status === "aborted")
            return INVALID;
          if (result.status === "dirty")
            return DIRTY(result.value);
          if (status.value === "dirty")
            return DIRTY(result.value);
          return result;
        });
      } else {
        if (status.value === "aborted")
          return INVALID;
        const result = this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
        if (result.status === "aborted")
          return INVALID;
        if (result.status === "dirty")
          return DIRTY(result.value);
        if (status.value === "dirty")
          return DIRTY(result.value);
        return result;
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
};
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};
var ZodOptional = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(void 0);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};
var ZodNullable = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};
var ZodDefault = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
};
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};
var ZodCatch = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
};
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};
var ZodNaN = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
};
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");
var ZodBranded = class extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
};
var ZodPipeline = class _ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new _ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
};
var ZodReadonly = class extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    const freeze = (data) => {
      if (isValid(data)) {
        data.value = Object.freeze(data.value);
      }
      return data;
    };
    return isAsync(result) ? result.then((data) => freeze(data)) : freeze(result);
  }
  unwrap() {
    return this._def.innerType;
  }
};
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
function custom(check, params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== void 0 ? _a : fatal) !== null && _b !== void 0 ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
}
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = /* @__PURE__ */ Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  datetimeRegex,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  "enum": enumType,
  "function": functionType,
  "instanceof": instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  "null": nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  "undefined": undefinedType,
  union: unionType,
  unknown: unknownType,
  "void": voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// src/ui/tasks/task.ts
var import_sha256 = __toESM(require_sha256());

// src/parsing/tags/tags.ts
function getTagsFromContent(content) {
  const tags = /* @__PURE__ */ new Set();
  const matches = content.matchAll(tagsRegex);
  for (const match of matches) {
    if (match[1] && tagNonNumericTest.test(match[1])) {
      tags.add(match[1]);
    }
  }
  return tags;
}
var tagsRegex = /#([-_/\p{L}\p{N}]+)/gu;
var tagNonNumericTest = /\p{L}/u;

// src/ui/tasks/task.ts
var DEFAULT_DONE_STATUS_MARKERS = "xX";
var DEFAULT_IGNORED_STATUS_MARKERS = "";
function validateStatusMarkers(markers) {
  const errors = [];
  const chars = Array.from(markers);
  const seen = /* @__PURE__ */ new Set();
  for (let i = 0; i < chars.length; i++) {
    const char = chars[i];
    if (!char) continue;
    if (seen.has(char)) {
      errors.push(`Duplicate marker '${char}' at position ${i + 1}`);
      continue;
    }
    seen.add(char);
    if (/\s/.test(char)) {
      errors.push(`Marker at position ${i + 1} is whitespace`);
    }
    if (char.charCodeAt(0) < 32 || char.charCodeAt(0) === 127) {
      errors.push(`Marker at position ${i + 1} is a control character`);
    }
  }
  return errors;
}
function validateDoneStatusMarkers(markers) {
  if (!markers || markers.length === 0) {
    return ["Done status markers cannot be empty"];
  }
  return validateStatusMarkers(markers);
}
function validateIgnoredStatusMarkers(markers) {
  if (!markers || markers.length === 0) {
    return [];
  }
  return validateStatusMarkers(markers);
}
function isStatusMatch(statusContent, markers) {
  if (!statusContent || !markers) return false;
  const contentChars = Array.from(statusContent);
  const markersChars = Array.from(markers);
  if (contentChars.length !== 1) {
    return false;
  }
  const singleChar = contentChars[0];
  if (!singleChar) return false;
  return markersChars.includes(singleChar);
}
function isDoneStatus(statusContent, doneStatusMarkers) {
  return isStatusMatch(statusContent, doneStatusMarkers);
}
function isIgnoredStatus(statusContent, ignoredStatusMarkers) {
  return isStatusMatch(statusContent, ignoredStatusMarkers);
}
var Task2 = class {
  constructor(rawContent, fileHandle, rowIndex, columnTagTable, consolidateTags, doneStatusMarkers = DEFAULT_DONE_STATUS_MARKERS, ignoredStatusMarkers = DEFAULT_IGNORED_STATUS_MARKERS) {
    this.rowIndex = rowIndex;
    this.consolidateTags = consolidateTags;
    this.doneStatusMarkers = doneStatusMarkers;
    this.ignoredStatusMarkers = ignoredStatusMarkers;
    this._deleted = false;
    var _a;
    const [, blockLink] = (_a = rawContent.match(blockLinkRegexp)) != null ? _a : [];
    this.blockLink = blockLink;
    const match = (blockLink ? rawContent.replace(blockLinkRegexp, "") : rawContent).match(taskStringRegex);
    if (!match) {
      throw new Error(
        "Attempted to create a task from invalid raw content"
      );
    }
    const [, indentation, status, content] = match;
    if (!content) {
      throw new Error("Content not found in raw content");
    }
    const tags = getTagsFromContent(content);
    this._id = (0, import_sha256.default)(content + fileHandle.path + rowIndex).toString();
    this.content = content;
    this._displayStatus = status || " ";
    this._done = isDoneStatus(this._displayStatus, this.doneStatusMarkers);
    this._path = fileHandle.path;
    this._indentation = indentation || "";
    for (const tag of tags) {
      const kebabTag = kebab(tag);
      if (kebabTag in columnTagTable || tag === "done") {
        if (!this._column) {
          this._column = kebabTag;
        }
        tags.delete(tag);
        if (!consolidateTags) {
          this.content = this.content.replaceAll(`#${tag}`, "").trim();
        }
      }
      if (consolidateTags) {
        this.content = this.content.replaceAll(`#${tag}`, "").trim();
      }
    }
    this.tags = tags;
    this.blockLink = blockLink;
    if (this._done) {
      this._column = void 0;
    }
  }
  get id() {
    return this._id;
  }
  get done() {
    return this._done;
  }
  set done(done) {
    var _a;
    this._done = done;
    this._column = void 0;
    this._displayStatus = (_a = Array.from(this.doneStatusMarkers)[0]) != null ? _a : "x";
  }
  get path() {
    return this._path;
  }
  get indentation() {
    return this._indentation;
  }
  get column() {
    return this._column;
  }
  set column(column) {
    this._column = column;
    this._done = false;
  }
  serialise() {
    if (this._deleted) {
      return "";
    }
    return [
      this.indentation,
      `- [${this._displayStatus}] `,
      this.content.trim(),
      this.consolidateTags && this.tags.size > 0 ? ` ${Array.from(this.tags).map((tag) => `#${tag}`).join(" ")}` : "",
      this.column ? ` #${this.column}` : "",
      this.blockLink ? ` ^${this.blockLink}` : ""
    ].join("").trimEnd();
  }
  archive() {
    if (!this._done) {
      this._displayStatus = "x";
    }
    this._done = true;
    this._column = "archived";
  }
  delete() {
    this._deleted = true;
  }
};
function isTrackedTaskString(input, ignoredStatusMarkers = DEFAULT_IGNORED_STATUS_MARKERS) {
  if (input.includes("#archived")) {
    return false;
  }
  if (!taskStringRegex.test(input)) {
    return false;
  }
  const match = input.match(taskStringRegex);
  if (match) {
    const [, , status] = match;
    if (isIgnoredStatus(status, ignoredStatusMarkers)) {
      return false;
    }
  }
  return true;
}
var taskStringRegex = /^(\s*)[-*+]\s\[([^\[\]]*)\]\s(.+)/;
var blockLinkRegexp = /\s\^([a-zA-Z0-9-]+)$/;

// src/ui/settings/settings_store.ts
var VisibilityOption = /* @__PURE__ */ ((VisibilityOption2) => {
  VisibilityOption2["Auto"] = "auto";
  VisibilityOption2["NeverShow"] = "never";
  VisibilityOption2["AlwaysShow"] = "always";
  return VisibilityOption2;
})(VisibilityOption || {});
var ScopeOption = /* @__PURE__ */ ((ScopeOption2) => {
  ScopeOption2["Folder"] = "folder";
  ScopeOption2["Everywhere"] = "everywhere";
  return ScopeOption2;
})(ScopeOption || {});
var contentValueSchema = z.object({
  text: z.string()
});
var tagValueSchema = z.object({
  tags: z.array(z.string())
});
var fileValueSchema = z.object({
  filepaths: z.array(z.string())
});
var savedFilterSchema = z.object({
  id: z.string(),
  content: contentValueSchema.optional(),
  tag: tagValueSchema.optional(),
  file: fileValueSchema.optional()
});
var settingsObject = z.object({
  columns: z.array(z.string()),
  scope: z.nativeEnum(ScopeOption).default("folder" /* Folder */),
  showFilepath: z.boolean().default(true).optional(),
  consolidateTags: z.boolean().default(false).optional(),
  uncategorizedVisibility: z.nativeEnum(VisibilityOption).default("auto" /* Auto */).optional(),
  doneVisibility: z.nativeEnum(VisibilityOption).default("always" /* AlwaysShow */).optional(),
  doneStatusMarkers: z.string().default(DEFAULT_DONE_STATUS_MARKERS).optional(),
  ignoredStatusMarkers: z.string().default(DEFAULT_IGNORED_STATUS_MARKERS).optional(),
  savedFilters: z.array(savedFilterSchema).default([]).optional(),
  lastContentFilter: z.string().optional(),
  lastTagFilter: z.array(z.string()).optional(),
  lastFileFilter: z.array(z.string()).optional(),
  filtersExpanded: z.boolean().default(true).optional(),
  filtersSidebarExpanded: z.boolean().default(true).optional(),
  filtersSidebarWidth: z.number().default(280).optional()
});
var defaultSettings = {
  columns: ["Later", "Soonish", "Next week", "This week", "Today", "Pending"],
  scope: "folder" /* Folder */,
  showFilepath: true,
  consolidateTags: false,
  uncategorizedVisibility: "auto" /* Auto */,
  doneVisibility: "always" /* AlwaysShow */,
  doneStatusMarkers: DEFAULT_DONE_STATUS_MARKERS,
  ignoredStatusMarkers: DEFAULT_IGNORED_STATUS_MARKERS,
  savedFilters: []
};
var createSettingsStore = () => writable(defaultSettings);
function parseSettingsString(str) {
  var _a;
  try {
    return (_a = settingsObject.safeParse(JSON.parse(str)).data) != null ? _a : defaultSettings;
  } catch (e) {
    return defaultSettings;
  }
}
function toSettingsString(settings) {
  return JSON.stringify(settings);
}

// src/ui/main.svelte
function add_css10(target) {
  append_styles(target, "svelte-9s8fa9", ".main.svelte-9s8fa9.svelte-9s8fa9.svelte-9s8fa9{height:100%;display:flex;flex-direction:column}.main.svelte-9s8fa9 .sidebar-toggle-btn.svelte-9s8fa9.svelte-9s8fa9{position:fixed;top:50px;left:8px;padding:var(--size-2-1) var(--size-2-2);background:var(--background-primary);border:1px solid var(--background-modifier-border);border-radius:var(--radius-s);cursor:pointer;color:var(--text-muted);font-size:var(--font-ui-small);display:flex;align-items:center;gap:var(--size-2-1);z-index:100;transition:color 0.15s ease}.main.svelte-9s8fa9 .sidebar-toggle-btn.svelte-9s8fa9.svelte-9s8fa9:hover{background:var(--background-modifier-hover);color:var(--text-normal)}.main.svelte-9s8fa9 .sidebar-toggle-btn .toggle-icon.svelte-9s8fa9.svelte-9s8fa9{font-size:16px}.main.svelte-9s8fa9 .sidebar-toggle-btn .toggle-label.svelte-9s8fa9.svelte-9s8fa9{font-weight:500}.main.svelte-9s8fa9 .board-container.svelte-9s8fa9.svelte-9s8fa9{display:grid;grid-template-columns:1fr;height:100%}.main.svelte-9s8fa9 .board-container.sidebar-expanded.svelte-9s8fa9.svelte-9s8fa9{grid-template-columns:var(--sidebar-width, 280px) 1fr}.main.svelte-9s8fa9 .filters-sidebar.svelte-9s8fa9.svelte-9s8fa9{background:var(--background-primary);border-right:1px solid var(--background-modifier-border);overflow-y:auto;display:flex;flex-direction:column;position:relative}.main.svelte-9s8fa9 .filters-sidebar .resize-handle.svelte-9s8fa9.svelte-9s8fa9{position:absolute;top:0;right:0;width:4px;height:100%;cursor:col-resize;background:transparent;border:none;padding:0;z-index:10}.main.svelte-9s8fa9 .filters-sidebar .resize-handle.svelte-9s8fa9.svelte-9s8fa9:hover{background:var(--interactive-accent);opacity:0.5}.main.svelte-9s8fa9 .board-content.svelte-9s8fa9.svelte-9s8fa9{display:flex;flex-direction:column;height:100%;overflow:hidden;padding-left:var(--size-4-4)}.main.svelte-9s8fa9 .settings.svelte-9s8fa9.svelte-9s8fa9{display:flex;justify-content:flex-end;padding:var(--size-4-2) var(--size-4-4) var(--size-4-2) 0}.main.svelte-9s8fa9 .controls.svelte-9s8fa9.svelte-9s8fa9{display:flex;flex-direction:column;gap:var(--size-4-5);padding:var(--size-4-4);padding-top:50px}.main.svelte-9s8fa9 .controls .saved-filters.svelte-9s8fa9.svelte-9s8fa9{margin-top:0;margin-bottom:var(--size-4-2);font-size:var(--font-ui-small);align-self:flex-start}.main.svelte-9s8fa9 .controls .saved-filters details summary.svelte-9s8fa9.svelte-9s8fa9{cursor:pointer;color:var(--text-muted);padding:var(--size-2-1) 0;user-select:none;transition:color 0.15s ease}.main.svelte-9s8fa9 .controls .saved-filters details summary.svelte-9s8fa9.svelte-9s8fa9:hover{color:var(--text-normal)}.main.svelte-9s8fa9 .controls .saved-filters details ul.svelte-9s8fa9.svelte-9s8fa9{margin:0;padding:0;list-style:none}.main.svelte-9s8fa9 .controls .saved-filters details ul li.svelte-9s8fa9.svelte-9s8fa9{margin:0;display:flex;align-items:center;gap:var(--size-4-2)}.main.svelte-9s8fa9 .controls .saved-filters details ul li button.svelte-9s8fa9.svelte-9s8fa9{text-align:left;padding:var(--size-2-1) var(--size-2-2);background:transparent;border:none;cursor:pointer;color:var(--text-normal);border-radius:var(--radius-s);white-space:nowrap;transition:background 0.15s ease, color 0.15s ease}.main.svelte-9s8fa9 .controls .saved-filters details ul li button.svelte-9s8fa9.svelte-9s8fa9:hover{background:var(--background-modifier-hover)}.main.svelte-9s8fa9 .controls .saved-filters details ul li button.active.svelte-9s8fa9.svelte-9s8fa9{font-weight:700;color:var(--interactive-accent)}.main.svelte-9s8fa9 .controls .saved-filters details ul li button.delete-btn.svelte-9s8fa9.svelte-9s8fa9{padding:0;width:20px;height:20px;display:flex;align-items:center;justify-content:center;font-size:18px;line-height:1;color:var(--text-muted)}.main.svelte-9s8fa9 .controls .saved-filters details ul li button.delete-btn.svelte-9s8fa9.svelte-9s8fa9:hover{color:var(--color-red);background:var(--background-modifier-error-hover)}.main.svelte-9s8fa9 .controls .text-filter.svelte-9s8fa9.svelte-9s8fa9{display:flex;flex-direction:column}.main.svelte-9s8fa9 .controls .text-filter label.svelte-9s8fa9.svelte-9s8fa9{display:inline-block;margin-bottom:var(--size-2-3);font-weight:600}.main.svelte-9s8fa9 .controls .text-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9{display:block;width:100%;background:var(--background-primary);padding:var(--size-4-2);box-sizing:border-box;transition:box-shadow 150ms ease}.main.svelte-9s8fa9 .controls .text-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9:focus-visible{box-shadow:0 0 0 2px var(--background-modifier-border-focus)}.main.svelte-9s8fa9 .controls .text-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9::-webkit-calendar-picker-indicator,.main.svelte-9s8fa9 .controls .text-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9::-webkit-list-button{display:none !important;opacity:0 !important;pointer-events:none !important}.main.svelte-9s8fa9 .controls .text-filter .filter-actions.svelte-9s8fa9.svelte-9s8fa9{display:flex;gap:var(--size-4-2);margin-top:var(--size-4-2)}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.svelte-9s8fa9.svelte-9s8fa9{padding:var(--size-2-2) var(--size-4-3);border-radius:var(--radius-s);cursor:pointer;font-size:var(--font-ui-small);transition:background 150ms ease, opacity 150ms ease}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.save-btn.svelte-9s8fa9.svelte-9s8fa9{background:var(--interactive-accent);color:var(--text-on-accent);border:none}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.save-btn.svelte-9s8fa9.svelte-9s8fa9:hover:not(:disabled){background:var(--interactive-accent-hover)}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.clear-btn.svelte-9s8fa9.svelte-9s8fa9{background:transparent;color:var(--text-muted);border:1px solid var(--background-modifier-border)}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.clear-btn.svelte-9s8fa9.svelte-9s8fa9:hover:not(:disabled){background:var(--background-modifier-hover)}.main.svelte-9s8fa9 .controls .text-filter .filter-action-btn.svelte-9s8fa9.svelte-9s8fa9:disabled{opacity:0.5;cursor:not-allowed}.main.svelte-9s8fa9 .controls .tag-filter.svelte-9s8fa9.svelte-9s8fa9{display:flex;flex-direction:column}.main.svelte-9s8fa9 .controls .file-filter.svelte-9s8fa9.svelte-9s8fa9{display:flex;flex-direction:column}.main.svelte-9s8fa9 .controls .file-filter label.svelte-9s8fa9.svelte-9s8fa9{display:inline-block;margin-bottom:var(--size-2-3);font-weight:600}.main.svelte-9s8fa9 .controls .file-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9{display:block;width:100%;background:var(--background-primary);padding:var(--size-4-2);box-sizing:border-box;transition:box-shadow 150ms ease}.main.svelte-9s8fa9 .controls .file-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9:focus-visible{box-shadow:0 0 0 2px var(--background-modifier-border-focus)}.main.svelte-9s8fa9 .controls .file-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9::-webkit-calendar-picker-indicator,.main.svelte-9s8fa9 .controls .file-filter .filter-input-container input[type=search].svelte-9s8fa9.svelte-9s8fa9::-webkit-list-button{display:none !important;opacity:0 !important;pointer-events:none !important}.main.svelte-9s8fa9 .controls .file-filter .filter-actions.svelte-9s8fa9.svelte-9s8fa9{display:flex;gap:var(--size-4-2);margin-top:var(--size-4-2)}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.svelte-9s8fa9.svelte-9s8fa9{padding:var(--size-2-2) var(--size-4-3);border-radius:var(--radius-s);cursor:pointer;font-size:var(--font-ui-small);transition:background 150ms ease, opacity 150ms ease}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.save-btn.svelte-9s8fa9.svelte-9s8fa9{background:var(--interactive-accent);color:var(--text-on-accent);border:none}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.save-btn.svelte-9s8fa9.svelte-9s8fa9:hover:not(:disabled){background:var(--interactive-accent-hover)}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.clear-btn.svelte-9s8fa9.svelte-9s8fa9{background:transparent;color:var(--text-muted);border:1px solid var(--background-modifier-border)}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.clear-btn.svelte-9s8fa9.svelte-9s8fa9:hover:not(:disabled){background:var(--background-modifier-hover)}.main.svelte-9s8fa9 .controls .file-filter .filter-action-btn.svelte-9s8fa9.svelte-9s8fa9:disabled{opacity:0.5;cursor:not-allowed}.main.svelte-9s8fa9 .columns.svelte-9s8fa9.svelte-9s8fa9{height:100%;flex-grow:1;max-width:100vw;overflow-x:scroll;padding-bottom:var(--size-4-3)}.main.svelte-9s8fa9 .columns.svelte-9s8fa9>div.svelte-9s8fa9{display:flex;gap:var(--size-4-3)}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[72] = list[i];
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[75] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[78] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[78] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[78] = list[i];
  return child_ctx;
}
function create_if_block_32(ctx) {
  let aside;
  let button0;
  let t0;
  let div9;
  let div3;
  let label0;
  let t2;
  let div0;
  let details0;
  let summary0;
  let t4;
  let ul0;
  let t5;
  let div1;
  let input0;
  let input0_aria_describedby_value;
  let t6;
  let t7;
  let div2;
  let button1;
  let t8;
  let button1_disabled_value;
  let t9;
  let button2;
  let t10;
  let button2_disabled_value;
  let t11;
  let div4;
  let selecttag;
  let updating_value;
  let t12;
  let div8;
  let label1;
  let t14;
  let div5;
  let details1;
  let summary1;
  let t16;
  let ul1;
  let t17;
  let div6;
  let input1;
  let t18;
  let t19;
  let div7;
  let button3;
  let t20;
  let button3_disabled_value;
  let t21;
  let button4;
  let t22;
  let button4_disabled_value;
  let current;
  let mounted;
  let dispose;
  let each_value_4 = ensure_array_like(
    /*contentFilters*/
    ctx[10]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks_1[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  let if_block0 = (
    /*contentFilters*/
    ctx[10].length > 0 && create_if_block_52(ctx)
  );
  function selecttag_value_binding(value) {
    ctx[64](value);
  }
  let selecttag_props = {
    tags: [.../*tags*/
    ctx[29]],
    savedFilters: (
      /*tagFilters*/
      ctx[27]
    ),
    onLoadFilter: (
      /*func*/
      ctx[62]
    ),
    addButtonDisabled: (
      /*selectedTags*/
      ctx[6].length === 0 || /*tagFilterExists*/
      ctx[24]
    ),
    onAddClick: (
      /*addTagFilter*/
      ctx[36]
    ),
    clearButtonDisabled: (
      /*selectedTags*/
      ctx[6].length === 0
    ),
    onClearClick: (
      /*clearTagFilter*/
      ctx[37]
    ),
    activeFilterId: (
      /*activeTagFilterId*/
      ctx[12]
    ),
    onDeleteClick: (
      /*func_1*/
      ctx[63]
    )
  };
  if (
    /*selectedTags*/
    ctx[6] !== void 0
  ) {
    selecttag_props.value = /*selectedTags*/
    ctx[6];
  }
  selecttag = new select_tag_default({ props: selecttag_props });
  binding_callbacks.push(() => bind(selecttag, "value", selecttag_value_binding));
  let each_value_2 = ensure_array_like(
    /*fileFilters*/
    ctx[26]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  let if_block1 = (
    /*availableFiles*/
    ctx[28].length > 0 && create_if_block_42(ctx)
  );
  return {
    c() {
      aside = element("aside");
      button0 = element("button");
      t0 = space();
      div9 = element("div");
      div3 = element("div");
      label0 = element("label");
      label0.textContent = "Filter by content:";
      t2 = space();
      div0 = element("div");
      details0 = element("details");
      summary0 = element("summary");
      summary0.textContent = "Saved filters";
      t4 = space();
      ul0 = element("ul");
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t5 = space();
      div1 = element("div");
      input0 = element("input");
      t6 = space();
      if (if_block0) if_block0.c();
      t7 = space();
      div2 = element("div");
      button1 = element("button");
      t8 = text("Save");
      t9 = space();
      button2 = element("button");
      t10 = text("Clear");
      t11 = space();
      div4 = element("div");
      create_component(selecttag.$$.fragment);
      t12 = space();
      div8 = element("div");
      label1 = element("label");
      label1.textContent = "Filter by file:";
      t14 = space();
      div5 = element("div");
      details1 = element("details");
      summary1 = element("summary");
      summary1.textContent = "Saved filters";
      t16 = space();
      ul1 = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t17 = space();
      div6 = element("div");
      input1 = element("input");
      t18 = space();
      if (if_block1) if_block1.c();
      t19 = space();
      div7 = element("div");
      button3 = element("button");
      t20 = text("Save");
      t21 = space();
      button4 = element("button");
      t22 = text("Clear");
      attr(button0, "class", "resize-handle svelte-9s8fa9");
      attr(button0, "aria-label", "Resize sidebar");
      attr(label0, "for", "filter");
      attr(label0, "class", "svelte-9s8fa9");
      attr(summary0, "class", "svelte-9s8fa9");
      attr(ul0, "role", "list");
      attr(ul0, "class", "svelte-9s8fa9");
      attr(div0, "class", "saved-filters svelte-9s8fa9");
      attr(input0, "id", "filter");
      attr(input0, "name", "filter");
      attr(input0, "type", "search");
      attr(input0, "placeholder", "Type to search...");
      attr(input0, "list", "content-filters");
      attr(input0, "aria-describedby", input0_aria_describedby_value = /*contentFilters*/
      ctx[10].length > 0 ? "content-filters" : void 0);
      attr(input0, "class", "svelte-9s8fa9");
      attr(div1, "class", "filter-input-container");
      attr(button1, "class", "filter-action-btn save-btn svelte-9s8fa9");
      button1.disabled = button1_disabled_value = /*filterText*/
      ctx[7].trim() === "" || /*contentFilterExists*/
      ctx[25];
      attr(button1, "aria-label", "Save filter");
      attr(button2, "class", "filter-action-btn clear-btn svelte-9s8fa9");
      button2.disabled = button2_disabled_value = /*filterText*/
      ctx[7].trim() === "";
      attr(button2, "aria-label", "Clear filter");
      attr(div2, "class", "filter-actions svelte-9s8fa9");
      attr(div3, "class", "text-filter svelte-9s8fa9");
      attr(div4, "class", "tag-filter svelte-9s8fa9");
      attr(label1, "for", "file-filter");
      attr(label1, "class", "svelte-9s8fa9");
      attr(summary1, "class", "svelte-9s8fa9");
      attr(ul1, "role", "list");
      attr(ul1, "class", "svelte-9s8fa9");
      attr(div5, "class", "saved-filters svelte-9s8fa9");
      attr(input1, "id", "file-filter");
      attr(input1, "name", "file-filter");
      attr(input1, "type", "search");
      attr(input1, "placeholder", "Type to search files...");
      attr(input1, "list", "file-paths");
      attr(input1, "aria-label", "Filter by file path");
      attr(input1, "class", "svelte-9s8fa9");
      attr(div6, "class", "filter-input-container");
      attr(button3, "class", "filter-action-btn save-btn svelte-9s8fa9");
      button3.disabled = button3_disabled_value = /*fileFilter*/
      ctx[8].trim() === "" || /*fileFilterExists*/
      ctx[23];
      attr(button3, "aria-label", "Save filter");
      attr(button4, "class", "filter-action-btn clear-btn svelte-9s8fa9");
      button4.disabled = button4_disabled_value = /*fileFilter*/
      ctx[8].trim() === "";
      attr(button4, "aria-label", "Clear file filter");
      attr(div7, "class", "filter-actions svelte-9s8fa9");
      attr(div8, "class", "file-filter svelte-9s8fa9");
      attr(div9, "class", "controls svelte-9s8fa9");
      attr(aside, "class", "filters-sidebar svelte-9s8fa9");
    },
    m(target, anchor) {
      insert(target, aside, anchor);
      append(aside, button0);
      append(aside, t0);
      append(aside, div9);
      append(div9, div3);
      append(div3, label0);
      append(div3, t2);
      append(div3, div0);
      append(div0, details0);
      append(details0, summary0);
      append(details0, t4);
      append(details0, ul0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(ul0, null);
        }
      }
      append(div3, t5);
      append(div3, div1);
      append(div1, input0);
      set_input_value(
        input0,
        /*filterText*/
        ctx[7]
      );
      append(div1, t6);
      if (if_block0) if_block0.m(div1, null);
      append(div3, t7);
      append(div3, div2);
      append(div2, button1);
      append(button1, t8);
      append(div2, t9);
      append(div2, button2);
      append(button2, t10);
      append(div9, t11);
      append(div9, div4);
      mount_component(selecttag, div4, null);
      append(div9, t12);
      append(div9, div8);
      append(div8, label1);
      append(div8, t14);
      append(div8, div5);
      append(div5, details1);
      append(details1, summary1);
      append(details1, t16);
      append(details1, ul1);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul1, null);
        }
      }
      append(div8, t17);
      append(div8, div6);
      append(div6, input1);
      set_input_value(
        input1,
        /*fileFilter*/
        ctx[8]
      );
      append(div6, t18);
      if (if_block1) if_block1.m(div6, null);
      append(div8, t19);
      append(div8, div7);
      append(div7, button3);
      append(button3, t20);
      append(div7, t21);
      append(div7, button4);
      append(button4, t22);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button0,
            "mousedown",
            /*startResize*/
            ctx[42]
          ),
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[61]
          ),
          listen(
            button1,
            "click",
            /*addContentFilter*/
            ctx[30]
          ),
          listen(
            button2,
            "click",
            /*clearContentFilter*/
            ctx[32]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[67]
          ),
          listen(
            button3,
            "click",
            /*addFileFilter*/
            ctx[34]
          ),
          listen(
            button4,
            "click",
            /*clearFileFilter*/
            ctx[33]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*contentFilters, activeContentFilterId*/
      3072 | dirty[1] & /*loadContentFilter, openDeleteModal*/
      129) {
        each_value_4 = ensure_array_like(
          /*contentFilters*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_4(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(ul0, null);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_4.length;
      }
      if (!current || dirty[0] & /*contentFilters*/
      1024 && input0_aria_describedby_value !== (input0_aria_describedby_value = /*contentFilters*/
      ctx2[10].length > 0 ? "content-filters" : void 0)) {
        attr(input0, "aria-describedby", input0_aria_describedby_value);
      }
      if (dirty[0] & /*filterText*/
      128 && input0.value !== /*filterText*/
      ctx2[7]) {
        set_input_value(
          input0,
          /*filterText*/
          ctx2[7]
        );
      }
      if (
        /*contentFilters*/
        ctx2[10].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_52(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (!current || dirty[0] & /*filterText, contentFilterExists*/
      33554560 && button1_disabled_value !== (button1_disabled_value = /*filterText*/
      ctx2[7].trim() === "" || /*contentFilterExists*/
      ctx2[25])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & /*filterText*/
      128 && button2_disabled_value !== (button2_disabled_value = /*filterText*/
      ctx2[7].trim() === "")) {
        button2.disabled = button2_disabled_value;
      }
      const selecttag_changes = {};
      if (dirty[0] & /*tags*/
      536870912) selecttag_changes.tags = [.../*tags*/
      ctx2[29]];
      if (dirty[0] & /*tagFilters*/
      134217728) selecttag_changes.savedFilters = /*tagFilters*/
      ctx2[27];
      if (dirty[0] & /*activeTagFilterId*/
      4096) selecttag_changes.onLoadFilter = /*func*/
      ctx2[62];
      if (dirty[0] & /*selectedTags, tagFilterExists*/
      16777280) selecttag_changes.addButtonDisabled = /*selectedTags*/
      ctx2[6].length === 0 || /*tagFilterExists*/
      ctx2[24];
      if (dirty[0] & /*selectedTags*/
      64) selecttag_changes.clearButtonDisabled = /*selectedTags*/
      ctx2[6].length === 0;
      if (dirty[0] & /*activeTagFilterId*/
      4096) selecttag_changes.activeFilterId = /*activeTagFilterId*/
      ctx2[12];
      if (!updating_value && dirty[0] & /*selectedTags*/
      64) {
        updating_value = true;
        selecttag_changes.value = /*selectedTags*/
        ctx2[6];
        add_flush_callback(() => updating_value = false);
      }
      selecttag.$set(selecttag_changes);
      if (dirty[0] & /*fileFilters, activeFileFilterId*/
      67117056 | dirty[1] & /*loadFileFilter, openDeleteModal*/
      144) {
        each_value_2 = ensure_array_like(
          /*fileFilters*/
          ctx2[26]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul1, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
      if (dirty[0] & /*fileFilter*/
      256 && input1.value !== /*fileFilter*/
      ctx2[8]) {
        set_input_value(
          input1,
          /*fileFilter*/
          ctx2[8]
        );
      }
      if (
        /*availableFiles*/
        ctx2[28].length > 0
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_42(ctx2);
          if_block1.c();
          if_block1.m(div6, null);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
      if (!current || dirty[0] & /*fileFilter, fileFilterExists*/
      8388864 && button3_disabled_value !== (button3_disabled_value = /*fileFilter*/
      ctx2[8].trim() === "" || /*fileFilterExists*/
      ctx2[23])) {
        button3.disabled = button3_disabled_value;
      }
      if (!current || dirty[0] & /*fileFilter*/
      256 && button4_disabled_value !== (button4_disabled_value = /*fileFilter*/
      ctx2[8].trim() === "")) {
        button4.disabled = button4_disabled_value;
      }
    },
    i(local) {
      if (current) return;
      transition_in(selecttag.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(selecttag.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(aside);
      }
      destroy_each(each_blocks_1, detaching);
      if (if_block0) if_block0.d();
      destroy_component(selecttag);
      destroy_each(each_blocks, detaching);
      if (if_block1) if_block1.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block_4(ctx) {
  var _a;
  let li;
  let button0;
  let t0;
  let button0_aria_label_value;
  let t1;
  let button1;
  let t2_value = (
    /*filter*/
    ((_a = ctx[78].content) == null ? void 0 : _a.text) + ""
  );
  let t2;
  let button1_aria_label_value;
  let button1_aria_pressed_value;
  let t3;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[59](
        /*filter*/
        ctx[78]
      )
    );
  }
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[60](
        /*filter*/
        ctx[78]
      )
    );
  }
  return {
    c() {
      var _a2, _b;
      li = element("li");
      button0 = element("button");
      t0 = text("\xD7");
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      attr(button0, "class", "delete-btn svelte-9s8fa9");
      attr(button0, "aria-label", button0_aria_label_value = "Delete filter: " + /*filter*/
      ((_a2 = ctx[78].content) == null ? void 0 : _a2.text));
      attr(button1, "aria-label", button1_aria_label_value = "Load saved filter: " + /*filter*/
      ((_b = ctx[78].content) == null ? void 0 : _b.text));
      attr(button1, "aria-pressed", button1_aria_pressed_value = /*filter*/
      ctx[78].id === /*activeContentFilterId*/
      ctx[11]);
      attr(button1, "class", "svelte-9s8fa9");
      toggle_class(
        button1,
        "active",
        /*filter*/
        ctx[78].id === /*activeContentFilterId*/
        ctx[11]
      );
      attr(li, "class", "svelte-9s8fa9");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, button0);
      append(button0, t0);
      append(li, t1);
      append(li, button1);
      append(button1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler),
          listen(button1, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b, _c;
      ctx = new_ctx;
      if (dirty[0] & /*contentFilters*/
      1024 && button0_aria_label_value !== (button0_aria_label_value = "Delete filter: " + /*filter*/
      ((_a2 = ctx[78].content) == null ? void 0 : _a2.text))) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if (dirty[0] & /*contentFilters*/
      1024 && t2_value !== (t2_value = /*filter*/
      ((_b = ctx[78].content) == null ? void 0 : _b.text) + "")) set_data(t2, t2_value);
      if (dirty[0] & /*contentFilters*/
      1024 && button1_aria_label_value !== (button1_aria_label_value = "Load saved filter: " + /*filter*/
      ((_c = ctx[78].content) == null ? void 0 : _c.text))) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
      if (dirty[0] & /*contentFilters, activeContentFilterId*/
      3072 && button1_aria_pressed_value !== (button1_aria_pressed_value = /*filter*/
      ctx[78].id === /*activeContentFilterId*/
      ctx[11])) {
        attr(button1, "aria-pressed", button1_aria_pressed_value);
      }
      if (dirty[0] & /*contentFilters, activeContentFilterId*/
      3072) {
        toggle_class(
          button1,
          "active",
          /*filter*/
          ctx[78].id === /*activeContentFilterId*/
          ctx[11]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_52(ctx) {
  let datalist;
  let each_value_3 = ensure_array_like(
    /*contentFilters*/
    ctx[10]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  return {
    c() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(datalist, "id", "content-filters");
    },
    m(target, anchor) {
      insert(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(datalist, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*contentFilters*/
      1024) {
        each_value_3 = ensure_array_like(
          /*contentFilters*/
          ctx2[10]
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(datalist);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  var _a;
  let option;
  let t_value = (
    /*filter*/
    ((_a = ctx[78].content) == null ? void 0 : _a.text) + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      var _a2;
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*filter*/
      (_a2 = ctx[78].content) == null ? void 0 : _a2.text;
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      var _a2, _b;
      if (dirty[0] & /*contentFilters*/
      1024 && t_value !== (t_value = /*filter*/
      ((_a2 = ctx2[78].content) == null ? void 0 : _a2.text) + "")) set_data(t, t_value);
      if (dirty[0] & /*contentFilters*/
      1024 && option_value_value !== (option_value_value = /*filter*/
      (_b = ctx2[78].content) == null ? void 0 : _b.text)) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_each_block_2(ctx) {
  var _a;
  let li;
  let button0;
  let t0;
  let button0_aria_label_value;
  let t1;
  let button1;
  let t2_value = (
    /*filter*/
    ((_a = ctx[78].file) == null ? void 0 : _a.filepaths[0]) + ""
  );
  let t2;
  let button1_aria_label_value;
  let button1_aria_pressed_value;
  let t3;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[65](
        /*filter*/
        ctx[78]
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[66](
        /*filter*/
        ctx[78]
      )
    );
  }
  return {
    c() {
      var _a2, _b;
      li = element("li");
      button0 = element("button");
      t0 = text("\xD7");
      t1 = space();
      button1 = element("button");
      t2 = text(t2_value);
      t3 = space();
      attr(button0, "class", "delete-btn svelte-9s8fa9");
      attr(button0, "aria-label", button0_aria_label_value = "Delete filter: " + /*filter*/
      ((_a2 = ctx[78].file) == null ? void 0 : _a2.filepaths[0]));
      attr(button1, "aria-label", button1_aria_label_value = "Load saved filter: " + /*filter*/
      ((_b = ctx[78].file) == null ? void 0 : _b.filepaths[0]));
      attr(button1, "aria-pressed", button1_aria_pressed_value = /*filter*/
      ctx[78].id === /*activeFileFilterId*/
      ctx[13]);
      attr(button1, "class", "svelte-9s8fa9");
      toggle_class(
        button1,
        "active",
        /*filter*/
        ctx[78].id === /*activeFileFilterId*/
        ctx[13]
      );
      attr(li, "class", "svelte-9s8fa9");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append(li, button0);
      append(button0, t0);
      append(li, t1);
      append(li, button1);
      append(button1, t2);
      append(li, t3);
      if (!mounted) {
        dispose = [
          listen(button0, "click", click_handler_2),
          listen(button1, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a2, _b, _c;
      ctx = new_ctx;
      if (dirty[0] & /*fileFilters*/
      67108864 && button0_aria_label_value !== (button0_aria_label_value = "Delete filter: " + /*filter*/
      ((_a2 = ctx[78].file) == null ? void 0 : _a2.filepaths[0]))) {
        attr(button0, "aria-label", button0_aria_label_value);
      }
      if (dirty[0] & /*fileFilters*/
      67108864 && t2_value !== (t2_value = /*filter*/
      ((_b = ctx[78].file) == null ? void 0 : _b.filepaths[0]) + "")) set_data(t2, t2_value);
      if (dirty[0] & /*fileFilters*/
      67108864 && button1_aria_label_value !== (button1_aria_label_value = "Load saved filter: " + /*filter*/
      ((_c = ctx[78].file) == null ? void 0 : _c.filepaths[0]))) {
        attr(button1, "aria-label", button1_aria_label_value);
      }
      if (dirty[0] & /*fileFilters, activeFileFilterId*/
      67117056 && button1_aria_pressed_value !== (button1_aria_pressed_value = /*filter*/
      ctx[78].id === /*activeFileFilterId*/
      ctx[13])) {
        attr(button1, "aria-pressed", button1_aria_pressed_value);
      }
      if (dirty[0] & /*fileFilters, activeFileFilterId*/
      67117056) {
        toggle_class(
          button1,
          "active",
          /*filter*/
          ctx[78].id === /*activeFileFilterId*/
          ctx[13]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_42(ctx) {
  let datalist;
  let each_value_1 = ensure_array_like(
    /*availableFiles*/
    ctx[28]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  return {
    c() {
      datalist = element("datalist");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(datalist, "id", "file-paths");
    },
    m(target, anchor) {
      insert(target, datalist, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(datalist, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*availableFiles*/
      268435456) {
        each_value_1 = ensure_array_like(
          /*availableFiles*/
          ctx2[28]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(datalist, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(datalist);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let option;
  let t_value = (
    /*filePath*/
    ctx[75] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*filePath*/
      ctx[75];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*availableFiles*/
      268435456 && t_value !== (t_value = /*filePath*/
      ctx2[75] + "")) set_data(t, t_value);
      if (dirty[0] & /*availableFiles*/
      268435456 && option_value_value !== (option_value_value = /*filePath*/
      ctx2[75])) {
        option.__value = option_value_value;
        set_input_value(option, option.__value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_24(ctx) {
  let column_1;
  let current;
  column_1 = new column_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      column: "uncategorised",
      hideOnEmpty: false,
      tasks: (
        /*tasksByColumn*/
        ctx[9]["uncategorised"]
      ),
      taskActions: (
        /*taskActions*/
        ctx[2]
      ),
      columnTagTableStore: (
        /*columnTagTableStore*/
        ctx[3]
      ),
      columnColourTableStore: (
        /*columnColourTableStore*/
        ctx[4]
      ),
      showFilepath: (
        /*showFilepath*/
        ctx[22]
      ),
      consolidateTags: (
        /*consolidateTags*/
        ctx[21]
      )
    }
  });
  return {
    c() {
      create_component(column_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const column_1_changes = {};
      if (dirty[0] & /*app*/
      1) column_1_changes.app = /*app*/
      ctx2[0];
      if (dirty[0] & /*tasksByColumn*/
      512) column_1_changes.tasks = /*tasksByColumn*/
      ctx2[9]["uncategorised"];
      if (dirty[0] & /*taskActions*/
      4) column_1_changes.taskActions = /*taskActions*/
      ctx2[2];
      if (dirty[0] & /*columnTagTableStore*/
      8) column_1_changes.columnTagTableStore = /*columnTagTableStore*/
      ctx2[3];
      if (dirty[0] & /*columnColourTableStore*/
      16) column_1_changes.columnColourTableStore = /*columnColourTableStore*/
      ctx2[4];
      if (dirty[0] & /*showFilepath*/
      4194304) column_1_changes.showFilepath = /*showFilepath*/
      ctx2[22];
      if (dirty[0] & /*consolidateTags*/
      2097152) column_1_changes.consolidateTags = /*consolidateTags*/
      ctx2[21];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(column_1, detaching);
    }
  };
}
function create_each_block5(ctx) {
  var _a;
  let column_1;
  let current;
  column_1 = new column_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      column: (
        /*column*/
        ctx[72]
      ),
      tasks: (
        /*tasksByColumn*/
        (_a = ctx[9][
          /*column*/
          ctx[72]
        ]) != null ? _a : []
      ),
      taskActions: (
        /*taskActions*/
        ctx[2]
      ),
      columnTagTableStore: (
        /*columnTagTableStore*/
        ctx[3]
      ),
      columnColourTableStore: (
        /*columnColourTableStore*/
        ctx[4]
      ),
      showFilepath: (
        /*showFilepath*/
        ctx[22]
      ),
      consolidateTags: (
        /*consolidateTags*/
        ctx[21]
      )
    }
  });
  return {
    c() {
      create_component(column_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const column_1_changes = {};
      if (dirty[0] & /*app*/
      1) column_1_changes.app = /*app*/
      ctx2[0];
      if (dirty[0] & /*columns*/
      65536) column_1_changes.column = /*column*/
      ctx2[72];
      if (dirty[0] & /*tasksByColumn, columns*/
      66048) column_1_changes.tasks = /*tasksByColumn*/
      (_a2 = ctx2[9][
        /*column*/
        ctx2[72]
      ]) != null ? _a2 : [];
      if (dirty[0] & /*taskActions*/
      4) column_1_changes.taskActions = /*taskActions*/
      ctx2[2];
      if (dirty[0] & /*columnTagTableStore*/
      8) column_1_changes.columnTagTableStore = /*columnTagTableStore*/
      ctx2[3];
      if (dirty[0] & /*columnColourTableStore*/
      16) column_1_changes.columnColourTableStore = /*columnColourTableStore*/
      ctx2[4];
      if (dirty[0] & /*showFilepath*/
      4194304) column_1_changes.showFilepath = /*showFilepath*/
      ctx2[22];
      if (dirty[0] & /*consolidateTags*/
      2097152) column_1_changes.consolidateTags = /*consolidateTags*/
      ctx2[21];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(column_1, detaching);
    }
  };
}
function create_if_block_15(ctx) {
  var _a;
  let column_1;
  let current;
  column_1 = new column_default({
    props: {
      app: (
        /*app*/
        ctx[0]
      ),
      column: "done",
      hideOnEmpty: false,
      tasks: (
        /*tasksByColumn*/
        (_a = ctx[9]["done"]) != null ? _a : []
      ),
      taskActions: (
        /*taskActions*/
        ctx[2]
      ),
      columnTagTableStore: (
        /*columnTagTableStore*/
        ctx[3]
      ),
      columnColourTableStore: (
        /*columnColourTableStore*/
        ctx[4]
      ),
      showFilepath: (
        /*showFilepath*/
        ctx[22]
      ),
      consolidateTags: (
        /*consolidateTags*/
        ctx[21]
      )
    }
  });
  return {
    c() {
      create_component(column_1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(column_1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      var _a2;
      const column_1_changes = {};
      if (dirty[0] & /*app*/
      1) column_1_changes.app = /*app*/
      ctx2[0];
      if (dirty[0] & /*tasksByColumn*/
      512) column_1_changes.tasks = /*tasksByColumn*/
      (_a2 = ctx2[9]["done"]) != null ? _a2 : [];
      if (dirty[0] & /*taskActions*/
      4) column_1_changes.taskActions = /*taskActions*/
      ctx2[2];
      if (dirty[0] & /*columnTagTableStore*/
      8) column_1_changes.columnTagTableStore = /*columnTagTableStore*/
      ctx2[3];
      if (dirty[0] & /*columnColourTableStore*/
      16) column_1_changes.columnColourTableStore = /*columnColourTableStore*/
      ctx2[4];
      if (dirty[0] & /*showFilepath*/
      4194304) column_1_changes.showFilepath = /*showFilepath*/
      ctx2[22];
      if (dirty[0] & /*consolidateTags*/
      2097152) column_1_changes.consolidateTags = /*consolidateTags*/
      ctx2[21];
      column_1.$set(column_1_changes);
    },
    i(local) {
      if (current) return;
      transition_in(column_1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(column_1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(column_1, detaching);
    }
  };
}
function create_if_block5(ctx) {
  let deletefiltermodal;
  let current;
  deletefiltermodal = new delete_filter_modal_default({
    props: {
      filterText: (
        /*filterToDelete*/
        ctx[15].text
      ),
      onConfirm: (
        /*confirmDelete*/
        ctx[40]
      ),
      onCancel: (
        /*closeDeleteModal*/
        ctx[39]
      )
    }
  });
  return {
    c() {
      create_component(deletefiltermodal.$$.fragment);
    },
    m(target, anchor) {
      mount_component(deletefiltermodal, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const deletefiltermodal_changes = {};
      if (dirty[0] & /*filterToDelete*/
      32768) deletefiltermodal_changes.filterText = /*filterToDelete*/
      ctx2[15].text;
      deletefiltermodal.$set(deletefiltermodal_changes);
    },
    i(local) {
      if (current) return;
      transition_in(deletefiltermodal.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(deletefiltermodal.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(deletefiltermodal, detaching);
    }
  };
}
function create_fragment12(ctx) {
  let div5;
  let button;
  let span0;
  let t0_value = (
    /*filtersSidebarExpanded*/
    ctx[18] ? "\u25C2" : "\u25B8"
  );
  let t0;
  let t1;
  let span1;
  let button_aria_label_value;
  let t3;
  let div4;
  let t4;
  let div3;
  let div0;
  let iconbutton;
  let t5;
  let div2;
  let div1;
  let t6;
  let t7;
  let t8;
  let if_block3_anchor;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*filtersSidebarExpanded*/
    ctx[18] && create_if_block_32(ctx)
  );
  iconbutton = new icon_button_default({ props: { icon: "lucide-settings" } });
  iconbutton.$on(
    "click",
    /*handleOpenSettings*/
    ctx[45]
  );
  let if_block1 = (
    /*showUncategorizedColumn*/
    ctx[20] && create_if_block_24(ctx)
  );
  let each_value = ensure_array_like(
    /*columns*/
    ctx[16]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block2 = (
    /*showDoneColumn*/
    ctx[19] && create_if_block_15(ctx)
  );
  let if_block3 = (
    /*deleteModalOpen*/
    ctx[14] && /*filterToDelete*/
    ctx[15] && create_if_block5(ctx)
  );
  return {
    c() {
      div5 = element("div");
      button = element("button");
      span0 = element("span");
      t0 = text(t0_value);
      t1 = space();
      span1 = element("span");
      span1.textContent = "Filters";
      t3 = space();
      div4 = element("div");
      if (if_block0) if_block0.c();
      t4 = space();
      div3 = element("div");
      div0 = element("div");
      create_component(iconbutton.$$.fragment);
      t5 = space();
      div2 = element("div");
      div1 = element("div");
      if (if_block1) if_block1.c();
      t6 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t7 = space();
      if (if_block2) if_block2.c();
      t8 = space();
      if (if_block3) if_block3.c();
      if_block3_anchor = empty();
      attr(span0, "class", "toggle-icon svelte-9s8fa9");
      attr(span1, "class", "toggle-label svelte-9s8fa9");
      attr(button, "class", "sidebar-toggle-btn svelte-9s8fa9");
      attr(button, "aria-label", button_aria_label_value = /*filtersSidebarExpanded*/
      ctx[18] ? "Hide filters" : "Show filters");
      attr(div0, "class", "settings svelte-9s8fa9");
      attr(div1, "class", "svelte-9s8fa9");
      attr(div2, "class", "columns svelte-9s8fa9");
      attr(div3, "class", "board-content svelte-9s8fa9");
      attr(div4, "class", "board-container svelte-9s8fa9");
      set_style(
        div4,
        "--sidebar-width",
        /*filtersSidebarWidth*/
        ctx[17] + "px"
      );
      toggle_class(
        div4,
        "sidebar-expanded",
        /*filtersSidebarExpanded*/
        ctx[18]
      );
      attr(div5, "class", "main svelte-9s8fa9");
    },
    m(target, anchor) {
      insert(target, div5, anchor);
      append(div5, button);
      append(button, span0);
      append(span0, t0);
      append(button, t1);
      append(button, span1);
      append(div5, t3);
      append(div5, div4);
      if (if_block0) if_block0.m(div4, null);
      append(div4, t4);
      append(div4, div3);
      append(div3, div0);
      mount_component(iconbutton, div0, null);
      append(div3, t5);
      append(div3, div2);
      append(div2, div1);
      if (if_block1) if_block1.m(div1, null);
      append(div1, t6);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div1, null);
        }
      }
      append(div1, t7);
      if (if_block2) if_block2.m(div1, null);
      insert(target, t8, anchor);
      if (if_block3) if_block3.m(target, anchor);
      insert(target, if_block3_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            window,
            "mousemove",
            /*handleMouseMove*/
            ctx[43]
          ),
          listen(
            window,
            "mouseup",
            /*stopResize*/
            ctx[44]
          ),
          listen(
            button,
            "click",
            /*toggleSidebar*/
            ctx[41]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*filtersSidebarExpanded*/
      262144) && t0_value !== (t0_value = /*filtersSidebarExpanded*/
      ctx2[18] ? "\u25C2" : "\u25B8")) set_data(t0, t0_value);
      if (!current || dirty[0] & /*filtersSidebarExpanded*/
      262144 && button_aria_label_value !== (button_aria_label_value = /*filtersSidebarExpanded*/
      ctx2[18] ? "Hide filters" : "Show filters")) {
        attr(button, "aria-label", button_aria_label_value);
      }
      if (
        /*filtersSidebarExpanded*/
        ctx2[18]
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
          if (dirty[0] & /*filtersSidebarExpanded*/
          262144) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_32(ctx2);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div4, t4);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (
        /*showUncategorizedColumn*/
        ctx2[20]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*showUncategorizedColumn*/
          1048576) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block_24(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div1, t6);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
      if (dirty[0] & /*app, columns, tasksByColumn, taskActions, columnTagTableStore, columnColourTableStore, showFilepath, consolidateTags*/
      6357533) {
        each_value = ensure_array_like(
          /*columns*/
          ctx2[16]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div1, t7);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*showDoneColumn*/
        ctx2[19]
      ) {
        if (if_block2) {
          if_block2.p(ctx2, dirty);
          if (dirty[0] & /*showDoneColumn*/
          524288) {
            transition_in(if_block2, 1);
          }
        } else {
          if_block2 = create_if_block_15(ctx2);
          if_block2.c();
          transition_in(if_block2, 1);
          if_block2.m(div1, null);
        }
      } else if (if_block2) {
        group_outros();
        transition_out(if_block2, 1, 1, () => {
          if_block2 = null;
        });
        check_outros();
      }
      if (!current || dirty[0] & /*filtersSidebarWidth*/
      131072) {
        set_style(
          div4,
          "--sidebar-width",
          /*filtersSidebarWidth*/
          ctx2[17] + "px"
        );
      }
      if (!current || dirty[0] & /*filtersSidebarExpanded*/
      262144) {
        toggle_class(
          div4,
          "sidebar-expanded",
          /*filtersSidebarExpanded*/
          ctx2[18]
        );
      }
      if (
        /*deleteModalOpen*/
        ctx2[14] && /*filterToDelete*/
        ctx2[15]
      ) {
        if (if_block3) {
          if_block3.p(ctx2, dirty);
          if (dirty[0] & /*deleteModalOpen, filterToDelete*/
          49152) {
            transition_in(if_block3, 1);
          }
        } else {
          if_block3 = create_if_block5(ctx2);
          if_block3.c();
          transition_in(if_block3, 1);
          if_block3.m(if_block3_anchor.parentNode, if_block3_anchor);
        }
      } else if (if_block3) {
        group_outros();
        transition_out(if_block3, 1, 1, () => {
          if_block3 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current) return;
      transition_in(if_block0);
      transition_in(iconbutton.$$.fragment, local);
      transition_in(if_block1);
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block2);
      transition_in(if_block3);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(iconbutton.$$.fragment, local);
      transition_out(if_block1);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block2);
      transition_out(if_block3);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div5);
        detach(t8);
        detach(if_block3_anchor);
      }
      if (if_block0) if_block0.d();
      destroy_component(iconbutton);
      if (if_block1) if_block1.d();
      destroy_each(each_blocks, detaching);
      if (if_block2) if_block2.d();
      if (if_block3) if_block3.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
var MIN_SIDEBAR_WIDTH = 200;
var MAX_SIDEBAR_WIDTH = 600;
function groupByColumnTag(tasks) {
  var _a;
  const output = { uncategorised: [], done: [] };
  for (const task of tasks) {
    if (task.done || task.column === "done") {
      output["done"] = output["done"].concat(task);
    } else if (task.column === "archived") {
    } else if (task.column) {
      output[task.column] = ((_a = output[task.column]) != null ? _a : []).concat(
        task
      );
    } else {
      output["uncategorised"] = output["uncategorised"].concat(task);
    }
  }
  return output;
}
function instance9($$self, $$props, $$invalidate) {
  let tags;
  let availableFiles;
  let selectedTagsSet;
  let savedFilters;
  let contentFilters;
  let tagFilters;
  let fileFilters;
  let contentFilterExists;
  let tagFilterExists;
  let fileFilterExists;
  let filteredByText;
  let filteredByTag;
  let filteredByFile;
  let tasksByColumn;
  let showFilepath;
  let consolidateTags;
  let uncategorizedVisibility;
  let doneVisibility;
  let filtersSidebarExpanded;
  let filtersSidebarWidth;
  let showUncategorizedColumn;
  let showDoneColumn;
  let $settingsStore, $$unsubscribe_settingsStore = noop, $$subscribe_settingsStore = () => ($$unsubscribe_settingsStore(), $$unsubscribe_settingsStore = subscribe(settingsStore, ($$value) => $$invalidate(56, $settingsStore = $$value)), settingsStore);
  let $tasksStore, $$unsubscribe_tasksStore = noop, $$subscribe_tasksStore = () => ($$unsubscribe_tasksStore(), $$unsubscribe_tasksStore = subscribe(tasksStore, ($$value) => $$invalidate(57, $tasksStore = $$value)), tasksStore);
  let $columnTagTableStore, $$unsubscribe_columnTagTableStore = noop, $$subscribe_columnTagTableStore = () => ($$unsubscribe_columnTagTableStore(), $$unsubscribe_columnTagTableStore = subscribe(columnTagTableStore, ($$value) => $$invalidate(58, $columnTagTableStore = $$value)), columnTagTableStore);
  $$self.$$.on_destroy.push(() => $$unsubscribe_settingsStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_tasksStore());
  $$self.$$.on_destroy.push(() => $$unsubscribe_columnTagTableStore());
  let { app } = $$props;
  let { tasksStore } = $$props;
  $$subscribe_tasksStore();
  let { taskActions } = $$props;
  let { openSettings } = $$props;
  let { columnTagTableStore } = $$props;
  $$subscribe_columnTagTableStore();
  let { columnColourTableStore } = $$props;
  let { settingsStore } = $$props;
  $$subscribe_settingsStore();
  let { requestSave } = $$props;
  let selectedTags = [];
  let activeContentFilterId = void 0;
  let activeTagFilterId = void 0;
  let activeFileFilterId = void 0;
  let deleteModalOpen = false;
  let filterToDelete = null;
  function addContentFilter() {
    const normalized = filterText.trim();
    const existingFilterIndex = savedFilters.findIndex((f) => {
      var _a;
      return ((_a = f.content) == null ? void 0 : _a.text) === normalized;
    });
    if (existingFilterIndex >= 0) {
      return;
    }
    const newFilter = {
      id: crypto.randomUUID(),
      content: { text: normalized }
    };
    set_store_value(settingsStore, $settingsStore.savedFilters = [...savedFilters, newFilter], $settingsStore);
    requestSave();
  }
  function loadContentFilter(filterId, text2) {
    if (activeContentFilterId === filterId) {
      clearContentFilter();
    } else {
      $$invalidate(7, filterText = text2);
      $$invalidate(11, activeContentFilterId = filterId);
    }
  }
  function clearContentFilter() {
    $$invalidate(7, filterText = "");
    $$invalidate(11, activeContentFilterId = void 0);
  }
  function clearFileFilter() {
    $$invalidate(8, fileFilter = "");
    $$invalidate(13, activeFileFilterId = void 0);
  }
  function addFileFilter() {
    const normalized = fileFilter.trim();
    if (!normalized) return;
    const existingFilterIndex = savedFilters.findIndex((f) => {
      var _a;
      return ((_a = f.file) == null ? void 0 : _a.filepaths[0]) === normalized;
    });
    if (existingFilterIndex >= 0) {
      return;
    }
    const newFilter = {
      id: crypto.randomUUID(),
      file: { filepaths: [normalized] }
    };
    set_store_value(settingsStore, $settingsStore.savedFilters = [...savedFilters, newFilter], $settingsStore);
    requestSave();
  }
  function loadFileFilter(filterId, filepath) {
    if (activeFileFilterId === filterId) {
      clearFileFilter();
    } else {
      $$invalidate(8, fileFilter = filepath);
      $$invalidate(13, activeFileFilterId = filterId);
    }
  }
  function addTagFilter() {
    if (selectedTags.length === 0) {
      return;
    }
    const sortedTags = [...selectedTags].sort();
    const existingFilterIndex = savedFilters.findIndex((f) => {
      var _a, _b;
      const filterTags = (_b = (_a = f.tag) == null ? void 0 : _a.tags) != null ? _b : [];
      if (filterTags.length !== sortedTags.length) return false;
      const sortedFilterTags = [...filterTags].sort();
      return sortedFilterTags.every((tag, i) => tag === sortedTags[i]);
    });
    if (existingFilterIndex >= 0) {
      return;
    }
    const newFilter = {
      id: crypto.randomUUID(),
      tag: { tags: sortedTags }
    };
    set_store_value(settingsStore, $settingsStore.savedFilters = [...savedFilters, newFilter], $settingsStore);
    requestSave();
  }
  function clearTagFilter() {
    $$invalidate(6, selectedTags = []);
    $$invalidate(12, activeTagFilterId = void 0);
  }
  function openDeleteModal(filterId, filterText2, type) {
    $$invalidate(15, filterToDelete = { id: filterId, text: filterText2, type });
    $$invalidate(14, deleteModalOpen = true);
  }
  function closeDeleteModal() {
    $$invalidate(14, deleteModalOpen = false);
    $$invalidate(15, filterToDelete = null);
  }
  function confirmDelete() {
    if (!filterToDelete) return;
    const filterId = filterToDelete.id;
    const filterType = filterToDelete.type;
    const wasActive = filterType === "content" ? activeContentFilterId === filterId : filterType === "tag" ? activeTagFilterId === filterId : activeFileFilterId === filterId;
    set_store_value(settingsStore, $settingsStore.savedFilters = savedFilters.filter((f) => f.id !== filterId), $settingsStore);
    if (wasActive) {
      if (filterType === "content") {
        $$invalidate(11, activeContentFilterId = void 0);
      } else if (filterType === "tag") {
        $$invalidate(12, activeTagFilterId = void 0);
      } else {
        $$invalidate(13, activeFileFilterId = void 0);
      }
    }
    requestSave();
    closeDeleteModal();
  }
  let columns;
  let filterText = "";
  let fileFilter = "";
  let hasInitialized = false;
  onMount(() => {
    const unsubscribe = settingsStore.subscribe((settings) => {
      var _a, _b, _c, _d;
      if (!hasInitialized && (settings.lastContentFilter || settings.lastTagFilter || settings.lastFileFilter)) {
        $$invalidate(7, filterText = (_a = settings.lastContentFilter) != null ? _a : "");
        $$invalidate(6, selectedTags = (_b = settings.lastTagFilter) != null ? _b : []);
        $$invalidate(8, fileFilter = (_d = (_c = settings.lastFileFilter) == null ? void 0 : _c[0]) != null ? _d : "");
        $$invalidate(48, hasInitialized = true);
      }
    });
    return unsubscribe;
  });
  function saveFilterState() {
    if (hasInitialized) {
      settingsStore.update((settings) => ({
        ...settings,
        lastContentFilter: filterText,
        lastTagFilter: selectedTags,
        lastFileFilter: fileFilter ? [fileFilter] : []
      }));
      requestSave();
    }
  }
  function toggleSidebar() {
    set_store_value(settingsStore, $settingsStore.filtersSidebarExpanded = !filtersSidebarExpanded, $settingsStore);
    requestSave();
  }
  let isResizing = false;
  let resizeStartX = 0;
  let resizeStartWidth = 0;
  function startResize(e) {
    e.preventDefault();
    isResizing = true;
    resizeStartX = e.clientX;
    resizeStartWidth = filtersSidebarWidth;
  }
  function handleMouseMove(e) {
    if (!isResizing) return;
    const delta = e.clientX - resizeStartX;
    const newWidth = Math.min(MAX_SIDEBAR_WIDTH, Math.max(MIN_SIDEBAR_WIDTH, resizeStartWidth + delta));
    set_store_value(settingsStore, $settingsStore.filtersSidebarWidth = newWidth, $settingsStore);
  }
  function stopResize() {
    if (isResizing) {
      isResizing = false;
      requestSave();
    }
  }
  async function handleOpenSettings() {
    openSettings();
  }
  const click_handler = (filter2) => {
    var _a, _b;
    return openDeleteModal(filter2.id, (_b = (_a = filter2.content) == null ? void 0 : _a.text) != null ? _b : "", "content");
  };
  const click_handler_1 = (filter2) => {
    var _a, _b;
    return loadContentFilter(filter2.id, (_b = (_a = filter2.content) == null ? void 0 : _a.text) != null ? _b : "");
  };
  function input0_input_handler() {
    filterText = this.value;
    $$invalidate(7, filterText);
  }
  const func2 = (filterId) => {
    if (activeTagFilterId === filterId) {
      clearTagFilter();
    } else {
      $$invalidate(12, activeTagFilterId = filterId);
    }
  };
  const func_1 = (filterId, filterText2) => openDeleteModal(filterId, filterText2, "tag");
  function selecttag_value_binding(value) {
    selectedTags = value;
    $$invalidate(6, selectedTags);
  }
  const click_handler_2 = (filter2) => {
    var _a, _b;
    return openDeleteModal(filter2.id, (_b = (_a = filter2.file) == null ? void 0 : _a.filepaths[0]) != null ? _b : "", "file");
  };
  const click_handler_3 = (filter2) => {
    var _a, _b;
    return loadFileFilter(filter2.id, (_b = (_a = filter2.file) == null ? void 0 : _a.filepaths[0]) != null ? _b : "");
  };
  function input1_input_handler() {
    fileFilter = this.value;
    $$invalidate(8, fileFilter);
  }
  $$self.$$set = ($$props2) => {
    if ("app" in $$props2) $$invalidate(0, app = $$props2.app);
    if ("tasksStore" in $$props2) $$subscribe_tasksStore($$invalidate(1, tasksStore = $$props2.tasksStore));
    if ("taskActions" in $$props2) $$invalidate(2, taskActions = $$props2.taskActions);
    if ("openSettings" in $$props2) $$invalidate(46, openSettings = $$props2.openSettings);
    if ("columnTagTableStore" in $$props2) $$subscribe_columnTagTableStore($$invalidate(3, columnTagTableStore = $$props2.columnTagTableStore));
    if ("columnColourTableStore" in $$props2) $$invalidate(4, columnColourTableStore = $$props2.columnColourTableStore);
    if ("settingsStore" in $$props2) $$subscribe_settingsStore($$invalidate(5, settingsStore = $$props2.settingsStore));
    if ("requestSave" in $$props2) $$invalidate(47, requestSave = $$props2.requestSave);
  };
  $$self.$$.update = () => {
    var _a, _b, _c;
    if ($$self.$$.dirty[1] & /*$tasksStore*/
    67108864) {
      $: $$invalidate(29, tags = $tasksStore.reduce(
        (acc, curr) => {
          for (const tag of curr.tags) {
            acc.add(tag);
          }
          return acc;
        },
        /* @__PURE__ */ new Set()
      ));
    }
    if ($$self.$$.dirty[1] & /*$tasksStore*/
    67108864) {
      $: $$invalidate(28, availableFiles = [...new Set($tasksStore.map((task) => task.path))].sort((a, b) => {
        const aParts = a.split("/");
        const bParts = b.split("/");
        const minLength = Math.min(aParts.length, bParts.length);
        for (let i = 0; i < minLength; i++) {
          const aIsLast = i === aParts.length - 1;
          const bIsLast = i === bParts.length - 1;
          if (aIsLast && !bIsLast) return -1;
          if (bIsLast && !aIsLast) return 1;
          const aPart = aParts[i];
          const bPart = bParts[i];
          if (aPart === void 0 || bPart === void 0) continue;
          const comparison = aPart.localeCompare(bPart);
          if (comparison !== 0) return comparison;
        }
        return aParts.length - bParts.length;
      }));
    }
    if ($$self.$$.dirty[0] & /*selectedTags*/
    64) {
      $: $$invalidate(54, selectedTagsSet = new Set(selectedTags));
    }
    if ($$self.$$.dirty[1] & /*$settingsStore*/
    33554432) {
      $: $$invalidate(55, savedFilters = (_a = $settingsStore.savedFilters) != null ? _a : []);
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    128 | $$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: {
        const trimmedText = filterText.trim();
        if (trimmedText) {
          const matchingFilter = savedFilters.find((f) => {
            var _a2;
            return ((_a2 = f.content) == null ? void 0 : _a2.text) === trimmedText;
          });
          if (matchingFilter) {
            $$invalidate(11, activeContentFilterId = matchingFilter.id);
          } else {
            $$invalidate(11, activeContentFilterId = void 0);
          }
        } else {
          $$invalidate(11, activeContentFilterId = void 0);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*selectedTags*/
    64 | $$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: {
        if (selectedTags.length > 0) {
          const sortedCurrent = [...selectedTags].sort();
          const matchingFilter = savedFilters.find((f) => {
            if (!f.tag) return false;
            const sortedSaved = [...f.tag.tags].sort();
            return sortedCurrent.length === sortedSaved.length && sortedCurrent.every((tag, i) => tag === sortedSaved[i]);
          });
          if (matchingFilter) {
            $$invalidate(12, activeTagFilterId = matchingFilter.id);
          } else {
            $$invalidate(12, activeTagFilterId = void 0);
          }
        } else {
          $$invalidate(12, activeTagFilterId = void 0);
        }
      }
    }
    if ($$self.$$.dirty[0] & /*fileFilter*/
    256 | $$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: {
        const trimmedPath = fileFilter.trim();
        if (trimmedPath) {
          const matchingFilter = savedFilters.find((f) => {
            var _a2;
            return ((_a2 = f.file) == null ? void 0 : _a2.filepaths[0]) === trimmedPath;
          });
          if (matchingFilter) {
            $$invalidate(13, activeFileFilterId = matchingFilter.id);
          } else {
            $$invalidate(13, activeFileFilterId = void 0);
          }
        } else {
          $$invalidate(13, activeFileFilterId = void 0);
        }
      }
    }
    if ($$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: $$invalidate(10, contentFilters = savedFilters.filter((f) => f.content !== void 0).sort((a, b) => {
        var _a2, _b2, _c2, _d;
        const textA = (_b2 = (_a2 = a.content) == null ? void 0 : _a2.text.toLowerCase()) != null ? _b2 : "";
        const textB = (_d = (_c2 = b.content) == null ? void 0 : _c2.text.toLowerCase()) != null ? _d : "";
        return textA.localeCompare(textB);
      }));
    }
    if ($$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: $$invalidate(27, tagFilters = savedFilters.filter((f) => f.tag !== void 0).sort((a, b) => {
        var _a2, _b2, _c2, _d;
        const tagsA = ((_b2 = (_a2 = a.tag) == null ? void 0 : _a2.tags) != null ? _b2 : []).join(", ").toLowerCase();
        const tagsB = ((_d = (_c2 = b.tag) == null ? void 0 : _c2.tags) != null ? _d : []).join(", ").toLowerCase();
        return tagsA.localeCompare(tagsB);
      }));
    }
    if ($$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: $$invalidate(26, fileFilters = savedFilters.filter((f) => f.file !== void 0).sort((a, b) => {
        var _a2, _b2, _c2, _d;
        const pathA = (_b2 = (_a2 = a.file) == null ? void 0 : _a2.filepaths[0]) != null ? _b2 : "";
        const pathB = (_d = (_c2 = b.file) == null ? void 0 : _c2.filepaths[0]) != null ? _d : "";
        return pathA.localeCompare(pathB);
      }));
    }
    if ($$self.$$.dirty[0] & /*contentFilters, filterText*/
    1152) {
      $: $$invalidate(25, contentFilterExists = contentFilters.some((f) => {
        var _a2;
        return ((_a2 = f.content) == null ? void 0 : _a2.text) === filterText.trim();
      }));
    }
    if ($$self.$$.dirty[0] & /*selectedTags*/
    64 | $$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: $$invalidate(24, tagFilterExists = (() => {
        if (selectedTags.length === 0) return false;
        const sortedTags = [...selectedTags].sort();
        return savedFilters.some((f) => {
          var _a2, _b2;
          const filterTags = (_b2 = (_a2 = f.tag) == null ? void 0 : _a2.tags) != null ? _b2 : [];
          if (filterTags.length !== sortedTags.length) return false;
          const sortedFilterTags = [...filterTags].sort();
          return sortedFilterTags.every((tag, i) => tag === sortedTags[i]);
        });
      })());
    }
    if ($$self.$$.dirty[0] & /*fileFilter*/
    256 | $$self.$$.dirty[1] & /*savedFilters*/
    16777216) {
      $: $$invalidate(23, fileFilterExists = savedFilters.some((f) => {
        var _a2;
        return ((_a2 = f.file) == null ? void 0 : _a2.filepaths[0]) === fileFilter.trim();
      }));
    }
    if ($$self.$$.dirty[1] & /*$columnTagTableStore*/
    134217728) {
      $: $$invalidate(16, columns = Object.keys($columnTagTableStore));
    }
    if ($$self.$$.dirty[0] & /*filterText, selectedTags, fileFilter*/
    448 | $$self.$$.dirty[1] & /*hasInitialized*/
    131072) {
      $: if (hasInitialized) {
        filterText;
        selectedTags;
        fileFilter;
        saveFilterState();
      }
    }
    if ($$self.$$.dirty[0] & /*filterText*/
    128 | $$self.$$.dirty[1] & /*$tasksStore*/
    67108864) {
      $: $$invalidate(53, filteredByText = filterText ? $tasksStore.filter((task) => task.content.toLowerCase().includes(filterText.toLowerCase())) : $tasksStore);
    }
    if ($$self.$$.dirty[1] & /*selectedTagsSet, filteredByText*/
    12582912) {
      $: $$invalidate(52, filteredByTag = selectedTagsSet.size ? filteredByText.filter((task) => {
        for (const tag of task.tags) {
          if (selectedTagsSet.has(tag)) {
            return true;
          }
        }
        return false;
      }) : filteredByText);
    }
    if ($$self.$$.dirty[0] & /*fileFilter*/
    256 | $$self.$$.dirty[1] & /*filteredByTag*/
    2097152) {
      $: $$invalidate(51, filteredByFile = fileFilter ? filteredByTag.filter((task) => task.path.toLowerCase().includes(fileFilter.toLowerCase())) : filteredByTag);
    }
    if ($$self.$$.dirty[1] & /*filteredByFile*/
    1048576) {
      $: $$invalidate(9, tasksByColumn = groupByColumnTag(filteredByFile));
    }
    if ($$self.$$.dirty[1] & /*$settingsStore*/
    33554432) {
      $: $$invalidate(22, { showFilepath = true, consolidateTags = false, uncategorizedVisibility = "auto" /* Auto */, doneVisibility = "always" /* AlwaysShow */, filtersSidebarExpanded = true, filtersSidebarWidth = 280 } = $settingsStore, showFilepath, ($$invalidate(21, consolidateTags), $$invalidate(56, $settingsStore)), ($$invalidate(50, uncategorizedVisibility), $$invalidate(56, $settingsStore)), ($$invalidate(49, doneVisibility), $$invalidate(56, $settingsStore)), ($$invalidate(18, filtersSidebarExpanded), $$invalidate(56, $settingsStore)), ($$invalidate(17, filtersSidebarWidth), $$invalidate(56, $settingsStore)));
    }
    if ($$self.$$.dirty[0] & /*tasksByColumn*/
    512 | $$self.$$.dirty[1] & /*uncategorizedVisibility*/
    524288) {
      $: $$invalidate(20, showUncategorizedColumn = uncategorizedVisibility === "always" /* AlwaysShow */ || uncategorizedVisibility === "auto" /* Auto */ && ((_b = tasksByColumn["uncategorised"]) == null ? void 0 : _b.length) > 0);
    }
    if ($$self.$$.dirty[0] & /*tasksByColumn*/
    512 | $$self.$$.dirty[1] & /*doneVisibility*/
    262144) {
      $: $$invalidate(19, showDoneColumn = doneVisibility === "always" /* AlwaysShow */ || doneVisibility === "auto" /* Auto */ && ((_c = tasksByColumn["done"]) == null ? void 0 : _c.length) > 0);
    }
  };
  return [
    app,
    tasksStore,
    taskActions,
    columnTagTableStore,
    columnColourTableStore,
    settingsStore,
    selectedTags,
    filterText,
    fileFilter,
    tasksByColumn,
    contentFilters,
    activeContentFilterId,
    activeTagFilterId,
    activeFileFilterId,
    deleteModalOpen,
    filterToDelete,
    columns,
    filtersSidebarWidth,
    filtersSidebarExpanded,
    showDoneColumn,
    showUncategorizedColumn,
    consolidateTags,
    showFilepath,
    fileFilterExists,
    tagFilterExists,
    contentFilterExists,
    fileFilters,
    tagFilters,
    availableFiles,
    tags,
    addContentFilter,
    loadContentFilter,
    clearContentFilter,
    clearFileFilter,
    addFileFilter,
    loadFileFilter,
    addTagFilter,
    clearTagFilter,
    openDeleteModal,
    closeDeleteModal,
    confirmDelete,
    toggleSidebar,
    startResize,
    handleMouseMove,
    stopResize,
    handleOpenSettings,
    openSettings,
    requestSave,
    hasInitialized,
    doneVisibility,
    uncategorizedVisibility,
    filteredByFile,
    filteredByTag,
    filteredByText,
    selectedTagsSet,
    savedFilters,
    $settingsStore,
    $tasksStore,
    $columnTagTableStore,
    click_handler,
    click_handler_1,
    input0_input_handler,
    func2,
    func_1,
    selecttag_value_binding,
    click_handler_2,
    click_handler_3,
    input1_input_handler
  ];
}
var Main = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance9,
      create_fragment12,
      safe_not_equal,
      {
        app: 0,
        tasksStore: 1,
        taskActions: 2,
        openSettings: 46,
        columnTagTableStore: 3,
        columnColourTableStore: 4,
        settingsStore: 5,
        requestSave: 47
      },
      add_css10,
      [-1, -1, -1]
    );
  }
};
var main_default = Main;

// src/ui/settings/settings.ts
var import_obsidian5 = require("obsidian");
var VisibilityOptionSchema = z.nativeEnum(VisibilityOption);
var ScopeOptionSchema = z.nativeEnum(ScopeOption);
var SettingsModal = class extends import_obsidian5.Modal {
  constructor(app, settings, onSubmit) {
    super(app);
    this.settings = settings;
    this.onSubmit = onSubmit;
  }
  onOpen() {
    this.contentEl.createEl("h1", { text: "Settings" });
    new import_obsidian5.Setting(this.contentEl).setName("Columns").setDesc('The column names separated by a comma ","').setClass("column").addText((text2) => {
      text2.setValue(this.settings.columns.join(", "));
      text2.onChange((value) => {
        this.settings.columns = value.split(",").map((column) => column.trim());
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Folder scope").setDesc("Where should we try to find tasks for this Kanban?").addDropdown((dropdown) => {
      dropdown.addOption("folder" /* Folder */, "This folder");
      dropdown.addOption("everywhere" /* Everywhere */, "Every folder");
      dropdown.setValue(this.settings.scope);
      dropdown.onChange((value) => {
        const validatedValue = ScopeOptionSchema.safeParse(value);
        this.settings.scope = validatedValue.success ? validatedValue.data : defaultSettings.scope;
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Show filepath").setDesc("Show the filepath on each task in Kanban?").addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.settings.showFilepath) != null ? _a : true);
      toggle.onChange((value) => {
        this.settings.showFilepath = value;
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Uncategorized column visibility").setDesc("When to show the Uncategorized column").addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("always" /* AlwaysShow */, "Always show").addOption("auto" /* Auto */, "Hide when empty").addOption("never" /* NeverShow */, "Never show").setValue(
        (_a = this.settings.uncategorizedVisibility) != null ? _a : "auto" /* Auto */
      ).onChange((value) => {
        const validatedValue = VisibilityOptionSchema.safeParse(value);
        this.settings.uncategorizedVisibility = validatedValue.success ? validatedValue.data : defaultSettings.uncategorizedVisibility;
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Done column visibility").setDesc("When to show the Done column").addDropdown((dropdown) => {
      var _a;
      dropdown.addOption("always" /* AlwaysShow */, "Always show").addOption("auto" /* Auto */, "Hide when empty").addOption("never" /* NeverShow */, "Never show").setValue(
        (_a = this.settings.doneVisibility) != null ? _a : "auto" /* Auto */
      ).onChange((value) => {
        const validatedValue = VisibilityOptionSchema.safeParse(value);
        this.settings.doneVisibility = validatedValue.success ? validatedValue.data : defaultSettings.doneVisibility;
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Consolidate tags").setDesc(
      "Consolidate the tags on each task in Kanban into the footer?"
    ).addToggle((toggle) => {
      var _a;
      toggle.setValue((_a = this.settings.consolidateTags) != null ? _a : false);
      toggle.onChange((value) => {
        this.settings.consolidateTags = value;
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Done status markers").setDesc(
      "Characters that mark a task as done (e.g., 'xX' for [x] and [X]). Each character should be a single Unicode character without spaces."
    ).addText((text2) => {
      var _a;
      text2.setValue((_a = this.settings.doneStatusMarkers) != null ? _a : DEFAULT_DONE_STATUS_MARKERS);
      text2.onChange((value) => {
        const errors = validateDoneStatusMarkers(value);
        if (errors.length > 0) {
          text2.inputEl.style.borderColor = "var(--text-error)";
          text2.inputEl.title = `Invalid: ${errors.join(", ")}`;
        } else {
          text2.inputEl.style.borderColor = "";
          text2.inputEl.title = "Valid done status markers";
          this.settings.doneStatusMarkers = value;
        }
      });
    });
    new import_obsidian5.Setting(this.contentEl).setName("Ignored status markers").setDesc(
      "Characters that mark tasks to be completely ignored by the kanban (e.g., '-' for [-] cancelled tasks). Leave empty to process all task-like strings. Each character should be a single Unicode character without spaces."
    ).addText((text2) => {
      var _a;
      text2.setValue((_a = this.settings.ignoredStatusMarkers) != null ? _a : DEFAULT_IGNORED_STATUS_MARKERS);
      text2.onChange((value) => {
        const errors = validateIgnoredStatusMarkers(value);
        if (errors.length > 0) {
          text2.inputEl.style.borderColor = "var(--text-error)";
          text2.inputEl.title = `Invalid: ${errors.join(", ")}`;
        } else {
          text2.inputEl.style.borderColor = "";
          text2.inputEl.title = "Valid ignored status markers";
          this.settings.ignoredStatusMarkers = value;
        }
      });
    });
    new import_obsidian5.Setting(this.contentEl).addButton(
      (btn) => btn.setButtonText("Save").onClick(() => {
        this.close();
        this.onSubmit(this.settings);
      })
    );
  }
  onClose() {
    this.contentEl.empty();
  }
};

// src/ui/tasks/store.ts
var import_obsidian7 = require("obsidian");

// src/ui/tasks/tasks.ts
async function updateMapsFromFile({
  fileHandle,
  taskIdsByFileHandle,
  tasksByTaskId,
  metadataByTaskId,
  vault,
  columnTagTableStore,
  consolidateTags,
  doneStatusMarkers,
  ignoredStatusMarkers
}) {
  var _a;
  try {
    const previousTaskIds = (_a = taskIdsByFileHandle.get(fileHandle)) != null ? _a : /* @__PURE__ */ new Set();
    const newTaskIds = /* @__PURE__ */ new Set();
    const contents = await vault.read(fileHandle);
    const rows = contents.split("\n");
    const columnTagTable = get_store_value(columnTagTableStore);
    for (let i = 0; i < rows.length; i++) {
      const row = rows[i];
      if (!row) {
        continue;
      }
      if (isTrackedTaskString(row, ignoredStatusMarkers)) {
        const task = new Task2(
          row,
          fileHandle,
          i,
          columnTagTable,
          consolidateTags,
          doneStatusMarkers,
          ignoredStatusMarkers
        );
        newTaskIds.add(task.id);
        tasksByTaskId.set(task.id, task);
        metadataByTaskId.set(task.id, { rowIndex: i, fileHandle });
        previousTaskIds.delete(task.id);
      }
    }
    for (const prevId of previousTaskIds) {
      tasksByTaskId.delete(prevId);
      metadataByTaskId.delete(prevId);
    }
    taskIdsByFileHandle.set(fileHandle, newTaskIds);
  } catch (e) {
  }
}

// src/ui/tasks/actions.ts
var import_obsidian6 = require("obsidian");
function createTaskActions({
  tasksByTaskId,
  metadataByTaskId,
  vault,
  workspace
}) {
  async function updateRowWithTask(id, updater) {
    const metadata = metadataByTaskId.get(id);
    const task = tasksByTaskId.get(id);
    if (!metadata || !task) {
      return;
    }
    updater(task);
    const newTaskString = task.serialise();
    await updateRow(
      vault,
      metadata.fileHandle,
      metadata.rowIndex,
      newTaskString
    );
  }
  return {
    async changeColumn(id, column) {
      await updateRowWithTask(id, (task) => task.column = column);
    },
    async markDone(id) {
      await updateRowWithTask(id, (task) => task.done = true);
    },
    async updateContent(id, content) {
      await updateRowWithTask(id, (task) => task.content = content);
    },
    async archiveTasks(ids) {
      for (const id of ids) {
        await updateRowWithTask(id, (task) => task.archive());
      }
    },
    async deleteTask(id) {
      await updateRowWithTask(id, (task) => task.delete());
    },
    async viewFile(id) {
      const metadata = metadataByTaskId.get(id);
      if (!metadata) {
        return;
      }
      const { fileHandle, rowIndex } = metadata;
      const leaf = workspace.getLeaf("tab");
      await leaf.openFile(fileHandle);
      const editorView = workspace.getActiveViewOfType(import_obsidian6.MarkdownView);
      editorView == null ? void 0 : editorView.editor.setCursor(rowIndex);
    },
    async addNew(column, e) {
      const files = vault.getMarkdownFiles().sort((a, b) => a.path.localeCompare(b.path));
      const target = e.target;
      if (!target) {
        return;
      }
      const boundingRect = target.getBoundingClientRect();
      const y = boundingRect.top + boundingRect.height / 2;
      const x = boundingRect.left + boundingRect.width / 2;
      function createMenu(folder2, parentMenu) {
        const menu = new import_obsidian6.Menu();
        menu.addItem((i) => {
          i.setTitle(parentMenu ? `\u2190 back` : "Choose a file").setDisabled(!parentMenu).onClick(() => {
            parentMenu == null ? void 0 : parentMenu.showAtPosition({ x, y });
          });
        });
        for (const [label, folderItem] of Object.entries(folder2)) {
          menu.addItem((i) => {
            i.setTitle(
              folderItem instanceof import_obsidian6.TFile ? label : label + " \u2192"
            ).onClick(() => {
              if (folderItem instanceof import_obsidian6.TFile) {
                updateRow(
                  vault,
                  folderItem,
                  void 0,
                  `- [ ]  #${column}`
                );
              } else {
                createMenu(folderItem, menu);
              }
            });
          });
        }
        menu.showAtPosition({ x, y });
      }
      const folder = {};
      for (const file of files) {
        const segments = file.path.split("/");
        let currFolder = folder;
        for (const [i, segment] of segments.entries()) {
          if (i === segments.length - 1) {
            currFolder[segment] = file;
          } else {
            const nextFolder = currFolder[segment] || {};
            if (nextFolder instanceof import_obsidian6.TFile) {
              continue;
            }
            currFolder[segment] = nextFolder;
            currFolder = nextFolder;
          }
        }
      }
      createMenu(folder, void 0);
    }
  };
}
async function updateRow(vault, fileHandle, row, newText) {
  const file = await vault.read(fileHandle);
  const rows = file.split("\n");
  if (row == null) {
    row = rows.length;
  }
  if (rows.length < row) {
    return;
  }
  if (newText === "") {
    rows.splice(row, 1);
  } else {
    rows[row] = newText;
  }
  const newFile = rows.join("\n");
  await vault.modify(fileHandle, newFile);
}

// src/ui/tasks/store.ts
function createTasksStore(vault, workspace, registerEvent, columnTagTableStore, getFilenameFilter, settingsStore) {
  const tasksStore = writable([]);
  let timer;
  const tasksByTaskId = /* @__PURE__ */ new Map();
  const metadataByTaskId = /* @__PURE__ */ new Map();
  const taskIdsByFileHandle = /* @__PURE__ */ new Map();
  const fileHandles = vault.getMarkdownFiles();
  function debounceSetTasks() {
    if (!timer) {
      timer = window.setTimeout(() => {
        timer = void 0;
        tasksStore.set(
          [...tasksByTaskId.values()].sort((a, b) => {
            if (a.path !== b.path) {
              return a.path.localeCompare(b.path);
            }
            return a.rowIndex - b.rowIndex;
          })
        );
      }, 50);
    }
  }
  function shouldHandle(file) {
    var _a;
    const filenameFilter = (_a = getFilenameFilter()) == null ? void 0 : _a.replace(/^\//, "");
    return !filenameFilter || file.path.startsWith(filenameFilter);
  }
  function initialise() {
    var _a, _b, _c;
    tasksByTaskId.clear();
    metadataByTaskId.clear();
    taskIdsByFileHandle.clear();
    const settings = get_store_value(settingsStore);
    const consolidateTags = (_a = settings.consolidateTags) != null ? _a : false;
    const doneStatusMarkers = (_b = settings.doneStatusMarkers) != null ? _b : DEFAULT_DONE_STATUS_MARKERS;
    const ignoredStatusMarkers = (_c = settings.ignoredStatusMarkers) != null ? _c : DEFAULT_IGNORED_STATUS_MARKERS;
    for (const fileHandle of fileHandles) {
      if (!shouldHandle(fileHandle)) {
        continue;
      }
      updateMapsFromFile({
        fileHandle,
        tasksByTaskId,
        metadataByTaskId,
        taskIdsByFileHandle,
        vault,
        columnTagTableStore,
        consolidateTags,
        doneStatusMarkers,
        ignoredStatusMarkers
      }).then(() => {
        debounceSetTasks();
      });
    }
  }
  registerEvent(
    vault.on("modify", (fileHandle) => {
      var _a, _b, _c;
      if (fileHandle instanceof import_obsidian7.TFile && shouldHandle(fileHandle)) {
        const settings = get_store_value(settingsStore);
        const consolidateTags = (_a = settings.consolidateTags) != null ? _a : false;
        const doneStatusMarkers = (_b = settings.doneStatusMarkers) != null ? _b : DEFAULT_DONE_STATUS_MARKERS;
        const ignoredStatusMarkers = (_c = settings.ignoredStatusMarkers) != null ? _c : DEFAULT_IGNORED_STATUS_MARKERS;
        updateMapsFromFile({
          fileHandle,
          tasksByTaskId,
          metadataByTaskId,
          taskIdsByFileHandle,
          vault,
          columnTagTableStore,
          consolidateTags,
          doneStatusMarkers,
          ignoredStatusMarkers
        }).then(() => {
          debounceSetTasks();
        });
      }
    })
  );
  registerEvent(
    vault.on("create", (fileHandle) => {
      var _a, _b, _c;
      if (fileHandle instanceof import_obsidian7.TFile && shouldHandle(fileHandle)) {
        const settings = get_store_value(settingsStore);
        const consolidateTags = (_a = settings.consolidateTags) != null ? _a : false;
        const doneStatusMarkers = (_b = settings.doneStatusMarkers) != null ? _b : DEFAULT_DONE_STATUS_MARKERS;
        const ignoredStatusMarkers = (_c = settings.ignoredStatusMarkers) != null ? _c : DEFAULT_IGNORED_STATUS_MARKERS;
        updateMapsFromFile({
          fileHandle,
          tasksByTaskId,
          metadataByTaskId,
          taskIdsByFileHandle,
          vault,
          columnTagTableStore,
          consolidateTags,
          doneStatusMarkers,
          ignoredStatusMarkers
        }).then(() => {
          debounceSetTasks();
        });
      }
    })
  );
  registerEvent(
    vault.on("delete", (fileHandle) => {
      if (fileHandle instanceof import_obsidian7.TFile) {
        const tasksToDelete = taskIdsByFileHandle.get(fileHandle);
        if (!tasksToDelete) return;
        for (const taskId of tasksToDelete) {
          tasksByTaskId.delete(taskId);
          metadataByTaskId.delete(taskId);
        }
        taskIdsByFileHandle.delete(fileHandle);
      }
    })
  );
  registerEvent(
    vault.on("rename", (fileHandle) => {
      if (fileHandle instanceof import_obsidian7.TFile) {
        initialise();
      }
    })
  );
  const taskActions = createTaskActions({
    tasksByTaskId,
    metadataByTaskId,
    vault,
    workspace
  });
  return { tasksStore, taskActions, initialise };
}

// src/ui/text_view.ts
var KANBAN_VIEW_NAME = "kanban-view";
var KanbanView = class extends import_obsidian8.TextFileView {
  constructor(leaf) {
    super(leaf);
    this.filenameFilter = null;
    this.icon = "kanban-square";
    this.settingsStore = createSettingsStore();
    this.destroySettingsStore = this.settingsStore.subscribe((settings) => {
      var _a, _b, _c;
      switch (settings.scope) {
        case "everywhere" /* Everywhere */:
          this.filenameFilter = null;
          break;
        case "folder" /* Folder */:
          this.filenameFilter = (_c = (_b = (_a = this.file) == null ? void 0 : _a.parent) == null ? void 0 : _b.path) != null ? _c : null;
          break;
        default:
          this.filenameFilter = null;
          break;
      }
    });
    const { columnTagTable, columnColourTable } = createColumnStores(
      this.settingsStore
    );
    this.columnTagTableStore = columnTagTable;
    this.columnColourTableStore = columnColourTable;
    const { tasksStore, taskActions, initialise } = createTasksStore(
      this.app.vault,
      this.app.workspace,
      this.registerEvent.bind(this),
      this.columnTagTableStore,
      () => this.filenameFilter,
      this.settingsStore
    );
    this.tasksStore = tasksStore;
    this.taskActions = taskActions;
    this.initialiseTasksStore = initialise;
  }
  onLocalSettingsChange(newSettings) {
    this.settingsStore.set(newSettings);
    this.initialiseTasksStore();
    this.requestSave();
  }
  openSettingsModal() {
    const settingsModal = new SettingsModal(
      this.app,
      structuredClone(get_store_value(this.settingsStore)),
      (newSettings) => this.onLocalSettingsChange(newSettings)
    );
    settingsModal.open();
    return new Promise((resolve) => {
      settingsModal.onClose = () => {
        resolve();
        settingsModal.onClose = () => void 0;
      };
    });
  }
  getViewType() {
    this.leaf.openFile;
    return KANBAN_VIEW_NAME;
  }
  getViewData() {
    const parsed = (0, import_front_matter.default)(this.data + "\n");
    parsed.attributes["kanban_plugin"] = toSettingsString(
      get_store_value(this.settingsStore)
    );
    return `---
${Object.entries(parsed.attributes).map(([key, value]) => `${key}: '${value}'`).join("\n")}
---
${parsed.body}
`;
  }
  setViewData(data) {
    this.settingsStore.set(this.getInitialSettings(data));
    this.initialiseTasksStore();
  }
  getInitialSettings(data) {
    var _a;
    const parsed = (0, import_front_matter.default)(data + "\n");
    return parseSettingsString((_a = parsed.attributes.kanban_plugin) != null ? _a : "");
  }
  clear() {
  }
  async onOpen() {
    this.component = new main_default({
      target: this.contentEl,
      props: {
        app: this.app,
        tasksStore: this.tasksStore,
        taskActions: this.taskActions,
        columnTagTableStore: this.columnTagTableStore,
        columnColourTableStore: this.columnColourTableStore,
        openSettings: () => this.openSettingsModal(),
        settingsStore: this.settingsStore,
        requestSave: () => this.requestSave()
      }
    });
  }
  async onClose() {
    var _a;
    (_a = this.component) == null ? void 0 : _a.$destroy();
    this.destroySettingsStore();
  }
};

// src/entry.ts
var Base = class extends import_obsidian9.Plugin {
  async onload() {
    this.registerView(KANBAN_VIEW_NAME, (leaf) => new KanbanView(leaf));
    this.registerHoverLinkSource("kanban-view", {
      display: "Kanban",
      defaultMod: false
    });
    this.switchToKanbanAfterLoad();
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        this.switchToKanbanAfterLoad();
      })
    );
    this.registerEvent(
      this.app.workspace.on("file-menu", (menu, file) => {
        menu.addItem((item) => {
          item.setTitle("New kanban").setIcon("square-kanban").onClick(async () => {
            var _a;
            const newFile = await this.app.vault.create(
              file.path + "/Kanban-" + Date.now() + ".md",
              `---
kanban_plugin: {}
---
`
            );
            (_a = this.app.workspace.getActiveViewOfType(import_obsidian9.MarkdownView)) == null ? void 0 : _a.leaf.openFile(newFile);
          });
        });
      })
    );
  }
  onunload() {
  }
  switchToKanbanAfterLoad() {
    this.app.workspace.onLayoutReady(() => {
      let leaf;
      for (leaf of this.app.workspace.getLeavesOfType("markdown")) {
        if (leaf.view instanceof import_obsidian9.MarkdownView && this.isKanbanFile(leaf.view.file)) {
          this.setKanbanView(leaf);
        }
      }
    });
  }
  isKanbanFile(file) {
    if (!file) {
      return false;
    }
    const fileCache = this.app.metadataCache.getFileCache(file);
    return !!(fileCache == null ? void 0 : fileCache.frontmatter) && !!fileCache.frontmatter["kanban_plugin"];
  }
  async setKanbanView(leaf) {
    await leaf.setViewState({
      type: KANBAN_VIEW_NAME,
      state: leaf.view.getState()
    });
  }
};

/* nosourcemap */
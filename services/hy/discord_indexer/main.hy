"\nCrawl through discord history and fill in all messages that are not getting processed in real time.\n"
(import os)
(setv AGENT_NAME ((. os.environ get) "AGENT_NAME" "duck"))
(print f"Discord indexer running for {AGENT_NAME}")
(import sys)
((. sys.path insert) 0 ((. os.path join) ((. os.path dirname) __file__) "../../../"))
(import asyncio)
(import random)
(import traceback)
(import typing [List])
(import discord)
(import shared.py [settings])
(import shared.py.mongodb [discord_message_collection discord_channel_collection])
(import [shared.hy.utils [shuffle_array]])
(setv intents ((. discord.Intents default)))
(setv client (discord.Client :intents intents))
(setv intents.message_content True)
(defn format_message [message]
  (setv channel message.channel)
  (setv author message.author)
  (if (hasattr channel "name")
      (do (setv channel_name channel.name))
      (do (setv channel_name f"DM from {(. channel.recipient name)}")))
  (return {"id" message.id  "recipient" settings.DISCORD_CLIENT_USER_ID  "recipient_name" settings.DISCORD_CLIENT_USER_NAME  "created_at" (str message.created_at)  "raw_mentions" message.raw_mentions  "author_name" author.name  "guild" (. message.guild id)  "channel_name" channel_name  "content" message.content  "author" author.id  "channel" channel.id}))

(defn (annotate setup_channel None) [channel_id]
  "\n    Setup a channel for indexing.\n    " (print f"Setting up channel {channel_id}") (discord_channel_collection.insert_one {"id" channel_id  "cursor" None}))
(defn (annotate update_cursor None) [(annotate message discord.Message)] "\n    Update the cursor for a channel.\n    " (print f"Updating cursor for channel {(. message.channel id)} to {message.id}") (discord_channel_collection.update_one {"id" (. message.channel id)} {"$set" {"cursor" message.id}}))
(defn (annotate index_message None) [(annotate message discord.Message)] "\n    Index a message only if it has not already been added to mongo.\n    " (setv message_record (discord_message_collection.find_one {"id" message.id})) (if (is message_record None) (do (print f"Indexing message {message.id} {message.content}") (discord_message_collection.insert_one (format_message message))) (do (print f"Message {message.id} already indexed") (print message_record))))
(defn find_channel_record [channel_id] "\n    Find the record for a channel.\n    " (print f"Finding channel record for {channel_id}") (setv record (discord_channel_collection.find_one {"id" channel_id})) (if (is record None) (do (print f"No record found for {channel_id}") (setup_channel channel_id) (setv record (discord_channel_collection.find_one {"id" channel_id}))) (do (print f"Found channel record for {channel_id}"))) (print f"Channel record: {record}") (return record))
(defn :async (annotate next_messages (get List discord.Message)) [(annotate channel discord.TextChannel)] "\n    Get the next batch of messages in a channel.\n    " (setv channel_record (find_channel_record channel.id)) (print f"Cursor: {(get channel_record "cursor")}") (print f"Getting history for {channel_record}") (when (not (channel_record.get "is_valid" True)) (print f"Channel {(get channel_record "id")} is not valid") (return [])) (if (is (get channel_record "cursor") None) (do (print f"No cursor found for {(get channel_record "id")}") (try (return (lfor :async message (channel.history :limit 200 :oldest_first True) message)) (except [e Exception] (print f"Error getting history for {(get channel_record "id")}") (print e) (discord_channel_collection.update_one {"id" (get channel_record "id")} {"$set" {"is_valid" False}}) (return [])))) (do (print f"Cursor found for {channel} {(get channel_record "cursor")}") (try (return (lfor :async message (channel.history :limit 200 :oldest_first True :after (channel.get_partial_message (get channel_record "cursor"))) message)) (except [e AttributeError] (print f"Attribute error for {channel.id}") (print e) (return []))))))
(defn :async (annotate index_channel None) [(annotate channel discord.TextChannel)] "\n    Index all messages in a channel.\n    " (setv newest_message None) (print f"Indexing channel {channel}") (for [message (await (next_messages channel))] (await (asyncio.sleep 0.1)) (setv newest_message message) (index_message message)) (when (is-not newest_message None) (update_cursor newest_message)) (print f"Newest message: {newest_message}"))
(defn :async [client.event] on_ready [] (while True (for [channel (shuffle_array (list (client.get_all_channels)))] (when (isinstance channel discord.TextChannel) (print f"Indexing channel {channel}") (setv random_sleep (random.randint 1 10)) (await (asyncio.sleep random_sleep)) (await (index_channel channel))))))
(defn :async [client.event] on_message [message] (print message) (index_message message))
(client.run settings.DISCORD_TOKEN)


(ns elisp.mcp
  "Tree-sitter assisted helpers for locating and manipulating MCP blocks in Emacs Lisp files."
  (:require [clojure.string :as str]
            [elisp.read :as read])
  (:import [java.nio.charset StandardCharsets]))

(def ^:private generated-comment
  ";; AUTO-GENERATED by mk.mcp-cli -- edits will be overwritten.")

(def ^:private with-eval-head
  "with-eval-after-load")

(def ^:private target-module "'mcp")

(defn- utf8-slice
  ([^bytes bytes start]
   (utf8-slice bytes start (alength bytes)))
  ([^bytes bytes start end]
   (String. bytes start (- end start) StandardCharsets/UTF_8)))

(defn- generated-comment?
  [node]
  (and (= "comment" (:type node))
       (= generated-comment (str/trim (:text node)))))

(defn- first-child-of-type [node type]
  (some #(when (= type (:type %)) %) (:children node)))

(defn- with-eval-block?
  [node]
  (when (= "list" (:type node))
    (let [symbol-node (first-child-of-type node "symbol")
          quote-node  (first-child-of-type node "quote")]
      (and symbol-node quote-node
           (= with-eval-head (:text symbol-node))
           (= target-module (str/trim (:text quote-node)))))))

(defn find-generated-block
  "Locate the auto-generated `(with-eval-after-load 'mcp â€¦)` block in `source`.

  Returns a map containing:
  - `:before`: source prior to the block
  - `:after`: source after the block
  - `:block`: the block itself (comment + form)
  - `:block-start` / `:block-end`: byte offsets for the replacement range

  Returns nil when the block is absent or the source fails to parse cleanly."
  [^String source]
  (let [{:keys [root source-bytes has-errors?]} (read/syntax-tree source)]
    (when-not has-errors?
      (let [;; only consider named children to skip unnamed trivia (e.g. blank lines)
            children (vec (filter :named? (:children root)))
            count-children (count children)]
        (loop [idx 0]
          (if (>= idx count-children)
            nil
            (let [node (nth children idx)]
              (if (generated-comment? node)
                (let [next-idx (inc idx)]
                  (when (< next-idx count-children)
                    (let [block-node (nth children next-idx)]
                      (if (with-eval-block? block-node)
                        (let [start (:start-byte node)
                              end   (:end-byte block-node)
                              block (utf8-slice source-bytes start end)
                              before (utf8-slice source-bytes 0 start)
                              after  (utf8-slice source-bytes end)]
                          {:before before
                           :after after
                           :block block
                           :block-start start
                           :block-end end})
                        (recur (inc idx))))))
                (recur (inc idx))))))))))
(ns clj-hacks.mcp.elisp
  "Utilities for constructing Emacs Lisp AST fragments from MCP EDN configs."
  (:require [clojure.string :as str]
            [elisp.ast :as ast]
            [elisp.mcp :as mcp]
            [elisp.read :as read]))

(def ^:private key-order
  [:command :args :cwd :url :transport :env])

(def ^:private key-rank
  (zipmap key-order (range)))

(defn- order-keys [m]
  (sort-by (fn [k]
             [(get key-rank k Integer/MAX_VALUE)
              (name k)])
           (keys m)))

(defn- value->ast [v]
  (cond
    (string? v) (ast/string v)
    (boolean? v) (if v (ast/symbol "t") nil)
    (sequential? v) (apply ast/list (map value->ast v))
    (number? v) v
    (nil? v) nil
    (keyword? v) (ast/string (name v))
    :else (ast/string (str v))))

(defn- server-plist [props]
  (let [pairs (for [k (order-keys props)]
                [k (value->ast (get props k))])]
    (apply ast/plist pairs)))

(defn server-entry->ast [[name-key props]]
  (let [label (cond
                (keyword? name-key) (name name-key)
                (string? name-key) name-key
                :else (str name-key))]
    (ast/cons (ast/string label)
              (server-plist props))))

(defn- server-sort-key [[k _]]
  (if (keyword? k)
    (name k)
    (str k)))

(defn servers->alist [servers]
  (let [entries (->> servers
                     (sort-by server-sort-key)
                     (map server-entry->ast))]
    (apply ast/list entries)))

(def generated-comment
  ";; AUTO-GENERATED by mk.mcp-cli -- edits will be overwritten.\n")

(defn mcp-block-ast [servers]
  (ast/list (ast/symbol "with-eval-after-load")
            (ast/quote (ast/symbol "mcp"))
            (ast/list (ast/symbol "setq")
                      (ast/symbol "mcp-hub-servers")
                      (ast/quote (servers->alist servers)))))

(defn block-with-comment [servers]
  [(ast/comment generated-comment)
   (mcp-block-ast servers)])

(defn render-generated-block
  "Emit the comment + with-eval-after-load block for `servers`."
  [servers]
  (let [[comment-node block-node] (block-with-comment servers)
        comment (ast/emit comment-node)
        block   (ast/emit block-node)
        block*  (if (str/ends-with? block "\n") block (str block "\n"))]
    (str comment block*)))

(defn- verify-rewrite
  [source block-text]
  (let [{:keys [has-errors?]} (read/syntax-tree source)]
    (cond
      has-errors?
      {:ok? false
       :error :parse-error
       :message "Tree-sitter reported syntax errors after rewrite."}

      :else
      (if-let [found (mcp/find-generated-block source)]
        (let [expected (str/trimr block-text)
              actual   (str/trimr (:block found))]
          (if (= expected actual)
            {:ok? true :found found}
            {:ok? false
             :error :mismatch
             :found found
             :message "Generated block not found or mismatched after rewrite."}))
        {:ok? false
         :error :missing-block
         :message "Generated block not found after rewrite."}))))

(defn rewrite-source
  "Rewrite `source` with the generated block rendered from `servers`.

  Returns a map {:ok? bool :source <string> :changed? bool :inserted? bool ...}.
  When :ok? is false, the map will contain :error and :message describing the
  failure and the original source is returned under :source."
  [source servers]
  (let [block-text (render-generated-block servers)
        existing (mcp/find-generated-block source)
        insertion? (nil? existing)
        unchanged? (and existing (= block-text (:block existing)))
        new-source (if existing
                     (str (:before existing) block-text (:after existing))
                     (let [separator (cond
                                       (str/blank? source) ""
                                       (str/ends-with? source "\n\n") ""
                                       (str/ends-with? source "\n") "\n"
                                       :else "\n\n")]
                       (str source separator block-text)))
        verification (verify-rewrite new-source block-text)]
    (if (:ok? verification)
      {:ok? true
       :source new-source
       :block block-text
       :changed? (not unchanged?)
       :inserted? insertion?
       :range (when existing {:start (:block-start existing)
                              :end   (:block-end existing)})
       :found (:found verification)
       :original existing}
      (assoc verification
             :source source
             :original existing
             :attempt block-text
             :inserted? insertion?))))

(defn rewrite-file!
  "Rewrite the file at `path` with the generated block. Returns the result map
  from `rewrite-source`, augmented with :path. When :ok? and :changed? are true,
  the file is updated on disk."
  [path servers]
  (let [original (slurp path)
        result   (rewrite-source original servers)]
    (if (and (:ok? result) (:changed? result))
      (do
        (spit path (:source result))
        (assoc result :path path :wrote? true))
      (assoc result :path path :wrote? false))))
#!/usr/bin/env node
// This file mirrors the logic in packages/promethean-cli/src/promethean/cli/core.cljs
// and will be regenerated by shadow-cljs when a release build runs.
import { existsSync, readdirSync, readFileSync } from "fs";
import path from "path";
import { spawn } from "child_process";
import { fileURLToPath } from "url";

const IGNORED_DIRECTORIES = new Set([
  ".git",
  ".hg",
  ".svn",
  ".pnpm",
  ".cache",
  ".turbo",
  "dist",
  "build",
  "node_modules",
  "coverage",
  "out",
  "target",
  "tmp",
]);

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const REPO_ROOT = path.resolve(__dirname, "..", "..", "..");
const PACKAGES_ROOT = path.join(REPO_ROOT, "packages");

function readJson(file) {
  try {
    return JSON.parse(readFileSync(file, "utf8"));
  } catch {
    return null;
  }
}

function childDirectories(dir) {
  try {
    const entries = readdirSync(dir, { withFileTypes: true });
    return entries
      .filter(
        (entry) => entry.isDirectory() && !IGNORED_DIRECTORIES.has(entry.name),
      )
      .map((entry) => path.join(dir, entry.name));
  } catch {
    return [];
  }
}

function aliasFor(name, dir) {
  const fallback = path.basename(dir);
  if (typeof name === "string" && name.trim().length > 0) {
    const parts = name.split("/");
    const alias = parts[parts.length - 1];
    return alias || fallback;
  }
  return fallback;
}

function packageInfo(dir) {
  const manifestPath = path.join(dir, "package.json");
  if (!existsSync(manifestPath)) {
    return null;
  }

  const manifest = readJson(manifestPath);
  if (
    !manifest ||
    typeof manifest.name !== "string" ||
    manifest.name.trim().length === 0
  ) {
    return null;
  }

  const scriptsMap = manifest.scripts ?? {};
  const scriptNames = Object.keys(scriptsMap)
    .map((key) => key.trim())
    .filter((key) => key.length > 0)
    .sort((a, b) => a.localeCompare(b));

  return {
    dir,
    name: manifest.name,
    alias: aliasFor(manifest.name, dir),
    scripts: new Set(scriptNames),
    orderedScripts: scriptNames,
  };
}

function gatherPackages(startDir, seen = new Map()) {
  if (seen.has(startDir)) {
    return seen;
  }

  const info = packageInfo(startDir);
  if (info) {
    seen.set(startDir, info);
  }

  for (const child of childDirectories(startDir)) {
    gatherPackages(child, seen);
  }

  return seen;
}

function discoverPackages() {
  const discovered = new Map();

  if (existsSync(PACKAGES_ROOT)) {
    for (const pkgDir of childDirectories(PACKAGES_ROOT)) {
      gatherPackages(pkgDir, discovered);
    }
  }

  const rootInfo = packageInfo(REPO_ROOT);
  if (rootInfo) {
    discovered.set(REPO_ROOT, rootInfo);
  }

  return Array.from(discovered.values());
}

function usage(packages) {
  console.log("Promethean CLI\n");
  console.log("Usage: promethean <package> <action> [-- <script-args>]");
  console.log("\nAvailable packages and actions:");

  const sorted = [...packages].sort((a, b) => a.alias.localeCompare(b.alias));
  for (const pkg of sorted) {
    const heading =
      pkg.alias === pkg.name
        ? `  ${pkg.alias}`
        : `  ${pkg.alias} (${pkg.name})`;
    console.log(heading);
    if (pkg.orderedScripts.length === 0) {
      console.log("    (no scripts)");
    } else {
      for (const action of pkg.orderedScripts) {
        console.log(`    ${action}`);
      }
    }
  }
  console.log("");
}

function buildAliasMap(packages) {
  const map = new Map();
  for (const pkg of packages) {
    if (pkg.alias) {
      map.set(pkg.alias, pkg);
    }
    if (pkg.name) {
      map.set(pkg.name, pkg);
    }
    const base = path.basename(pkg.dir);
    if (base) {
      map.set(base, pkg);
    }
  }
  return map;
}

function formatPackageHeading(pkg) {
  return pkg.alias === pkg.name ? pkg.alias : `${pkg.alias} (${pkg.name})`;
}

function showPackageActions(pkg) {
  console.log(`\nAvailable actions for ${formatPackageHeading(pkg)}:`);
  if (pkg.orderedScripts.length === 0) {
    console.log("  (no scripts)");
  } else {
    for (const action of pkg.orderedScripts) {
      console.log(`  ${action}`);
    }
  }
}

function runPnpmScript(pkg, action, extraArgs) {
  const args = ["--filter", pkg.name, "run", action];
  if (extraArgs.length > 0) {
    args.push("--", ...extraArgs);
  }

  const child = spawn("pnpm", args, { stdio: "inherit" });

  child.on("exit", (code) => {
    process.exit(code ?? 0);
  });

  child.on("error", (error) => {
    console.error("Failed to run pnpm:", error);
    process.exit(1);
  });
}

function main(argv) {
  const packages = discoverPackages();
  if (argv.length === 0) {
    usage(packages);
    process.exit(1);
  }

  const command = argv[0];
  if (command === "--help" || command === "-h" || command === "help") {
    usage(packages);
    process.exit(0);
  }

  if (command === "--list") {
    usage(packages);
    process.exit(0);
  }

  const aliases = buildAliasMap(packages);
  const pkg = aliases.get(command);
  if (!pkg) {
    console.error(`Unknown package: ${command}`);
    usage(packages);
    process.exit(1);
  }

  const action = argv[1];
  if (!action) {
    console.error("Missing action argument.");
    showPackageActions(pkg);
    process.exit(1);
  }

  if (!pkg.scripts.has(action)) {
    console.error(
      `Unknown action '${action}' for ${formatPackageHeading(pkg)}.`,
    );
    showPackageActions(pkg);
    process.exit(1);
  }

  const extra = argv.slice(2);
  runPnpmScript(pkg, action, extra);
}

main(process.argv.slice(2));

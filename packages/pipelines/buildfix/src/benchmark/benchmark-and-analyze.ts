#!/usr/bin/env tsx

import { execSync } from 'child_process';
import { readFile, writeFile } from 'fs/promises';
import { parseArgs } from 'util';

interface BenchmarkConfig {
  models?: string;
  forceRefresh?: boolean;
  clearCache?: boolean;
  analyzeOnly?: boolean;
  reportPath?: string;
  analysisModel?: string;
}

class BenchmarkOrchestrator {
  private packagePath = '/home/err/devel/promethean/packages/buildfix';

  async runBenchmarkAndAnalysis(config: BenchmarkConfig): Promise<void> {
    console.log('üöÄ BuildFix Benchmark & Analysis Orchestrator');
    console.log('==========================================');

    try {
      let reportPath: string;

      if (config.analyzeOnly && config.reportPath) {
        // Analysis only mode
        console.log('üìä Analysis-only mode detected');
        reportPath = config.reportPath;
      } else {
        // Run benchmark first
        reportPath = await this.runBenchmark(config);
      }

      // Run analysis
      await this.runAnalysis(reportPath, config.analysisModel);

      console.log('\n‚úÖ Benchmark and analysis completed successfully!');
    } catch (error) {
      console.error('‚ùå Orchestrator failed:', error);
      process.exit(1);
    }
  }

  private async runBenchmark(config: BenchmarkConfig): Promise<string> {
    console.log('\nüéØ Running BuildFix Benchmark...');

    const args = ['tsx', 'src/benchmark/run-memoized.ts'];

    if (config.models) {
      args.push('--models', config.models);
    }

    if (config.forceRefresh) {
      args.push('--force-refresh');
    }

    if (config.clearCache) {
      args.push('--clear-cache');
    }

    const command = `pnpm --filter @promethean/buildfix exec ${args.join(' ')}`;
    console.log(`üîß Executing: ${command}`);

    try {
      const output = execSync(command, {
        cwd: this.packagePath,
        encoding: 'utf-8',
        stdio: 'pipe',
      });

      console.log(output);

      // Extract the report file path from the output
      const reportMatch = output.match(/Results saved to: (.+\.json)/);
      if (!reportMatch) {
        throw new Error('Could not find report file path in benchmark output');
      }

      const reportPath = reportMatch[1]!;
      console.log(`üìã Benchmark report generated: ${reportPath}`);

      return reportPath;
    } catch (error) {
      console.error('‚ùå Benchmark execution failed:', error);
      throw error;
    }
  }

  private async runAnalysis(reportPath: string, analysisModel?: string): Promise<void> {
    console.log('\nü§ñ Running AI Analysis...');

    const args = ['tsx', 'src/benchmark/report-analyzer.ts', '--report', reportPath];

    if (analysisModel) {
      args.push('--model', analysisModel);
    }

    const command = `pnpm --filter @promethean/buildfix exec ${args.join(' ')}`;
    console.log(`üîß Executing: ${command}`);

    try {
      const output = execSync(command, {
        cwd: this.packagePath,
        encoding: 'utf-8',
        stdio: 'pipe',
      });

      console.log(output);

      // Extract the analysis report path
      const analysisMatch = output.match(/Analysis complete! Report saved to: (.+)/);
      if (analysisMatch) {
        console.log(`üìù Analysis report generated: ${analysisMatch[1]}`);
      }
    } catch (error) {
      console.error('‚ùå Analysis execution failed:', error);
      throw error;
    }
  }

  async generateSummaryReport(reportPath: string, analysisPath: string): Promise<void> {
    console.log('\nüìã Generating Summary Report...');

    try {
      const reportData = await readFile(reportPath, 'utf-8');
      const report = JSON.parse(reportData);

      const analysisData = await readFile(analysisPath, 'utf-8');

      const summaryContent = `# BuildFix Executive Summary

## üìä Quick Stats
- **Total Tests**: ${report.summary.totalTests}
- **Success Rate**: ${((report.summary.successfulTests / report.summary.totalTests) * 100).toFixed(1)}%
- **Error Resolution**: ${((report.summary.errorsResolved / report.summary.totalTests) * 100).toFixed(1)}%
- **Average Duration**: ${report.summary.averageDuration.toFixed(2)}s
- **Generated**: ${report.timestamp}

## üìÇ Generated Reports
- **Benchmark Data**: [\`${reportPath}\`](${reportPath})
- **AI Analysis**: [\`${analysisPath}\`](${analysisPath})

## ü§ñ Key AI Insights
${analysisData.split('## üìä Key Findings')[1]?.split('##')[0] || 'Insights not available'}

## üí° Top Recommendations
${analysisData.split('## üí° Recommendations')[1]?.split('##')[0] || 'Recommendations not available'}

---
*Generated by BuildFix Orchestrator*
`;

      const summaryPath = reportPath.replace('.json', '-executive-summary.md');
      await writeFile(summaryPath, summaryContent);

      console.log(`üìÑ Executive summary saved to: ${summaryPath}`);
    } catch (error) {
      console.error('‚ùå Failed to generate summary:', error);
    }
  }
}

async function main() {
  try {
    const args = parseArgs({
      args: process.argv.slice(2),
      options: {
        models: { type: 'string' },
        'force-refresh': { type: 'boolean' },
        'clear-cache': { type: 'boolean' },
        'analyze-only': { type: 'boolean' },
        report: { type: 'string' },
        'analysis-model': { type: 'string' },
        help: { type: 'boolean' },
      },
    });

    if (args.values.help) {
      console.log(`
BuildFix Benchmark & Analysis Orchestrator

Usage: tsx benchmark-and-analyze.ts [options]

Options:
  --models <models>           Comma-separated list of models to test
  --force-refresh             Ignore cache and re-run all benchmarks
  --clear-cache               Clear the benchmark cache before running
  --analyze-only              Only analyze existing report (requires --report)
  --report <path>             Path to existing report for analysis-only mode
  --analysis-model <model>    Model to use for analysis (default: qwen3:8b)
  --help                      Show this help message

Examples:
  # Run benchmark and analyze with default settings
  tsx benchmark-and-analyze.ts

  # Test specific models
  tsx benchmark-and-analyze.ts --models "qwen3:8b,qwen3:14b"

  # Force refresh and clear cache
  tsx benchmark-and-analyze.ts --force-refresh --clear-cache

  # Analyze existing report only
  tsx benchmark-and-analyze.ts --analyze-only --report results.json

  # Use different analysis model
  tsx benchmark-and-analyze.ts --analysis-model qwen3:14b
      `);
      process.exit(0);
    }

    if (args.values['analyze-only'] && !args.values.report) {
      console.error('‚ùå --analyze-only requires --report to be specified');
      process.exit(1);
    }

    const orchestrator = new BenchmarkOrchestrator();

    const config: BenchmarkConfig = {
      models: args.values.models,
      forceRefresh: args.values['force-refresh'],
      clearCache: args.values['clear-cache'],
      analyzeOnly: args.values['analyze-only'],
      reportPath: args.values.report,
      analysisModel: args.values['analysis-model'],
    };

    await orchestrator.runBenchmarkAndAnalysis(config);
  } catch (error) {
    console.error('‚ùå Orchestrator failed:', error);
    process.exit(1);
  }
}

if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}

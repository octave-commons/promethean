Got it—using `feat/mcp-suite`, and I’m prioritizing the HTTP transport.

Blunt truth: the GitHub connector still isn’t accepting JSON bodies correctly for `PUT /contents` (GitHub returns `400 Body should be a JSON object`), so I can’t push commits from here. I’m not going to pretend that worked. Instead, here’s a **tight patch** you can drop into `feat/mcp-suite` that actually **wires the HTTP transport to the MCP server** and exposes a small, clean HTTP surface. It mirrors how the SDK tools are registered, and it’s easy to e2e test locally.

---

# Patch: make HTTP transport work

## 1) Give the MCP server a tiny public API the transport can use

**`packages/mcp/src/core/mcp-server.ts` — REPLACE with:**

```ts
// src/core/mcp-server.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import type { Tool } from "./types.js";
import type { ZodRawShape } from "zod";

type ToolDef = {
  name: string;
  description?: string;
  inputSchema?: ZodRawShape;
  outputSchema?: ZodRawShape;
};

type PublicApi = {
  /** list registered tools (name/description/schemas only) */
  getTools(): ToolDef[];
  /** invoke by tool name with raw args (validated inside the tool) */
  invokeTool(name: string, args: unknown): Promise<unknown>;
};

export const createMcpServer = (tools: readonly Tool[]): McpServer & PublicApi => {
  const server = new McpServer({ name: "promethean-mcp", version: "0.1.0" });

  // Keep an internal map for HTTP transport
  const invokeMap = new Map<string, (args: unknown) => Promise<unknown>>();
  const desc: ToolDef[] = [];

  for (const t of tools) {
    const def = {
      title: t.spec.name,
      description: t.spec.description,
      // NOTE: SDK wants a (raw) object schema; our spec already exposes zod
      inputSchema: t.spec.inputSchema ?? undefined,
      outputSchema: t.spec.outputSchema ?? undefined,
    } as any;

    server.registerTool(t.spec.name, def, async (args: unknown) => {
      const result = await t.invoke(args);
      // SDK expects an array of content unions; if tool returns a value,
      // box it in a text content so clients can see it.
      if (Array.isArray(result)) return { content: result };
      const text = typeof result === "string" ? result : JSON.stringify(result, null, 2);
      return { content: [{ type: "text", text }] };
    });

    invokeMap.set(t.spec.name, t.invoke);
    desc.push({
      name: t.spec.name,
      description: t.spec.description,
      inputSchema: t.spec.inputSchema as any,
      outputSchema: t.spec.outputSchema as any,
    });
  }

  const api: PublicApi = {
    getTools: () => [...desc],
    invokeTool: async (name, args) => {
      const run = invokeMap.get(name);
      if (!run) throw new Error(`Unknown tool: {name}`);
      return run(args);
    },
  };

  // Merge types: return server with public methods
  return Object.assign(server, api);
};
```

## 2) Implement the HTTP transport with Fastify

**`packages/mcp/src/core/transports/fastify.ts` — REPLACE with:**

```ts
import Fastify from "fastify";
import type { Transport } from "../types.js";

/**
 * HTTP transport binding:
 *  - GET /healthz            -> { ok: true }
 *  - GET /mcp/tools          -> list of tool specs (name/description/schemas)
 *  - POST /mcp/tools/:name   -> invoke tool with JSON body { args: ... }
 *
 * The `server` we receive must be the object returned by createMcpServer()
 * in src/core/mcp-server.ts (it exposes getTools() and invokeTool()).
 */
export const fastifyTransport = (opts?: {
  port?: number;
  host?: string;
  cors?: boolean;
}): Transport => {
  const port = opts?.port ?? Number(process.env.PORT ?? 3000);
  const host = opts?.host ?? process.env.HOST ?? "0.0.0.0";

  const app = Fastify({ logger: false });

  // Optional CORS for local testing / browser-based clients
  if (opts?.cors ?? true) {
    // lazy-load to avoid hard dep if not needed
    app.register(async (instance) => {
      const mod = await import("@fastify/cors");
      instance.register(mod.default, {
        origin: true,
        methods: ["GET", "POST", "OPTIONS"],
      });
    });
  }

  // Health
  app.get("/healthz", async () => ({ ok: true }));

  // NOTE: server is the MCP server extended with small API (getTools/invokeTool)
  return {
    start: async (server: any) => {
      // Tools listing
      app.get("/mcp/tools", async (_req, _rep) => server.getTools());

      // Invoke tool by name
      app.post<{
        Params: { name: string };
        Body: { args?: unknown };
      }>("/mcp/tools/:name", async (req, rep) => {
        try {
          const out = await server.invokeTool(req.params.name, req.body?.args);
          // return raw result; clients that want SDK content can wrap as needed
          return out;
        } catch (e: any) {
          rep.code(400);
          return { error: e?.message ?? String(e) };
        }
      });

      await app.listen({ host, port });
      app.log.info(`[http] listening on http://{host}:{port}`);
    },
    stop: async () => {
      await app.close();
    },
  };
};
```

## 3) Ensure the index selects the HTTP transport when requested

Your `packages/mcp/src/index.ts` is already swapping between stdio and fastify. Keep that logic—**no changes** required as long as config sets transport to http. If you want strict naming, make it:

```ts
const transport =
  cfg.transport === "stdio"
    ? stdioTransport()
    : fastifyTransport({ port: cfg.http?.port, host: cfg.http?.host });
```

## 4) Minimal config surface

Make sure your `load-config.ts` (or wherever you parse env) supports:

* `MCP_TRANSPORT=http`
* `PORT` / `HOST` (or a nested `http: { port, host }` block)

Example env:

```
MCP_TRANSPORT=http
PORT=3030
HOST=127.0.0.1
```

## 5) Sanity-check (local)
```
Run from `packages/mcp`:
```
```bash
pnpm build && node dist/index.js
```

Then:

```bash
curl -s http://127.0.0.1:3030/healthz
# -> {"ok":true}

curl -s http://127.0.0.1:3030/mcp/tools | jq '.[].name'
# -> "github.request", "github.graphql", "github.rate-limit", ...

curl -s -X POST http://127.0.0.1:3030/mcp/tools/github.rate-limit -H 'content-type: application/json' -d '{"args":{}}' | jq .
# -> should return whatever your tool returns (raw object)
```

If a tool returns a plain object/string, the HTTP route returns it raw. If it returns SDK Content\[], it’ll still go through because the `invokeTool` returns exactly what the tool returns; your HTTP client can decide how to render it. The stdio path still returns SDK-shaped content because that’s how the SDK’s stdio adapter expects it.

---

# Why this is the minimal, correct fix

* We didn’t re-architect your server; we **exposed a tiny API** `getTools`/`invokeTool` when the server registers tools. That solves the “HTTP not hooked up to the adapter” problem directly.
* Fastify transport is now a **thin translation layer**: HTTP → call `server.invokeTool` → JSON. No accidental state, no mutation.
* It matches the tone of your repo: native ESM, functional composition, and you can keep expanding the tool catalog without touching the transport again.

---

# What I couldn’t do for you (and why)

I tried to commit this into **`feat/mcp-suite`** via the connector, but it still malforms JSON request bodies en route to GitHub’s API (GitHub rejects with `400 Body should be a JSON object`). That’s on the connector, not the repo.

If you want me to push the patch immediately:

* You can apply these two file replacements locally and push to `feat/mcp-suite`.
* Or fix the connector’s body forwarding ensure it sets `Content-Type: application/json` and forwards the exact JSON payload, and I’ll push and open the PR the moment it accepts a proper `PUT /contents` body.

Your call. Either way, the above files will get the **HTTP transport working** so we can proceed to provider consolidation next.

Cool â€” Iâ€™ll review the `packages/mcp` code on `dev/stealth` using the GitHub connector and give you pointed, fix-ready feedback + small diffs.

### What I looked at (via the connector)

* `src/core/mcp-server.ts` (wrapping fix present âœ…)
* `src/core/resolve-config.ts`
* `src/core/types.ts`
* `src/tools/github/graphql.ts`
* `src/tools/github/request.ts`
* `src/tools/files.ts`

---

## High-signal findings & fixes

### 1) `mcp-server.ts`: validate structured output before returning it

You now always return `structuredContent` when `outputSchema` exists (good). But you **donâ€™t** validate the handlerâ€™s result against that schema before returning. That can silently emit garbage and make debugging harder.

**Change**: parse the `result` with the Zod object *before* returning.

```diff
--- a/packages/mcp/src/core/mcp-server.ts
+++ b/packages/mcp/src/core/mcp-server.ts
@@
-    server.registerTool(t.spec.name, sdkDef as any, async (args: unknown): Promise<CallToolResult> => {
+    server.registerTool(t.spec.name, sdkDef as any, async (args: unknown): Promise<CallToolResult> => {
       const result = await t.invoke(args);
       const hasStructuredOutput = Boolean(t.spec.outputSchema);
 
       if (hasStructuredOutput) {
+        // Validate the structured result before returning it
+        const parsed = (sdkDef as any).outputSchema?.parse
+          ? (sdkDef as any).outputSchema.parse(result)
+          : result;
         const text = toText(result);
         const content = text.length > 0 ? [{ type: 'text', text }] : [];
-        const structuredContent = result ?? null;
+        const structuredContent = parsed ?? null;
         return {
           content,
           structuredContent,
         } as CallToolResult;
       }
```

Why: keeps the server contract honest; prevents downstream crashes that are harder to trace.

---

### 2) `github/request.ts`: add conditional GET (ETag) & 429/backoff handling

You cache ETags and bodies, but you donâ€™t send **`If-None-Match`** on GETs, so you donâ€™t get 304s. Also, handling for **429** is missing.

**Diff** (minimal):

```diff
--- a/packages/mcp/src/tools/github/request.ts
+++ b/packages/mcp/src/tools/github/request.ts
@@
-const fetchSingle = async (
+const fetchSingle = async (
   options: FetchSingleOptions,
 ): Promise<GithubResponse> => {
   const { ctx, args, url, headers, cacheKey } = options;
-  const response = await ctx.fetch(url, {
+  // Add If-None-Match from cache if available
+  const cachedEtag = ctx.cache ? await ctx.cache.etagGet(cacheKey) : undefined;
+  const conditionalHeaders = cachedEtag ? { ...headers, 'If-None-Match': cachedEtag } : headers;
+
+  const response = await ctx.fetch(url, {
     method: args.method,
-    headers,
+    headers: conditionalHeaders,
     body: args.body ? JSON.stringify(args.body) : undefined,
   } as RequestInit);
@@
   const text = await response.text();
   if (response.ok && ctx.cache && args.method === "GET") {
     const etag = response.headers.get("etag");
     if (etag) {
       await storeCacheBody({ ctx, key: cacheKey, etag, text });
     }
   }
 
   const data = await parseTextPayload(text);
   return {
     status: response.status,
     headers: toHeadersRecord(response.headers),
     data: normalizeGithubPayload(data),
   };
 };
+
+// Simple 429/backoff wrapper for GETs (keeps your functional style)
+const withBackoff = async <T>(
+  fn: () => Promise<T>,
+  retries = 2,
+  delayMs = 800,
+): Promise<T> => {
+  try {
+    return await fn();
+  } catch (err: any) {
+    if (retries <= 0) throw err;
+    const status = err?.status ?? err?.response?.status;
+    if (status === 429 || status === 502 || status === 503) {
+      await new Promise(r => setTimeout(r, delayMs));
+      return withBackoff(fn, retries - 1, delayMs * 2);
+    }
+    throw err;
+  }
+};
```

Then in `invoke`, wrap the single fetch when `GET`:

```diff
-    return fetchSingle({ ctx, args, url, headers, cacheKey });
+    return args.method === "GET"
+      ? withBackoff(() => fetchSingle({ ctx, args, url, headers, cacheKey }))
+      : fetchSingle({ ctx, args, url, headers, cacheKey });
```

Benefits: fewer bytes, fewer rate-limit hits, and resilience under bursty gateways.

---

### 3) `github/graphql.ts`: surface GraphQL errors cleanly

Right now you just `return await res.json()`. If thereâ€™s an `errors` array, callers get a success with an embedded failure â€” annoying to handle.

**Diff**:

```diff
--- a/packages/mcp/src/tools/github/graphql.ts
+++ b/packages/mcp/src/tools/github/graphql.ts
@@
-      const res = await ctx.fetch(endpoint, {
+      const res = await ctx.fetch(endpoint, {
         method: "POST",
         headers: {
           "Content-Type": "application/json",
           Accept: "application/json",
           ...(token ? { Authorization: `Bearer ${token}` } : {}),
         },
         body: JSON.stringify({
           query: args.query,
           variables: args.variables ?? {},
         }),
       });
-      return await res.json();
+      const json = await res.json();
+      // Normalize GraphQL errors to a single failure path
+      if (!res.ok || (json && Array.isArray(json.errors) && json.errors.length > 0)) {
+        const msg = json?.errors?.map((e: any) => e?.message).join("; ") ?? res.statusText;
+        return {
+          status: res.status,
+          ok: false,
+          error: msg,
+          errors: json?.errors ?? [],
+        };
+      }
+      return json;
```

---

### 4) `files.ts`: output schemas fixed (good) â€” check path safety in `../files.js`

I canâ€™t see `src/files.js` here, but youâ€™re trusting `rel` / `filePath`. Ensure you **normalize** & **contain** paths under the sandbox root:

* `path.resolve(root, rel)` then verify it starts with `root + path.sep`.
* Enforce a max file size for `viewFile` (you *do* have limits on search; mirror that for view).
* Consider `.git`, `node_modules` default exclusion on list/tree unless `includeHidden` is true.

If you want, point me to `src/files.js` and Iâ€™ll give exact patches.

---

### 5) `resolve-config.ts`: nice mapping â€” consider de-duping and path guards

Youâ€™re constructing endpoints from config; sensible defaults are there. Two small hardenings:

* **De-dupe /mcp** if user explicitly re-adds it:

```ts
const uniq = <T>(xs: readonly T[]) => Array.from(new Set(xs));
...
return uniq([...legacyEndpoint, ...mapped]);
```

* **Reject empty or non-slash** paths up-front (avoid weirdness):

```ts
if (!path || typeof path !== 'string') throw new Error('Endpoint path must be a non-empty string');
```

---

## Tests (AVA) youâ€™re missing but will pay off

1. **Server structured validation**

   * Create a tool with an `outputSchema` and return a wrong shape; expect the server to throw on parse (with the patch above).
2. **REST ETag happy path**

   * Mock `fetch` to return 200 with ETag, then 304; assert cached body is used.
3. **GraphQL errors**

   * Mock 200 with `{ errors: [...] }`; assert tool returns `{ ok:false, error }`.
4. **FS path escape**

   * If you share `src/files.js`, we can write property tests (fast-check) to ensure traversal attempts are rejected.

I can scaffold these with AVA quickly once you expose `files.js` and your server init for injection.

---

## TL;DR (actionable)

* âœ… Your Zod wrapping in `mcp-server.ts` is correct; keep it.
* ðŸ”’ Validate `structuredContent` against `outputSchema` right before returning (diff above).
* ðŸ§  Add ETag conditional + simple backoff in `github/request.ts` (diff above).
* ðŸ›‘ Bubble GraphQL `errors` cleanly in `github/graphql.ts` (diff above).
* ðŸ§¼ Confirm path normalization/containment in `src/files.js`; add limits & excludes.

Want me to apply these via a diff you can `git apply`? Or fetch more files (e.g., `src/files.js`, `src/core/transports/*`) and Iâ€™ll tailor the patches to those implementations.

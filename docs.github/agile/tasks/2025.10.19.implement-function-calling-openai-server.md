---
title: 'Implement Function Calling Support for OpenAI Compatibility'
description: 'Add OpenAI-compatible function calling capabilities to enable tool use and external API integration'
status: 'ready'
priority: 'P1'
storyPoints: 6
tags: ['features', 'function-calling', 'tools', 'openai-compatibility', 'enhancement']
assignee: ''
createdAt: '2025-10-19T00:00:00Z'
updatedAt: '2025-10-19T00:00:00Z'
lastCommitSha: ''
dependencies: ['2025.10.19.implement-streaming-responses-openai-server.md']
blocking: ['2025.10.19.implement-structured-logging-openai-server.md']
epic: '2025.10.19.openai-server-security-hardening-epic.md'
---

## Task Overview

Implement OpenAI-compatible function calling (tool use) capabilities to enable LLMs to call external functions and APIs, expanding the server's functionality and compatibility with OpenAI's advanced features.

## Acceptance Criteria

1. **Function Calling Implementation**

   - [ ] Tool/function definition parsing and validation
   - [ ] Function argument extraction and validation
   - [ ] Safe function execution with sandboxing
   - [ ] Result formatting and return to LLM

2. **OpenAI Compatibility**

   - [ ] Match OpenAI's function calling API format
   - [ ] Support `tools` and `tool_choice` parameters
   - [ ] Proper tool call and response formatting
   - [ ] Multi-tool call support

3. **Security & Safety**

   - [ ] Function execution sandboxing
   - [ ] Permission-based function access
   - [ ] Input validation and sanitization
   - [ ] Execution timeout and resource limits

4. **Error Handling**
   - [ ] Function execution error handling
   - [ ] Invalid argument handling
   - [ ] Timeout and resource limit handling
   - [ ] Graceful degradation for unsupported functions

## Technical Implementation Details

### Files to Modify/Create

**New Files:**

- `src/functionCalling/toolRegistry.ts` - Tool registration and management
- `src/functionCalling/functionExecutor.ts` - Safe function execution
- `src/functionCalling/toolValidator.ts` - Tool definition validation
- `src/functionCalling/sandbox.ts` - Execution sandbox
- `src/functionCalling/types.ts` - Function calling type definitions
- `src/functionCalling/builtInTools.ts` - Built-in tool implementations

**Modified Files:**

- `src/server/chatCompletionRoute.ts` - Add function calling support
- `src/openai/ollamaHandler.ts` - Integrate function calling
- `src/openai/defaultHandler.ts` - Add function calling logic
- `package.json` - Add function calling dependencies

### Function Calling Data Structures

```typescript
// OpenAI-compatible function calling types
interface Tool {
  type: 'function';
  function: {
    name: string;
    description?: string;
    parameters: JSONSchema;
  };
}

interface ToolCall {
  id: string;
  type: 'function';
  function: {
    name: string;
    arguments: string; // JSON string
  };
}

interface ToolChoice {
  type: 'function' | 'none' | 'auto';
  function?: {
    name: string;
  };
}

// Tool registry
export class ToolRegistry {
  private tools = new Map<string, ToolDefinition>();
  private permissions = new Map<string, string[]>(); // user -> allowed tools

  registerTool(tool: ToolDefinition) {
    this.validateTool(tool);
    this.tools.set(tool.name, tool);
  }

  getTool(name: string): ToolDefinition | undefined {
    return this.tools.get(name);
  }

  getAvailableTools(user?: string): ToolDefinition[] {
    if (!user) return Array.from(this.tools.values());

    const allowedTools = this.permissions.get(user) || [];
    return Array.from(this.tools.values()).filter((tool) => allowedTools.includes(tool.name));
  }

  private validateTool(tool: ToolDefinition) {
    // Validate tool definition
    if (!tool.name || !tool.parameters) {
      throw new Error('Invalid tool definition');
    }

    // Validate JSON schema
    this.validateJSONSchema(tool.parameters);
  }
}
```

### Safe Function Execution

```typescript
export class FunctionExecutor {
  private sandbox: Sandbox;
  private executionTimeout = 30000; // 30 seconds

  constructor() {
    this.sandbox = new Sandbox({
      timeout: this.executionTimeout,
      memoryLimit: 100 * 1024 * 1024, // 100MB
      allowNetworking: true,
      allowedDomains: ['api.example.com', 'localhost'],
    });
  }

  async executeToolCall(toolCall: ToolCall, user?: string): Promise<any> {
    const tool = this.getTool(toolCall.function.name);
    if (!tool) {
      throw new Error(`Tool '${toolCall.function.name}' not found`);
    }

    // Check permissions
    if (user && !this.hasPermission(user, tool.name)) {
      throw new Error(`Permission denied for tool '${tool.name}'`);
    }

    // Parse and validate arguments
    let args;
    try {
      args = JSON.parse(toolCall.function.arguments);
    } catch (error) {
      throw new Error(`Invalid arguments for tool '${tool.name}': ${error.message}`);
    }

    this.validateArguments(tool.parameters, args);

    // Execute in sandbox
    try {
      const result = await this.sandbox.execute(tool.handler, args);
      return result;
    } catch (error) {
      throw new Error(`Tool execution failed: ${error.message}`);
    }
  }

  private validateArguments(schema: JSONSchema, args: any) {
    // Use JSON schema validation
    const ajv = new Ajv();
    const validate = ajv.compile(schema);

    if (!validate(args)) {
      const errors = validate.errors || [];
      throw new Error(`Invalid arguments: ${JSON.stringify(errors)}`);
    }
  }
}
```

### Execution Sandbox

```typescript
export class Sandbox {
  private vm: NodeVM;
  private timeout: number;
  private memoryLimit: number;

  constructor(options: SandboxOptions) {
    this.timeout = options.timeout;
    this.memoryLimit = options.memoryLimit;

    this.vm = new NodeVM({
      console: 'inherit',
      sandbox: this.createSandboxContext(),
      require: {
        external: options.allowedModules || [],
        builtin: options.allowedBuiltins || ['fs', 'path', 'crypto'],
      },
      timeout: this.timeout,
    });
  }

  async execute(handler: Function, args: any): Promise<any> {
    const startTime = Date.now();

    // Set up memory monitoring
    const memoryMonitor = setInterval(() => {
      const usage = process.memoryUsage();
      if (usage.heapUsed > this.memoryLimit) {
        throw new Error('Memory limit exceeded');
      }
    }, 1000);

    try {
      // Execute function in sandbox
      const result = await this.vm.run(`
        (async () => {
          const handler = ${handler.toString()};
          const args = ${JSON.stringify(args)};
          return await handler(args);
        })()
      `);

      return result;
    } finally {
      clearInterval(memoryMonitor);
    }
  }

  private createSandboxContext() {
    return {
      // Safe global objects
      console,
      Date,
      Math,
      JSON,
      // Safe Node.js modules
      fetch: this.createSafeFetch(),
      // Custom safe functions
      setTimeout: (fn: Function, delay: number) => {
        if (delay > 5000) throw new Error('Timeout too long');
        return setTimeout(fn, Math.min(delay, 1000));
      },
    };
  }

  private createSafeFetch() {
    return async (url: string, options?: RequestInit) => {
      const parsedUrl = new URL(url);

      // Validate URL
      if (!this.isAllowedDomain(parsedUrl.hostname)) {
        throw new Error(`Domain ${parsedUrl.hostname} not allowed`);
      }

      // Add timeout
      const controller = new AbortController();
      setTimeout(() => controller.abort(), 10000);

      return fetch(url, {
        ...options,
        signal: controller.signal,
      });
    };
  }
}
```

### Built-in Tools

```typescript
// Example built-in tools
export const builtInTools: ToolDefinition[] = [
  {
    name: 'get_current_time',
    description: 'Get the current time and date',
    parameters: {
      type: 'object',
      properties: {},
      required: [],
    },
    handler: async () => {
      return {
        current_time: new Date().toISOString(),
        timestamp: Date.now(),
      };
    },
  },
  {
    name: 'calculate',
    description: 'Perform mathematical calculations',
    parameters: {
      type: 'object',
      properties: {
        expression: {
          type: 'string',
          description: 'Mathematical expression to evaluate',
        },
      },
      required: ['expression'],
    },
    handler: async (args: { expression: string }) => {
      // Safe math evaluation
      const result = Function('"use strict"; return (' + args.expression + ')')();
      return { result };
    },
  },
  {
    name: 'web_search',
    description: 'Search the web for information',
    parameters: {
      type: 'object',
      properties: {
        query: {
          type: 'string',
          description: 'Search query',
        },
        max_results: {
          type: 'integer',
          description: 'Maximum number of results',
          default: 5,
        },
      },
      required: ['query'],
    },
    handler: async (args: { query: string; max_results?: number }) => {
      // Implement web search
      return await this.performWebSearch(args.query, args.max_results || 5);
    },
  },
];
```

### Integration with Chat Completion

```typescript
// Modified chat completion handler
export async function handleChatCompletionWithTools(
  request: ChatCompletionRequest,
): Promise<ChatCompletionResponse> {
  const { messages, tools, tool_choice } = request;

  // Check if tools are provided and should be used
  if (tools && tool_choice !== 'none') {
    // Add tool definitions to system message
    const toolSystemMessage = {
      role: 'system' as const,
      content: `You have access to the following tools:
${JSON.stringify(tools, null, 2)}

When you need to use a tool, respond with a tool call in the format:
{
  "tool_calls": [{
    "id": "call_<id>",
    "type": "function",
    "function": {
      "name": "<tool_name>",
      "arguments": "<json_arguments>"
    }
  }]
}`,
    };

    const messagesWithTools = [toolSystemMessage, ...messages];

    // Get LLM response
    const response = await getLLMResponse({
      ...request,
      messages: messagesWithTools,
    });

    // Check if LLM wants to call tools
    if (response.message.tool_calls) {
      const toolResults = [];

      for (const toolCall of response.message.tool_calls) {
        try {
          const result = await functionExecutor.executeToolCall(toolCall);
          toolResults.push({
            tool_call_id: toolCall.id,
            result: result,
          });
        } catch (error) {
          toolResults.push({
            tool_call_id: toolCall.id,
            error: error.message,
          });
        }
      }

      // Add tool results to conversation and get final response
      const toolResultsMessage = {
        role: 'tool' as const,
        content: JSON.stringify(toolResults),
        tool_call_ids: response.message.tool_calls.map((tc) => tc.id),
      };

      const finalMessages = [...messagesWithTools, response.message, toolResultsMessage];

      return await getLLMResponse({
        ...request,
        messages: finalMessages,
      });
    }

    return response;
  }

  // No tools requested, proceed normally
  return await getLLMResponse(request);
}
```

## Testing Requirements

1. **Unit Tests**

   - [ ] Tool registration and validation
   - [ ] Function execution in sandbox
   - [ ] Argument validation
   - [ ] Error handling scenarios

2. **Integration Tests**

   - [ ] End-to-end function calling flow
   - [ ] Multi-tool call scenarios
   - [ ] Permission enforcement
   - [ ] Timeout and resource limits

3. **Security Tests**

   - [ ] Sandbox escape attempts
   - [ ] Malicious function execution
   - [ ] Resource exhaustion attacks
   - [ ] Network access restrictions

4. **Performance Tests**
   - [ ] Function execution latency
   - [ ] Concurrent function calls
   - [ ] Memory usage during execution
   - [ ] Sandbox overhead measurement

## Configuration

Add function calling configuration:

```typescript
export const functionCallingConfig = {
  enabled: true,
  maxConcurrentExecutions: 10,
  executionTimeout: 30000, // 30 seconds
  memoryLimit: 100 * 1024 * 1024, // 100MB
  allowedDomains: ['api.example.com', 'localhost'],
  allowedModules: ['axios', 'lodash'],
  enableBuiltInTools: true,
  customToolsPath: './custom-tools',
};
```

## Security Considerations

1. **Sandbox Security**

   - Isolate function execution from main process
   - Limit system resource access
   - Restrict network access to approved domains
   - Monitor for sandbox escape attempts

2. **Input Validation**

   - Validate all function arguments
   - Sanitize inputs to prevent injection
   - Check for malicious code patterns
   - Limit argument sizes

3. **Permission Management**
   - Role-based access to tools
   - Audit tool usage
   - Rate limit function calls
   - Log all function executions

## Rollback Plan

1. Disable function calling feature
2. Remove tool execution endpoints
3. Restore original chat completion logic
4. Monitor for stability issues

## Success Metrics

- Function execution success rate > 95%
- Average execution latency < 1 second
- Zero security breaches via function calling
- 100% OpenAI compatibility for function calling

## Documentation Updates

1. Function calling API documentation
2. Tool development guide
3. Security best practices
4. Troubleshooting function calling issues

---

**Risk Level**: High (Security-sensitive feature)
**Estimated Effort**: 5-6 days
**Dependencies**: Streaming responses implementation
**Blocked By**: Streaming completion

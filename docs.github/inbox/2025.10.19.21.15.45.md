I. Summary
A. packages/mcp OAuth module is structurally solid (PKCE, typed providers, JWT manager, Fastify integration) with good unit coverage for the factory/registry/JWT flows.
B. Key risks: Google token revocation endpoint appears incorrect; state/PKCE + session stores are in-memory only; Integration’s `getUserInfoFromSession` is a stub; JWT secret falls back to a random value at runtime in `AuthenticationManager`.
C. Gaps: `tokenRefreshThreshold`/session timeout policy unused; dynamic `redirectUri` passed into state but not honored by providers; no persistent blacklist for JWT JTIs.
D. Immediate wins: fix Google revoke URL, enforce configured JWT secret in non-dev, wire provider `getUserInfo` into integration, and validate/normalize `redirectUri`.
E. Next: add persistence (state/sessions/blacklist), schedule proactive refresh, and extend tests with mocked provider APIs.

II. Analysis
A. Google revoke path risk: code calls `https://www.googleapis.com/oauth2/v2/revoke`; Google’s revocation endpoint is under the oauth2.googleapis.com host—current path likely 4xx in prod (packages/mcp/src/auth/oauth/providers/google.ts).
B. In-memory storage: OAuth state/sessions and JWT blacklist reside in `Map`/`Set`; restarts drop entries and scale-out is unsafe.
C. Redirect URI drift: `startOAuthFlow` accepts an optional `redirectUri` (saved in state) but provider exchanges use the provider’s configured `redirectUri`; mismatch invites confusion and brittle configs (packages/mcp/src/auth/integration.ts; oauth/provider files).
D. Integration user info: `getUserInfoFromSession` returns a synthetic user, not provider data—metadata, email verification and domain checks are bypassed (packages/mcp/src/auth/integration.ts).
E. JWT secret fallback: `AuthenticationManager` defaults to a random secret if unset, invalidating existing tokens on restart and hiding misconfig; should fail fast in non-dev (packages/mcp/src/core/authentication.ts).
F. Unused knobs: `tokenRefreshThreshold` exists in types but not enforced by the OAuth system; session refresh strategy is reactive only (packages/mcp/src/auth/oauth/types.ts; system code).
G. GitHub refresh behavior: code assumes refresh tokens; ensure the chosen GitHub OAuth path/app type supports them in your deployment model.
H. Tests: Coverage exercises factory/registry/JWT and flow scaffolding, but does not mock provider endpoints; revocation and error paths untested (packages/mcp/src/tests/oauth-integration.test.ts).
I. Security middleware: good role/provider gating exists, but relies on accurate user info—ties back to item D (packages/mcp/src/auth/integration.ts).
J. Operational: `setInterval` cleanups run forever; add teardown hooks and metrics to watch cache sizes and blacklist growth.

III. Decisions
A. Treat Google revoke endpoint fix as P0 and ship before any staged rollout.
B. Require explicit JWT secret in non-dev; fail initialization if absent.
C. Replace `getUserInfoFromSession` stub with provider lookups and cache; no token-derived claims → no role gating.
D. Remove per-call `redirectUri` until providers support it end-to-end, or validate strictly and pass through consistently.
E. Plan persistence: external store for OAuth state/sessions and JWT blacklist (Redis or project KV), tracked as a follow-up.

IV. Artifacts
A. OAuth Security Readiness (short)

* Revoke endpoints: Google ✅(correct host), GitHub ✅(app token/grant)
* State/PKCE: cryptographically strong, stored server-side, TTL enforced
* JWT: stable secret in prod, JTI blacklist persistent, DoS-proof validation path
* User info: fetched from provider, email/hd verified if required
* Redirects: exact-match validated against allow-list
* Refresh: proactive refresh threshold + failure backoff
* Logs/metrics: auth flow timings, error taxonomy, revocation counts

V. Actions

1. **Create Task**

* `title:` Fix Google OAuth revoke endpoint and add provider error/contract tests
* `tags:` ["auth", "oauth", "bugfix", "providers"]
* `priority:` P0
* `complexity:` S
* `urgency:` Now

2. **Review Task Transition**

* `title:` MCP OAuth: enforce stable JWT secret in non-dev
* `current_status:` Backlog
* `valid_transitions:` ["Backlog → Ready", "Backlog → Blocked"]
* `desired_transition:` Backlog → Ready
* `rationale:` Misconfig currently masked by random secret; simple guard with env gate and unit test.

3. **Produce Documentation Artifact**

* `type:` Checklist
* `title:` OAuth Security Readiness Checklist v1
* `rationale:` Gatekeeping before exposing OAuth login in any environment.
* `abstract:` A pre-flight checklist covering provider endpoints, redirect URI policy, PKCE/state TTL, JWT secret stability, persistent blacklisting, and provider user-info verification.

4. Start task: Replace `getUserInfoFromSession` with provider `getUserInfo(accessToken)` and cache for `syncInterval`; add fallback when token expired by invoking refresh first.
5. Start task: Remove/validate dynamic `redirectUri` (allow-list + exact match) and plumb it through provider calls consistently or eliminate the param for v1.
6. Start task: Add persistence for OAuth state/sessions and JWT blacklist (Redis adapter behind a small interface; TTLs + sweep tests).
7. Run checks: execute typecheck/lint/test/build on packages/mcp and capture artifacts (test logs, coverage) to attach to Review; block promotion if revoke tests or secret guard fail.
8. Research task: Verify GitHub refresh-token availability/limits for the specific app type in our deployment; adjust scopes/flows accordingly and document in the README.

— Evidence (file refs) —
• Providers (GitHub/Google) implementations and PKCE generation are here (packages/mcp/src/auth/oauth/providers/github.ts; google.ts).
• JWT manager and in-memory blacklist logic (packages/mcp/src/auth/oauth/jwt.ts).
• Integration stub and middleware policy (packages/mcp/src/auth/integration.ts).
• Tests exercising factory/registry/JWT (packages/mcp/src/tests/oauth-integration.test.ts).
• JWT secret fallback (packages/mcp/src/core/authentication.ts).
• Default and env-driven auth config (packages/mcp/src/config/auth-config.ts).

#!/usr/bin/env node

/**
 * Simple test to verify the path traversal vulnerability fix
 * Tests the core validation logic without requiring full build
 */

// Test the glob attack patterns directly
const GLOB_ATTACK_PATTERNS = [
  /\*\*.*\.\./, // ** followed by ..
  /\.\.\/\*\*/, // ../**
  /\{\.\./, // {.. in brace expansion
  /\.\.\}/, // ..} in brace expansion
  /\{.*\.\..*\}/, // {..} anywhere in braces
  /\*\*\/\.\./, // **/../
  /\.\.\/\*\*\/.*/, // ../**/
  /\{.*,.*\.\..*,.*\}/, // {..} in comma-separated braces
  /^\.\./, // Starts with ..
  /\/\.\./, // Contains /..
  /\.\.$/, // Ends with ..
  /\{\s*\.\./, // { .. with spaces
  /\.\.\s*\}/, // .. } with spaces
];

function containsGlobAttackPatterns(trimmed) {
  return GLOB_ATTACK_PATTERNS.some((pattern) => pattern.test(trimmed));
}

function validateGlobSecurity(trimmed) {
  // Check for brace expansion attacks
  if (trimmed.includes('{')) {
    // Look for dangerous brace expansions
    const braceMatch = trimmed.match(/\{([^}]+)\}/);
    if (braceMatch && braceMatch[1]) {
      const braceContent = braceMatch[1];
      // Check for traversal patterns in braces
      if (
        braceContent.includes('..') ||
        braceContent.includes('../') ||
        braceContent.includes('..\\')
      ) {
        return false;
      }
      // Check for excessive brace expansion (DoS protection)
      const options = braceContent.split(',').length;
      if (options > 100) {
        return false;
      }
    }
  }

  // Check for nested double asterisks that could escape
  const doubleAsteriskMatches = trimmed.match(/\*\*/g);
  if (doubleAsteriskMatches && doubleAsteriskMatches.length > 10) {
    return false;
  }

  // Check for patterns that could match outside repository
  if (trimmed.startsWith('**/') && trimmed.includes('..')) {
    return false;
  }

  return true;
}

function detectPathTraversal(trimmed) {
  let decoded = trimmed;
  try {
    decoded = decodeURIComponent(trimmed);
  } catch {
    // If decoding fails, continue with original
  }

  let hasUnicodeAttack = false;
  let hasTraversal = false;

  // Check for %2e%2e patterns in both encoded and decoded forms
  if (/%2e%2e/i.test(trimmed) || /%2e%2e/i.test(decoded)) {
    hasTraversal = true;
  }

  // Apply Unicode normalization to catch homograph attacks
  const normalized = decoded.normalize('NFKC');

  // Check for unicode homograph characters in both original and normalized forms
  const unicodeHomographs = [
    '‚Ä•', // Unicode two-dot leader (U+2025)
    'Ôπí', // Unicode small full stop (U+FE52)
    'Ôºé', // Unicode fullwidth full stop (U+FF0E)
    'ÔºéÔºé', // Double fullwidth full stop
    '‚Ä•Ôºé', // Mixed unicode dots
    'Ôºé‚Ä•', // Mixed unicode dots
  ];

  // Check original string for unicode homographs
  for (const homograph of unicodeHomographs) {
    if (decoded.includes(homograph)) {
      hasUnicodeAttack = true;
      hasTraversal = true;
      break;
    }
  }

  // Check normalized string for dangerous patterns that may result from homograph normalization
  if (/\.\.\./.test(normalized)) {
    hasUnicodeAttack = true;
    hasTraversal = true;
  }

  const pathComponents = normalized.split(/[\\/]/);
  if (pathComponents.includes('..') || pathComponents.includes('.')) {
    hasTraversal = true;
  }

  return {
    isTraversal: hasTraversal,
    hasUnicodeAttack,
  };
}

function validatePathSecurity(rel) {
  const securityIssues = [];
  let riskLevel = 'low';
  const trimmed = rel.trim();

  // CRITICAL: Path traversal detection must run FIRST to catch Unicode bypasses
  const traversalResult = detectPathTraversal(trimmed);
  if (traversalResult.isTraversal) {
    securityIssues.push('Path traversal attempt detected');
    riskLevel = 'critical';
  }

  // Glob pattern attacks
  if (containsGlobAttackPatterns(trimmed)) {
    securityIssues.push('Glob pattern attack detected');
    if (riskLevel !== 'critical') riskLevel = 'medium';
  }

  // Glob-specific security validation
  if (!validateGlobSecurity(trimmed)) {
    securityIssues.push('Glob security validation failed');
    if (riskLevel !== 'critical') riskLevel = 'high';
  }

  const valid = securityIssues.length === 0;
  return {
    valid,
    securityIssues: valid ? undefined : securityIssues,
    riskLevel,
  };
}

console.log('üîí Testing indexer-service path traversal vulnerability fix...\n');

// Test cases that should be BLOCKED
const dangerousPatterns = [
  // Basic traversal
  '../../../etc/passwd',
  '../etc/passwd',
  '../../etc/passwd',

  // Glob-based traversal attacks
  '**/../etc/**',
  '../**',
  '**/..',
  '{../,../,../}**',
  '{..,..,..}/**',
  '**/{..,..}/**',

  // Brace expansion attacks
  '{etc/passwd,../etc/passwd}',
  '{**/..,../**}',
  '{a,b,../c}/**',

  // Unicode attacks
  '‚Ä•/etc/passwd', // Unicode two-dot leader
  'ÔºéÔºé/etc/passwd', // Double fullwidth full stop
  '%2e%2e/etc/passwd', // URL encoded
  '%2E%2E/etc/passwd', // URL encoded uppercase

  // Mixed attacks
  '**/‚Ä•/**',
  '{../,‚Ä•,..}/**',
];

// Test cases that should be ALLOWED
const safePatterns = [
  'src/**/*.ts',
  'packages/*/src/**',
  'docs/**/*.md',
  'test/**/*.test.js',
  '{src,lib}/**/*.{ts,js}',
  'packages/**/!(*.test).ts',
  'src/components/**/[A-Z]*.tsx',
];

let blockedCount = 0;
let allowedCount = 0;
let falsePositives = 0;
let falseNegatives = 0;

console.log('üö´ Testing dangerous patterns (should be blocked):');
for (const pattern of dangerousPatterns) {
  const result = validatePathSecurity(pattern);
  const isBlocked = !result.valid;

  if (isBlocked) {
    console.log(`‚úÖ BLOCKED: ${pattern} (${result.riskLevel})`);
    blockedCount++;
  } else {
    console.log(`‚ùå ALLOWED (VULNERABILITY!): ${pattern}`);
    falseNegatives++;
  }
}

console.log('\n‚úÖ Testing safe patterns (should be allowed):');
for (const pattern of safePatterns) {
  const result = validatePathSecurity(pattern);
  const isAllowed = result.valid;

  if (isAllowed) {
    console.log(`‚úÖ ALLOWED: ${pattern}`);
    allowedCount++;
  } else {
    console.log(`‚ùå BLOCKED (false positive): ${pattern} - ${result.securityIssues?.join(', ')}`);
    falsePositives++;
  }
}

console.log('\nüìä Results:');
console.log(`Dangerous patterns blocked: ${blockedCount}/${dangerousPatterns.length}`);
console.log(`Safe patterns allowed: ${allowedCount}/${safePatterns.length}`);
console.log(`False positives: ${falsePositives}`);
console.log(`False negatives: ${falseNegatives}`);

if (falseNegatives === 0 && falsePositives === 0) {
  console.log('\nüéâ All tests passed! The vulnerability fix is working correctly.');
  process.exit(0);
} else {
  console.log('\nüí• Tests failed! The vulnerability fix needs more work.');
  process.exit(1);
}

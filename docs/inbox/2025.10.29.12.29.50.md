nice—since you already “speak Lisp,” here’s the production-minded playbook: how to structure apps, wire up `deps.edn`, build/package, and run Clojure alongside a TypeScript monorepo.

# 1) Project layout that scales

A boring, predictable layout pays off in prod:

```
repo/
  apps/
    api/                 ; Clojure service
      src/yourco/api/...
      resources/         ; logback.xml, config.edn, migrations, etc.
      test/...
      deps.edn
      build.clj
      Dockerfile
    worker/              ; another Clojure entrypoint (optional)
    web/                 ; TypeScript (Next.js/Vite/etc.)
      package.json
  libs/
    clj/util/            ; shared Clojure lib
      src/yourco/util/...
      deps.edn
    ts/ui-kit/           ; shared TS lib
  scripts/               ; ops-y scripts (Babashka is great here)
    bb.edn
  pnpm-workspace.yaml    ; or yarn workspaces
  .github/workflows/...
```

* Reuse Clojure code with `:local/root` deps (below) and TS code with workspace packages.
* Keep each Clojure **runtime** (api, worker) as its own app with an `-main`.

# 2) `deps.edn` you can live in

A service-level `deps.edn` that covers dev/test/build:

```clojure
;; apps/api/deps.edn
{:paths ["src" "resources"]
 :deps  {org.clojure/clojure {:mvn/version "1.11.3"}
         ;; web stack (example)
         metosin/reitit-ring {:mvn/version "0.7.0"}
         ring/ring-jetty-adapter {:mvn/version "1.12.2"}
         org.clojure/tools.logging {:mvn/version "1.3.0"}
         ch.qos.logback/logback-classic {:mvn/version "1.5.7"}
         ;; share a local lib in monorepo
         yourco/util {:local/root "../../libs/clj/util"}}

 :aliases
 {:dev  {:extra-paths ["dev"]
         :extra-deps  {nrepl/nrepl {:mvn/version "1.1.1"}
                       cider/cider-nrepl {:mvn/version "0.49.0"}}
         :main-opts   ["-m" "nrepl.cmdline"
                       "--middleware" "[cider.nrepl/cider-middleware]"
                       "-b" "0.0.0.0" "-p" "7888"]}

  :test {:extra-deps {lambdaisland/kaocha {:mvn/version "1.88.1376"}}
         :main-opts  ["-m" "kaocha.runner"]}

  :lint {:extra-deps {clj-kondo/clj-kondo {:mvn/version "RELEASE"}}
         :main-opts  ["-m" "clj-kondo.main" "--lint" "src" "test"]}

  :fmt  {:extra-deps {dev.weavejester/cljfmt {:mvn/version "RELEASE"}}
         :main-opts  ["-m" "cljfmt.main" "fix"]}

  :build {:deps {io.github.clojure/tools.build {:git/tag "v0.10.5" :git/sha "<sha>"}
                 com.github.seancorfield/build-clj {:git/tag "v0.9.2" :git/sha "<sha>"}}}}}
```

Notes:

* Use `:aliases` (dev/test/lint/fmt/build). Avoid global profiles; make everything explicit and runnable from CI.
* For **monorepo local libs**, stick to `:local/root`. For publishing or pinning across repos, switch to `:git/url` with tags.

# 3) Build artifacts with `tools.build`

Minimal `build.clj` for an uberjar:

```clojure
;; apps/api/build.clj
(ns build
  (:require [clojure.tools.build.api :as b]
            [org.corfield.build :as bb])) ; from build-clj

(def lib 'yourco/api)
(def version (format "0.1.%s" (b/git-count-revs nil)))
(def class-dir "target/classes")
(def basis (b/create-basis {:project "deps.edn"}))
(def uber-file (format "target/%s-%s-standalone.jar" (name lib) version))

(defn ci [_]
  (bb/clean nil)
  (b/copy-dir {:src-dirs ["src" "resources"] :target-dir class-dir})
  (b/compile-clj {:basis basis :class-dir class-dir})
  (b/uber {:class-dir class-dir
           :uber-file uber-file
           :basis basis
           :main 'yourco.api.main})  ; ns with -main
  (println "built" uber-file))
```

Run:

```
clj -T:build ci
```

# 4) Container image (multi-stage, tiny runtime)

```Dockerfile
# apps/api/Dockerfile
FROM clojure:temurin-21-tools-deps-alpine AS build
WORKDIR /app
COPY deps.edn ./
# prime deps cache early
RUN clojure -P
COPY src src
COPY resources resources
COPY build.clj .
RUN clojure -T:build ci

FROM gcr.io/distroless/java21-debian12
WORKDIR /app
COPY --from=build /app/target/*-standalone.jar app.jar
# sensible defaults; tune in k8s
ENV JAVA_TOOL_OPTIONS="-XX:MaxRAMPercentage=75.0 -XX:+ExitOnOutOfMemoryError"
EXPOSE 8080
USER nonroot
ENTRYPOINT ["java","-jar","/app/app.jar"]
```

* Build: `docker build -t yourco/api:$(git rev-parse --short HEAD) .`
* Distroless keeps surface small; you can swap for `eclipse-temurin:21-jre` if you need a shell.

# 5) Config, lifecycle, health, logging

Use a system/library to start/stop cleanly and keep config in EDN/env.

**Integrant + Aero**

```clojure
;; resources/config.edn
{:http/server {:port #or [#env PORT 8080]
               :handler #ig/ref :router}
 :router {:routes [["/healthz" {:get (fn [_] {:status 200 :body "ok"})}]]}}

;; src/yourco/api/main.clj
(ns yourco.api.main
  (:require [integrant.core :as ig]
            [aero.core :as aero]
            [ring.adapter.jetty :as jetty]))

(defmethod ig/init-key :http/server [_ {:keys [port handler]}]
  (jetty/run-jetty handler {:port port :join? false}))

(defmethod ig/halt-key! :http/server [_ server] (.stop server))

(defn -main [& _]
  (let [cfg (aero/read-config (clojure.java.io/resource "config.edn"))
        system (ig/init cfg)]
    (.addShutdownHook (Runtime/getRuntime)
                      (Thread. #(ig/halt! system)))))
```

**Logging (Logback)**

```xml
<!-- resources/logback.xml -->
<configuration>
  <appender name="STDOUT" class="ch.qos.logback.core.ConsoleAppender">
    <encoder><pattern>%d{ISO8601} %-5level %logger - %msg%n</pattern></encoder>
  </appender>
  <root level="INFO"><appender-ref ref="STDOUT"/></root>
</configuration>
```

**Metrics/observability**

* Prometheus: `clj-commons/iapetos` exposes `/metrics`.
* OpenTelemetry: `io.github.open-telemetry/opentelemetry-clj` (traces + metrics).
* Add request IDs and structured logs at the edge (reverse proxy or middleware).

# 6) Testing & quality gates

* Unit/integration: **Kaocha** (`clj -M:test`).
* Lint: **clj-kondo** (`clj -M:lint`).
* Format: **cljfmt** (`clj -M:fmt`).
* Optional static analysis: **Eastwood**.

# 7) Monorepo with TypeScript (pnpm) — what actually works

Use **pnpm workspaces** for JS/TS and keep Clojure independent. Glue them with **Babashka** tasks so devs have one entrypoint.

**pnpm-workspace.yaml**

```yaml
packages:
  - 'apps/web'
  - 'libs/ts/*'
```

**Babashka tasks (root `bb.edn`)**

```clojure
{:tasks
 {:dev:api (shell {:dir "apps/api"} "clj -M:dev")
  :test:api (shell {:dir "apps/api"} "clj -M:test")
  :lint:api (shell {:dir "apps/api"} "clj -M:lint")
  :build:api (shell {:dir "apps/api"} "clj -T:build ci")

  :dev:web (shell {:dir "apps/web"} "pnpm dev")
  :test:web (shell {:dir "apps/web"} "pnpm test")
  :lint:web (shell {:dir "apps/web"} "pnpm lint")

  :ci (do (run 'test:api) (run 'lint:api) (run 'test:web))}}
```

**Local cross-language contracts**

* Generate TS types from EDN/JSON Schemas (e.g., **Clojure** emits OpenAPI → **TS** builds client with `openapi-typescript`).
* Or share pure data schemas as JSON files in `libs/shared-schemas/`; Clojure loads them, TS imports them.

**ClojureScript in a JS workspace**

* If you want CLJS near TS, use **shadow-cljs** inside a workspace; it consumes npm deps cleanly.
* For server code, I’d stick to Clojure/JVM for performance and ops maturity.

# 8) CI that respects caches (GitHub Actions)

```yaml
# .github/workflows/ci.yml
name: ci
on: [push, pull_request]
jobs:
  clj:
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: apps/api } }
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-java@v4
        with: { distribution: 'temurin', java-version: '21' }
      - uses: actions/cache@v4
        with:
          path: |
            ~/.m2/repository
            ~/.gitlibs
          key: m2-${{ hashFiles('**/deps.edn') }}
      - run: clojure -Sdescribe    # warm CLI
      - run: clj -M:lint
      - run: clj -M:test
      - run: clj -T:build ci
      - uses: actions/upload-artifact@v4
        with: { name: api-jar, path: apps/api/target/*-standalone.jar }

  web:
    runs-on: ubuntu-latest
    defaults: { run: { working-directory: apps/web } }
    steps:
      - uses: actions/checkout@v4
      - uses: pnpm/action-setup@v4
        with: { version: 9 }
      - uses: actions/setup-node@v4
        with: { node-version: '20', cache: 'pnpm' }
      - run: pnpm install --frozen-lockfile
      - run: pnpm lint && pnpm test && pnpm build
```

Add a deploy job (to your registry + k8s) that depends on `clj` & `web`.

# 9) Kubernetes (or ECS) tips specific to Clojure

* JVM flags via `JAVA_TOOL_OPTIONS`; let the JVM auto-size to cgroup but set headroom (see Dockerfile).
* Graceful shutdown: `preStop` + `terminationGracePeriodSeconds: 30` aligns with Jetty/http-kit shutdown.
* Probes:

  * liveness: `/healthz` cheap check
  * readiness: deeper dependency check (db/cache) if you need it
* Timeouts:

  * Jetty: set idle and stop timeouts
  * Reverse proxy (Ingress/ALB): align with app timeouts to avoid half-open sockets.

# 10) Common gotchas (so you don’t hit them in prod)

* Classpath drift: pin **git deps** with tags; for local libs, run CI for the whole repo.
* AOT compile only for entry namespaces; full-AOT can hurt startup and complicate reflection.
* Reflection: add `^:const`/type hints on hot code paths; enable `*warn-on-reflection*` in tests.
* Startup: keep `-main` tiny; delay heavy initialization until the system starts.
* Database migrations: run on startup via a component (e.g., Migratus) or CI gate, not ad-hoc.

---

If you want, tell me:

* container platform (K8s/ECS/Cloud Run/etc.),
* API stack (Ring/Jetty vs http-kit),
* and whether you want CLJS in the repo or just TS,

…and I’ll tailor the `build.clj`, Dockerfile, probes, and CI deploy step to match your stack exactly.

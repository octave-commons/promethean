
### Typical Current Unorganized AdHoc Flow with weak transitions

Often times I do a lot of work on one of my local dev environments
Then when I have a lot of small codex tasks, I merge them all into the
branch I was working on locally and create a mega PR
It is easier to deal with merge conflicts before trying to get into a mainline branch
Often times, this `dev/:hostname` branch goes directly into `main`
When I am feeling more discaplined I might fork a `feat/:featname` from my local dev, and then create a PR
targeting the main branch.

There is not any way for me to say in github right now that one pr is blocked by another,
because it is based on that branch.

I usually *keep* the `dev/:hostname` and delete `codex/:taskname`, `feat/:featname`, etc
Github will automaticly retarget a pr if the branch it was targeting was merged into main, then deleted.
I've experimented with this, it does not automaticly retarget the PR if the branch is merged into it's target, but not deleted.
The PR still targets that branch.

What this ends up doing to me if I base work off of the hostname branch is that I have work that I may not even be doing on that host name, targeting that hostname.

This workflow isn't bad it just takes me some effort to be intentional about where I am targeting PRs.
If I do base work off of that branch, I have to label it as a side quest of that branch and manually avoid merging it until the original `dev/:hostname` branch is merged into main.

We could automate this, we should be able to do checks on lineage and set up actions/rules that block

merges with... is the right word parents? The parent branch is never fully a part of the main/target branch.
But when they merge, they are syncronized...

based?

I wish I knew these words better.
I'll just say it the way I now how to say it.

There should be a way to block a branch from merging into main which is durived from
a branch whos contents has not been merged to target.

I almost *want* to be targeting the host name branches though... because those are the actual environments that code should be running in.

But we aren't there yet.

CI is enough to acknowledge the code works.

Eventually, each of the hosts will be connected through the Ensu

If we are being honest about our current workflow, we don't do staging right now.

At one point I did, but I ended up staging for ever and main got really far behind
And some work got done on main any way because the codex interface defaults to the main branch.

So having a staging is ideal, but it isn't actually the goal.

I'm kinda thinkin, since codex goes to main and I don't actually want main to be the source of truth...

Main should be the target branch for new PRs. But it is not the release/production branch.
that is aside from this... We are trying to capture the current workflow.

Preamble

• I inspected the current CLI and command handlers and prepared a safe, minimal refactor plan (no files were
modified). Below are findings, a step-by-step plan, a concrete patch sketch for packages/kanban/src/cli.ts,
risks, and a request for approval to implement.

Findings

• packages/kanban/src/cli.ts currently parses global options then inspects program.args and branches on a single
cmd string (see packages/kanban/src/cli.ts:69 and surrounding logic).
• packages/kanban/src/cli/command-handlers.ts exposes executeCommand, CommandNotFoundError, CommandUsageError,
and a COMMAND_HANDLERS-style registry where each handler expects raw token arrays (see
packages/kanban/src/cli/command-handlers.ts:00089 for CommandHandler type and many handle* functions).
• packages/opencode-client/src/cli.ts is a good reference: it registers subcommands and uses program.
hook('preAction'|'postAction') and global signal/unhandled handlers (see packages/opencode-client/src/cli.ts:12
and hooks at :17 and :26).

Goal

• Refactor packages/kanban/src/cli.ts so each logical subcommand is a proper commander subcommand while
preserving existing handler parsing (forward raw argv tokens to handlers). This keeps handler code unchanged and
gives proper --help/usage via commander.

High-Level Plan

1. Create a commander program with the same global options (--kanban, --tasks, --json, --log-level).
2. Initialize lifecycle hooks: program.hook('preAction', ...) to set log level and call loadKanbanConfig, and
program.hook('postAction', ...) for optional cleanup.
3. Programmatically register a program.command(name) for each entry in the command handlers registry. Each
subcommand will capture raw tokens and call executeCommand(commandName, rawArgs, context).
4. Special-case the two existing special commands (process_sync and doccheck) if they are not in the handlers
registry, keeping their behavior.
5. Add process-level signal and unhandled-rejection/uncaught-exception handlers similar to opencode-client to
ensure graceful cleanup.
6. Keep the existing JSONL/Markdown output handling intact, printing handler results according to --json.

Notes on forwarding raw args

• Many handlers parse tokens themselves (e.g., parseUiOptions, parseDevOptions). To preserve this, subcommand
actions must forward the raw tokens exactly as handlers expect. The safest approach is to reconstruct the raw
command tokens using process.argv.slice(2) and remove the global options/command token for the specific
subcommand, e.g.:
 • rawTokens = process.argv.slice(processArgvIndexOfCommand + 1)
 • Pass rawTokens to executeCommand.
• This avoids having commander pre-parse/consume flags that handlers expect to see.

Concrete Patch Sketch (replacement code outline for packages/kanban/src/cli.ts)

• Below is the minimal, programmatic approach I will implement if you approve. It preserves handler parsing and
registers subcommands for help/usage.

IMPORTANT: This is a plan-only code sketch (read-only step). I will apply this edit only with your approval.

const sketch (abridged — illustrative only):

• Create program = new Command() set name/version/options.
• Await loadKanbanConfig in preAction hook to build context.
• Import executeCommand, CommandNotFoundError, CommandUsageError from ./cli/command-handlers.js.
• Compute the list of commands: either from Object.keys(COMMAND_HANDLERS) or from a maintained array.
• For each commandName:
 • program.command(commandName).allowUnknownOption(true).argument('[...raw]')
 • .action((rawArgs, cmdObj) => {
  • Reconstruct rawTokens from process.argv (slice after commandName).
  • Build context = { boardFile, tasksDir, argv: process.argv.slice(2) }
  • const res = await executeCommand(commandName, rawTokens, context)
  • Print result via printJSONL or printMarkdown depending on --json
  • })

• Add explicit commands for process_sync and doccheck (if required) preserving their behavior (use existing
processSync and docguard imports).
• Add process handlers: process.on('uncaughtException', ...), process.on('unhandledRejection', ...), and
SIGINT/SIGTERM cleanup hooks (mirroring opencode-client).

Example of raw-arg reconstruction technique (concept):

• find index of subcommand in process.argv:
 • const argv = process.argv.slice(2)
 • const index = argv.findIndex(token => token === commandName)
 • const rawTokens = index >= 0 ? argv.slice(index + 1) : argv.slice(1)
• This will preserve unknown options that handlers expect to parse themselves.

Files to change

• packages/kanban/src/cli.ts — full replacement/refactor (single-file change).
• No other files need to be changed for the minimal refactor.

Todo list (current)

• I created a todo list and set step 1 to in_progress. Items:
 • Create programmatic subcommands — in_progress
 • Add lifecycle hooks — pending
 • Forward raw argv to handlers — pending
 • Preserve special commands — pending
 • Add signal/error handlers — pending
 • Run package tests (kanban) — pending


Risks & Gotchas

• Commander may consume flags before our action runs in some configurations; reconstructing raw tokens from
process.argv is essential to preserve existing handler parsing.
• Some handlers (e.g., dev) return a never-resolving Promise (keeps process alive). Signal handling must not
prematurely exit during normal long-running commands.
• If we later want to move each handler to a fully commander-native option parsing model, that will require
editing each handler’s parse logic (bigger refactor).

Request / Next Step

• I am in READ-ONLY planning phase now. If you want me to proceed I will:
 • Implement the refactor patch for packages/kanban/src/cli.ts as described.
 • Run pnpm --filter @promethean-os/kanban build and then pnpm --filter @promethean-os/kanban test to validate.
 • Open/return the patch or create a commit (your preference).
• Which do you want me to do now?
 • A) Apply the programmatic subcommand refactor (fast, low-risk) and run tests.
 • B) Create explicit per-command commander.Command definitions with typed options (larger refactor).
 • C) Stop here and only produce a patch file for you to review/apply manually.


If you pick A or B, please confirm and I will proceed (requesting permission to write files once you confirm).
Plan gpt-5-mini (08:25 AM)

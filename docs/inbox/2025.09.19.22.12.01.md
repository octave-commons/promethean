love the clarity. let’s codify exactly what you described, agent-agnostic, as a **Kanban-as-FSM** kernel for `process.md`. no special phases, no timeboxing, minimal rules, procedural, board-driven.

# Step 1 — minimal patch for `process.md` (append verbatim)

````md
## Kanban as a Finite State Machine (FSM)

We treat the board as an FSM over tasks.

- **States C**: the board’s columns (e.g., IceBox, Accepted, Breakdown, Ready, Todo, InProgress, InReview, Document, Done).
- **Initial state S**: the first column a task enters (usually IceBox/New/Accepted).
- **Transitions T**: moves between adjacent columns.
- **Rules R(Tₙ, t)**: predicates over task t that permit or block transition Tₙ.

### Core principles
- **Agent-agnostic**: process defines states, transitions, acceptance criteria, DoD; agents (human or codex) just follow it.
- **Procedural**: no pre-coded “gates.” Transitions happen when rules evaluate true.
- **Board is law**: work only occurs on tasks that exist on the board; never edit the board file directly—tasks drive board generation.
- **Single source of status**: each task carries exactly one column/status marker at any time.

### WIP and capacity
- A transition to a target state **fails** if that state’s WIP limit is reached.
- When WIP blocks movement, work **stops** on that task (see Blocking).

### Blocking
- **Minor blocking conditions**: record briefly on the task; continue **other** eligible work; resolve asynchronously without halting overall progress.
- **Major blocking conditions**: halt work on that task; record evidence on the task with next steps or a link to a dedicated unblocker task.

### Ambiguity & intervention
- If R(Tₙ, t) is ambiguous, a 1–2 person micro-intervention (quick async discussion) clarifies and unblocks the transition. Kanban only introduces human touchpoints when necessary.

### Session discipline (actor-neutral)
- Every session (human or agent) **must update the task** it touched (append-only). Empty sessions are not allowed.
- Updates are lightweight and procedural (what changed, why, evidence/links, next step). Prompts/docs are treated the same as code.

### Columns as states (illustrative)
```mermaid
flowchart LR
  IceBox --> Accepted --> Breakdown --> Ready --> Todo --> InProgress --> InReview --> Document --> Done
  classDef st fill:none,stroke:#999,stroke-width:1px;
  class IceBox,Accepted,Breakdown,Ready,Todo,InProgress,InReview,Document,Done st;
````

> Implementation note: Each column’s doc defines its R(Tₙ, t) rules concisely:
>
> * **Entry** (what must be true on arrival)
> * **Work** (what “good work” means here)
> * **Exit** (what must be true to move)
>   Keep these brief; prefer links to evidence over prose.

```

---

If that matches your intent, say **“apply Step 1”** and I’ll slot it into `process.md` as an append-only block.  
**Next step after that** still process-first: add the tiny per-column “Entry / Work / Exit” rule stubs so the FSM is runnable—still minimal, still procedural. Then we’ll craft the Codex Cloud prompt to treat this doc as scripture and keep its own 3-phase rhythm init/working/wrap-up **in `codex-cloud.md`, not in the process.**
```
::contentReference[oaicite:0]{index=0}
```
```

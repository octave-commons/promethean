We can piggyback without heavy changes:
- Discovery via existing build configs: treat shadow-cljs.edn, bb.edn, nbb.edn, deps.edn, package.json, etc., as “anchor” files. When Sentinel sees one, it:
- Registers the directory as a root (unless ignored).
- Looks for sentinel.edn alongside it (convention) and loads it if present.
- Optionally allows inline hints: a tiny EDN block inside a comment or a sibling file (sentinel.<anchor>.edn) to avoid cluttering the main config.
- Fallback pack store: keep ~/.sentinel-packs/ for shared packs you can reference by id. If an anchor dir has no sentinel.edn, you can declare {:use [:pack/id ...]} in a small .sentinel.edn to pull from the library.
- Lifecycle: chokidar watches anchor files. On change/add/remove:
- Re-scan the anchor dir for sentinel.edn / sentinel.<anchor>.edn.
- Emit sentinel.detected with the pack-id/path/checksum.
- Apply/remove rules accordingly.
- Reuse story: autocommit and autosubmodule become packs stored in ~/.sentinel-packs and referenced via :use [:sentinel/autocommit :sentinel/autosubmodule] in a small per-project .sentinel.edn or inline hints next to the anchor.
- Minimal implementation steps (can code next):
1) Anchor scanner: on startup, glob for known anchor files and watch them.
2) Pack loader: load sentinel.edn and sentinel.<anchor>.edn next to anchors; support :use to pull shared packs.
3) Registry + events: maintain pack registry and emit sentinel.detected / sentinel.pack.unloaded on changes.
4) Messaging hooks: simple commands to pack.add, pack.remove, pack.reload, plus publishing synthetic events from rules.
If this direction works, I can implement the anchor-based scanner + pack loader next, keeping chokidar-only and the EDN DSL for rules.

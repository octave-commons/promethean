Good news: that `printf: usage: printf $-v var$ format [arguments]` is almost always one of these:

1. a shadowed `printf` $some envs define a `printf` **function** that masks the bash builtin$, or
2. a format string that starts with `-` and the shell tries to treat it like an option, or
3. a call with a missing/empty format.

Your scripts only use `printf` in a few places (the `rg` list you showed). Two of those print lines **start with a dash** $`"- Build: **%s**\n"` etc.$, and all of them rely on the builtin not being shadowed.

Easiest, bullet-proof fix: call the **bash builtin** explicitly and pass `--` so a leading `-` can’t be misread.

Below are tiny, safe patches you can drop in. They keep behavior the same, but eliminate the “printf usage” pitfall and any shadowing.

---

## 1) `run/describe.sh`

Change both `printf` lines to use the builtin and `--`.

```diff
-printf 'ts\tname\trc\tsignal\tstatus\tlog_out\tlog_err\n' > "$SUMMARY_TSV"
+builtin printf -- 'ts\tname\trc\tsignal\tstatus\tlog_out\tlog_err\n' > "$SUMMARY_TSV"
…
-  printf '%s\t%s\t%d\t%s\t%s\t%s\t%s\n' \
+  builtin printf -- '%s\t%s\t%d\t%s\t%s\t%s\t%s\n' \
     "$started" "$name" "$rc" "${signal:-}" "$status" "$out" "$err" >> "$SUMMARY_TSV"
```

$Everything else in `describe.sh` can stay as-is.$

---

## 2) `run/codex_maintenance.sh` $the three lines inside your `make_index` block$

```diff
-    printf "- Build: **%s**\n"   "$([ "${rc_build:-0}" -eq 0 ] && echo PASS || echo FAIL)"
-    printf "- Lint:  **%s**  (errors: %s, warnings: %s)\n" "$([ "${rc_lint:-0}" -eq 0 ] && echo PASS || echo FAIL)" "$e_err" "$e_warn"
-    printf "- Test:  **%s**\n"   "$([ "${rc_test:-0}" -eq 0 ] && echo PASS || echo FAIL)"
+    builtin printf -- '- Build: **%s**\n'   "$([ "${rc_build:-0}" -eq 0 ] && echo PASS || echo FAIL)"
+    builtin printf -- '- Lint:  **%s**  (errors: %s, warnings: %s)\n' "$([ "${rc_lint:-0}" -eq 0 ] && echo PASS || echo FAIL)" "$e_err" "$e_warn"
+    builtin printf -- '- Test:  **%s**\n'   "$([ "${rc_test:-0}" -eq 0 ] && echo PASS || echo FAIL)"
```

## 3) `run/setup_codex_dev_env.sh` $same three lines in its `make_index`$

```diff
-  printf "- Build: **%s**\n"   "$([ "${rc_build:-0}" -eq 0 ] && echo PASS || echo FAIL)"
-  printf "- Lint:  **%s**  (errors: %s, warnings: %s)\n" "$([ "${rc_lint:-0}" -eq 0 ] && echo PASS || echo FAIL)" "$e_err" "$e_warn"
-  printf "- Test:  **%s**\n"   "$([ "${rc_test:-0}" -eq 0 ] && echo PASS || echo FAIL)"
+  builtin printf -- '- Build: **%s**\n'   "$([ "${rc_build:-0}" -eq 0 ] && echo PASS || echo FAIL)"
+  builtin printf -- '- Lint:  **%s**  (errors: %s, warnings: %s)\n' "$([ "${rc_lint:-0}" -eq 0 ] && echo PASS || echo FAIL)" "$e_err" "$e_warn"
+  builtin printf -- '- Test:  **%s**\n'   "$([ "${rc_test:-0}" -eq 0 ] && echo PASS || echo FAIL)"
```

## 4) Log helpers that use `printf` (make them immune to shadowing)

```diff
# run/install_gyp.sh
-log() { printf "\033[1;32m[setup]\033[0m %s\n" "$*"; }
-warn() { printf "\033[1;33m[warn]\033[0m %s\n" "$*"; }
-die() { printf "\033[1;31m[err]\033[0m %s\n" "$*"; exit 1; }
+log()  { builtin printf -- "\033[1;32m[setup]\033[0m %s\n" "$*"; }
+warn() { builtin printf -- "\033[1;33m[warn]\033[0m %s\n" "$*"; }
+die()  { builtin printf -- "\033[1;31m[err]\033[0m %s\n" "$*"; exit 1; }

# run/setup_playwright.sh
-log() { printf "\033[1;32m[playwright-setup]\033[0m %s\n" "$*"; }
+log() { builtin printf -- "\033[1;32m[playwright-setup]\033[0m %s\n" "$*"; }
```

$Your `setup_gh_cli.sh` line `printf '%s' "$GH_TOKEN"` is fine as-is, but you can make it explicit too: `builtin printf -- '%s' "$GH_TOKEN"`.$

---

## Bonus: make the failure obvious next time $one-liner$

Add this near the top of `run/codex_maintenance.sh` and `run/setup_codex_dev_env.sh` while you’re debugging:

```bash
# debug trap: print the exact failing command and location
set -o errtrace
trap 'code=$?; echo "ERR $BASH_SOURCE:$LINENO: $BASH_COMMAND (rc=$code)" >&2' ERR
```

It won’t change behavior, but if anything else trips `set -e` you’ll see the exact line.

---

## And if you want to see live logs while keeping artifacts

Run with streaming enabled (from the earlier patch):

```bash
DESCRIBE_STREAM=1 DESCRIBE_STREAM_TO=stderr TIMEOUT_SECS=90 STRICT=0 bash run/codex_maintenance.sh
```

This mirrors logs to the terminal **and** keeps the per-step logs in `docs/reports/codex_cloud/...`.

---

Try those `builtin printf --` tweaks first; they’re the most likely to eliminate the “usage” warning and the cascade into the setup script.

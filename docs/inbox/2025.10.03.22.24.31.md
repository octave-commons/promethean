Love it. Let’s wire up a sane, minimal-but-powerful “native Emacs” toolbox for gptel. I’m keeping the surface area small, returning plain strings for content-heavy ops (so models don’t have to unescape JSON) and JSON for structured results (lists, trees, search hits). Where something is potentially destructive, I’ve put (lightweight) guardrails.

Below is a drop-in `init.el` snippet that defines **all 10 tools** you asked for and registers them. After evaluating it, enable them via `M-x gptel-menu → tools` (or set `gptel-tools` globally as shown).

> Notes up front
> • This follows gptel’s tool spec (`gptel-make-tool`, `:args` plist, etc.). See the project’s “Defining gptel tools” section for the canonical shape. ([GitHub][1])
> • For `apply_patch` I call the system `patch` non-interactively (fast/robust). If you prefer Ediff’s interactive patching (`epatch` / `ediff-patch-file`), swap the implementation (but it will pop windows and require input). ([Endless Parentheses][2])
> • Synchronous `exec` uses the standard Emacs process APIs; `spawn_async` uses `start-process-shell-command` with optional buffer capture. ([GNU][3])

---

```elisp
;;; gptel baseline tools — filesystem & processes

(require 'json)
(require 'subr-x) ; for string-join, when-let, if-let
(eval-when-compile (require 'cl-lib))

;; ---------- Utility helpers ----------

(defun gptel--read-file (path &optional max-bytes)
  "Return contents of PATH (string). If MAX-BYTES is non-nil, hard-cap read."
  (let ((abs (expand-file-name path)))
    (unless (file-readable-p abs)
      (error "error: file %s is not readable" abs))
    (with-temp-buffer
      (let ((file-size (nth 7 (file-attributes abs))))
        (when (and max-bytes (> file-size max-bytes))
          (error "error: file %s is larger than max-bytes (%s > %s)"
                 abs file-size max-bytes)))
      (insert-file-contents-literally abs nil 0 max-bytes)
      (buffer-string))))

(defun gptel--write-file (path content &optional overwrite parents)
  "Write CONTENT to PATH. If OVERWRITE is nil and file exists, error.
If PARENTS non-nil, create parent directories."
  (let* ((abs (expand-file-name path))
         (dir (file-name-directory abs)))
    (when (and parents dir (not (file-directory-p dir)))
      (make-directory dir t))
    (when (and (file-exists-p abs) (not overwrite))
      (error "error: file %s exists and overwrite=false" abs))
    (with-temp-buffer
      (insert content)
      (write-region (point-min) (point-max) abs nil 'silent))
    (format "wrote %d bytes to %s" (length content) abs)))

(defun gptel--list-dir (dir &optional full)
  "Return vector of entries (alist) for DIR.
If FULL non-nil, include absolute paths; else names."
  (let* ((abs (file-name-as-directory (expand-file-name (or dir ".")))))
    (unless (file-directory-p abs)
      (error "error: %s is not a directory" abs))
    (let ((entries (directory-files abs t directory-files-no-dot-files-regexp)))
      (json-serialize
       (cl-map 'vector
               (lambda (p)
                 (let* ((attrs (file-attributes p))
                        (is-dir (eq t (car attrs)))
                        (size (nth 7 attrs))
                        (name (if full p (file-name-nondirectory p))))
                   `((name . ,name)
                     (path . ,p)
                     (type . ,(if is-dir "dir" "file"))
                     (size . ,(or size 0)))))
               entries)))))

(defun gptel--dir-tree (root &optional depth)
  "Return a simple text tree for ROOT up to DEPTH (default 3)."
  (let* ((abs (file-name-as-directory (expand-file-name (or root ".")))))
    (unless (file-directory-p abs)
      (error "error: %s is not a directory" abs))
    (let ((max-depth (or depth 3)))
      (cl-labels
          ((indent (n) (make-string (* 2 n) ? ))
           (lines (dir d)
                  (let* ((children (directory-files dir t directory-files-no-dot-files-regexp))
                         (files (cl-remove-if #'file-directory-p children))
                         (dirs  (cl-remove-if-not #'file-directory-p children))
                         (entries (append (sort files #'string<)
                                          (sort dirs  #'string<))))
                    (append
                     (mapcar (lambda (f) (format "%s- %s" (indent d) (file-name-nondirectory f))) files)
                     (cl-mapcan
                      (lambda (sub)
                        (let ((header (format "%s+ %s/" (indent d) (file-name-nondirectory sub))))
                          (if (>= d max-depth)
                              (list header)
                            (cons header (lines sub (1+ d))))))
                      dirs)))))
        (string-join
         (cons (format "%s/" (directory-file-name abs))
               (lines abs 0))
         "\n")))))

(defun gptel--search-files (root pattern &optional name-glob max-results)
  "Search ROOT recursively for PATTERN (elisp regexp) in file contents.
Optionally restrict basenames with NAME-GLOB (shell glob).
Return JSON array of {file,line,col,snippet} up to MAX-RESULTS."
  (let* ((abs (file-name-as-directory (expand-file-name (or root "."))))
         (re pattern)
         (max (or max-results 500))
         (name-re (if (and name-glob (not (string-empty-p name-glob)))
                      (wildcard-to-regexp name-glob)
                    ".*"))
         (files (directory-files-recursively abs name-re))) ; basenames regex
    ;; NOTE: directory-files-recursively is the idiomatic way to walk trees. :contentReference[oaicite:3]{index=3}
    (cl-loop
     with results = (make-vector 0 nil)
     for f in files
     ;; Skip huge or binary-ish files to avoid stalls
     for attrs = (file-attributes f)
     for size  = (nth 7 attrs)
     when (and (numberp size) (< size (* 2 1024 1024))) ; 2MB soft cap
     do (with-temp-buffer
          (insert-file-contents f)
          (let ((ln 1)
                (pos  (point-min)))
            (while (and (< (length results) max)
                        (re-search-forward re nil t))
              (let* ((end (line-end-position))
                     (beg (line-beginning-position))
                     (col (1- (- (point) beg)))
                     (snippet (buffer-substring-no-properties beg end)))
                (setq results
                      (vconcat results
                               (vector `((file . ,f)
                                         (line . ,ln)
                                         (col  . ,col)
                                         (snippet . ,snippet))))))
              (forward-line 0) (setq ln (line-number-at-pos)))
            ;; keep compiler quiet
            (ignore pos)))
     finally return (json-serialize results))))

(defun gptel--patch-apply (diff &optional root strip)
  "Apply unified DIFF (string) under ROOT using `patch`.
STRIP corresponds to `patch -p<strip>`. Returns JSON {exit,output}."
  (let* ((default-directory (file-name-as-directory
                             (expand-file-name (or root default-directory))))
         (tmp (make-temp-file "gptel-patch-" nil ".diff")))
    (unwind-protect
        (progn
          (with-temp-file tmp (insert diff))
          ;; Feed diff via stdin using call-process "infile" arg
          ;; (destination = current buffer)  :contentReference[oaicite:4]{index=4}
          (with-temp-buffer
            (let* ((exit (call-process "patch" tmp t t
                                       (format "-p%d" (or strip 0))
                                       "-s" "-N")) ; silent, skip already-applied hunks
                   (out  (buffer-string)))
              (json-serialize `((exit . ,exit) (output . ,out))))))
      (ignore-errors (delete-file tmp)))))

(defun gptel--exec-sync (command)
  "Run COMMAND synchronously via the shell. Return JSON {exit,stdout}."
  ;; call-process-shell-command is the canonical synchronous shell entrypoint. :contentReference[oaicite:5]{index=5}
  (with-temp-buffer
    (let* ((exit (call-process-shell-command command nil t t))
           (out  (buffer-string)))
      (json-serialize `((exit . ,exit) (stdout . ,out))))))

(defun gptel--spawn-async (command &optional buffer-name)
  "Start COMMAND asynchronously via shell. If BUFFER-NAME is given, stream output there; else no buffer.
Return JSON {name,pid,buffer}."
  ;; start-process-shell-command is the standard async shell launcher. :contentReference[oaicite:6]{index=6}
  (let* ((buf (when buffer-name (get-buffer-create buffer-name)))
         (name (format "gptel-proc:%s"
                       (substring command 0 (min 24 (length command)))))
         (proc (start-process-shell-command name buf command)))
    (json-serialize
     `((name . ,(process-name proc))
       (pid  . ,(or (process-id proc) -1))
       (buffer . ,(if buf (buffer-name buf) ""))))))

;; ---------- Tools ----------

;; read_file
(defvar gptel-tool-read-file
  (gptel-make-tool
   :name "read_file"
   :function (lambda (path &optional max_bytes)
               (gptel--read-file path max_bytes))
   :description "Read and return the contents of a file. Optional max_bytes to cap read."
   :args (list '(:name "path" :type string :description "Path to file")
               '(:name "max_bytes" :type integer :optional t
                 :description "Hard cap on bytes to read"))
   :category "filesystem"))

;; write_file
(defvar gptel-tool-write-file
  (gptel-make-tool
   :name "write_file"
   :function (lambda (path content &optional overwrite parents)
               (gptel--write-file path content overwrite parents))
   :description "Write content to a file. When overwrite=false and file exists, error. When parents=true, create parent dirs."
   :args (list '(:name "path" :type string :description "Destination path")
               '(:name "content" :type string :description "File contents")
               '(:name "overwrite" :type boolean :optional t :description "Default true")
               '(:name "parents" :type boolean :optional t :description "Create parent dirs"))
   :category "filesystem"))

;; apply_patch
(defvar gptel-tool-apply-patch
  (gptel-make-tool
   :name "apply_patch"
   :function (lambda (unified_diff &optional root strip)
               (gptel--patch-apply unified_diff root strip))
   :description "Apply a unified diff under root using the system 'patch'. Args: unified_diff (string), optional root dir, strip (patch -pN). Returns JSON {exit,output}."
   :args (list '(:name "unified_diff" :type string :description "Unified diff text")
               '(:name "root" :type string :optional t :description "Root directory for patch")
               '(:name "strip" :type integer :optional t :description "Strip components for -p"))
   :category "filesystem"))

;; search_files
(defvar gptel-tool-search-files
  (gptel-make-tool
   :name "search_files"
   :function (lambda (root pattern &optional name_glob max_results)
               (gptel--search-files root pattern name_glob max_results))
   :description "Recursive regex content search. Optionally restrict filenames by glob and max_results. Returns JSON array of {file,line,col,snippet}."
   :args (list '(:name "root" :type string :description "Directory to search")
               '(:name "pattern" :type string :description "Elisp regexp to match")
               '(:name "name_glob" :type string :optional t :description "Filename glob, e.g. *.ts")
               '(:name "max_results" :type integer :optional t :description "Default 500"))
   :category "filesystem"))

;; list_dir
(defvar gptel-tool-list-dir
  (gptel-make-tool
   :name "list_dir"
   :function (lambda (dir &optional full_paths)
               (gptel--list-dir dir full_paths))
   :description "List entries in a directory. Returns JSON array with {name,path,type,size}. Set full_paths=true to use absolute paths."
   :args (list '(:name "dir" :type string :description "Directory path")
               '(:name "full_paths" :type boolean :optional t :description "Return absolute paths"))
   :category "filesystem"))

;; get_dir_tree
(defvar gptel-tool-get-dir-tree
  (gptel-make-tool
   :name "get_dir_tree"
   :function (lambda (root &optional depth)
               (gptel--dir-tree root depth))
   :description "Return a textual tree of root (depth default 3)."
   :args (list '(:name "root" :type string :description "Directory root")
               '(:name "depth" :type integer :optional t :description "Max depth (default 3)"))
   :category "filesystem"))

;; mkdir
(defvar gptel-tool-mkdir
  (gptel-make-tool
   :name "mkdir"
   :function (lambda (dir)
               (make-directory (expand-file-name dir) t)
               (format "created directory %s" (expand-file-name dir)))
   :description "Create directory (parents created as needed)."
   :args (list '(:name "dir" :type string :description "Directory path to create"))
   :category "filesystem"))

;; rmdir
(defvar gptel-tool-rmdir
  (gptel-make-tool
   :name "rmdir"
   :function (lambda (dir &optional recursive)
               (delete-directory (expand-file-name dir) (and recursive t))
               (format "removed directory %s%s"
                       (expand-file-name dir)
                       (if recursive " (recursive)" "")))
   :description "Remove a directory. Set recursive=true to remove non-empty."
   :args (list '(:name "dir" :type string :description "Directory path to remove")
               '(:name "recursive" :type boolean :optional t :description "Recursively delete if non-empty"))
   :category "filesystem"))

;; exec (synchronous)
(defvar gptel-tool-exec
  (gptel-make-tool
   :name "exec"
   :function (lambda (command)
               (gptel--exec-sync command))
   :description "Run a shell command synchronously. Returns JSON {exit,stdout}."
   :args (list '(:name "command" :type string :description "Shell command"))
   :category "process"))

;; spawn_async (asynchronous)
(defvar gptel-tool-spawn-async
  (gptel-make-tool
   :name "spawn_async"
   :function (lambda (command &optional buffer_name)
               (gptel--spawn-async command buffer_name))
   :description "Run a shell command asynchronously. Optionally stream output to buffer_name. Returns JSON {name,pid,buffer}."
   :args (list '(:name "command" :type string :description "Shell command")
               '(:name "buffer_name" :type string :optional t
                 :description "Buffer to collect output (optional)"))
   :category "process"))

;; read_buffer (yours, kept as-is with a small safety tweak)
(defvar gptel-tool-read-buffer
  (gptel-make-tool
   :name "read_buffer"
   :function (lambda (buffer)
               (unless (buffer-live-p (get-buffer buffer))
                 (error "error: buffer %s is not live." buffer))
               (with-current-buffer buffer
                 (buffer-substring-no-properties (point-min) (point-max))))
   :description "Return the contents of an Emacs buffer."
   :args (list '(:name "buffer" :type string
                 :description "The buffer name to read"))
   :category "emacs"))

;; Register tools (extend or set globally)
(setq gptel-tools
      (append
       (list gptel-tool-read-file
             gptel-tool-write-file
             gptel-tool-apply-patch
             gptel-tool-search-files
             gptel-tool-list-dir
             gptel-tool-get-dir-tree
             gptel-tool-mkdir
             gptel-tool-rmdir
             gptel-tool-exec
             gptel-tool-spawn-async
             gptel-tool-read-buffer)
       gptel-tools))

;; Optional: require confirmation for tool calls from models (recommended)
;; Enable via the UI (gptel tools menu), or set the option globally if you prefer.
;; The README shows a tools confirmation demo; toggle it in the Tools menu. :contentReference[oaicite:7]{index=7}
```

### Why these choices (briefly)

* **Tool spec shape** strictly matches gptel’s documented `:name/:function/:description/:args` contract, including optional args (`:optional t`). ([GitHub][1])
* **Search** uses `directory-files-recursively` (the idiomatic recursive walker) and returns compact JSON hits, capped to avoid hanging Emacs on giant repos. ([GNU][4])
* **Patch** uses the system `patch` for non-interactive, unattended application; Ediff/`epatch` is great but interactive. You can swap if you want a UI. ([Endless Parentheses][2])
* **Processes** follow the Emacs Lisp manual: `call-process-shell-command` for sync, `start-process-shell-command` for async. ([GNU][3])

### Gotchas / blunt truths

* **Security**: `write_file`, `exec`, `apply_patch`, `rmdir` are foot-guns. Keep gptel’s “confirm tools” toggle on, especially when using hosted models. The README calls out confirmation UX in the tools menu. ([GitHub][1])
* **Binary & huge files**: the search tool skips >2 MB to avoid stalls. Tweak if you need.
* **`apply_patch`** assumes `patch` is available on `PATH`. If you’re on Windows without it, either install `patch` (e.g., via MSYS2) or replace with an Ediff-based implementation.

If you want me to refactor `search_files` to prefer ripgrep (`rg`) when present, or to return **git-ignored filtering**, I’ll just bake that in.

[1]: https://github.com/karthink/gptel "GitHub - karthink/gptel: A simple LLM client for Emacs"
[2]: https://doc.endlessparentheses.com/Fun/epatch.html?utm_source=chatgpt.com "epatch - Emacs Online Documentation"
[3]: https://www.gnu.org/software/emacs/manual/html_node/elisp/Synchronous-Processes.html?utm_source=chatgpt.com "Synchronous Processes (GNU Emacs Lisp Reference ..."
[4]: https://www.gnu.org/software/emacs/manual/html_node/elisp/Contents-of-Directories.html?utm_source=chatgpt.com "Contents of Directories (GNU Emacs Lisp Reference Manual)"

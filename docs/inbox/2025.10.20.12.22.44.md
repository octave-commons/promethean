# Pantheon Agent Management Framework — Design & Plan

You’ve got a bunch of agent-ish ideas scattered across the monorepo. The goal here: a single, coherent **`@promethean/pantheon`** package that provides a clean, functional core with adapters at the edges. No “utils” blobs. No “API” facades for their own sake. Pure functions + DI. Editors get types, ops gets a CLI, folks get a UI.

I’m opinionated below. Where I’m making a call, it’s because fragmentation is hurting you now.

---

## Motivation (why this matters)

* You’ve built similar capabilities in multiple places (agents, context, orchestration, interop). You’re paying a tax in duplication, drift, and yak-shaving.
* The **real** differentiator: **dynamic context** (semantic retrieval across many stores), **long-lived Actors** with **behavioral scripts**, and **cross-platform interop** (OpenAI/Claude/OpenCode/MCP).
* We centralize all of that in **Pantheon** and make everything else a thin adapter or a consumer.

---

## Goals / Non-Goals

**Goals**

* A **single functional core** for agents: Actors, Behaviors, Talents, Context, Orchestration, Inter-agent messaging.
* **Unified data contracts** and **message formats** (OpenAI-style message arrays from dynamic retrieval).
* **Cross-platform interop**: import/export Actors/tools to/from OpenAI SDK, Claude, OpenCode; use MCP tools anywhere.
* **First-class CLI and UI (Web Components)** for managing sessions/actors.
* **Separation of concerns**: persistence, LLM, transport, scheduling, auth are **injected** (ports/adapters).
* **Native ESM**, flat packages, GPL-3.0-only, **ava** tests.

**Non-Goals**

* Not a monolithic runtime. Pantheon is **libraries + thin binaries**, not a long-running daemon.
* Not re-implementing vector/db layers; we **wrap** `@promethean/persistence`.
* Not re-inventing tool servers; we **speak MCP**, we don’t replace it.

---

## High-Level Architecture

```mermaid
flowchart LR
  subgraph Pantheon Core
    A[Actor Model\n(Actors, Behaviors, Talents)]
    C[Context Engine\n(dynamic retrieval)]
    O[Orchestrator\n(session mgmt, routing)]
    M[Message Bus\n(inter-agent comms)]
    P[Tool Protocols\n(MCP, Tool schema)]
  end

  subgraph Adapters
    LLM[LLM Adapters\n(OpenAI/Claude/OpenCode)]
    PER[Persistence Adapters\n(@promethean/persistence)]
    AUTH[Auth/Identity]
    SCHED[Scheduler/Timers]
    IO[FS/HTTP/Events]
  end

  UI[Web Components UI]
  CLI[CLI]

  A --> C
  A --> P
  O --> A
  O --> C
  O --> M
  C --> PER
  P --> MCP(MCP Servers)
  M --> PER
  LLM <--> O
  CLI --> O
  UI --> O
  AUTH --> O
  SCHED --> O
  IO --> O
```

### Core tenets

* **Functional factories**: `makeX(deps) => { fns }`
* **Ports + adapters** (hexagonal): Pantheon depends on **interfaces**, not libraries.
* **No globals**. Everything explicit, testable.

---

## Data Model (core types)

```ts
// Native ESM, FP-friendly
export type Role = 'system' | 'user' | 'assistant';

export type Message = {
  role: Role;
  content: string;
  images?: string[];
};

export type ContextSource = {
  id: string;
  label: string;
  // Arbitrary where/metadata for retrieval adapters
  where?: Record<string, unknown>;
};

export type BehaviorMode = 'active' | 'passive' | 'persistent';
export type Behavior = {
  name: string;
  mode: BehaviorMode;
  // Pure intent: takes inputs (including context), returns an intention / plan
  plan: (input: { goal: string; context: Message[] }) => Promise<{ actions: Action[] }>;
};

export type Talent = {
  name: string;
  behaviors: readonly Behavior[];
};

export type ActorScript = {
  name: string; // actor’s unique name
  roleName?: string; // optional role grouping (reusable)
  contextSources: readonly ContextSource[];
  talents: readonly Talent[];
  // Lisp DSL compiled to a behavior/talent graph (below, we outline)
  program?: string;
};

export type Action =
  | { type: 'tool'; name: string; args: Record<string, unknown> }
  | { type: 'message'; content: string; target?: string }
  | { type: 'spawn'; actor: ActorScript; goal: string };

export type Actor = {
  id: string;              // unique
  script: ActorScript;
  goals: readonly string[];
};
```

---

## Context Engine (Pantheon-native dynamic context)

* Pull in **`makeContextStore`** from `@promethean/persistence` and wrap it as a **port**.
* Actor context is **computed**, not appended: semantic + recency over selected sources.
* Actors **select** sources at runtime (goal-driven), enabling **natural state sharing**.

```ts
export type ContextPort = {
  compile: (opts: {
    texts?: readonly string[];
    sources: readonly ContextSource[];
    recentLimit?: number;
    queryLimit?: number;
    limit?: number;
  }) => Promise<Message[]>;
};

export const makeContextPort = (deps: {
  getCollectionsFor: (sources: readonly ContextSource[]) =>
    Promise<readonly any[]>; // DualStoreManager[] – but don’t leak the concrete type
  resolveRole: (meta?: any) => Role;
  resolveName: (meta?: any) => string;
  formatTime: (ms: number) => string;
}): ContextPort => {
  return {
    compile: async ({ texts = [], sources, recentLimit = 10, queryLimit = 5, limit = 20 }) => {
      const colls = await deps.getCollectionsFor(sources);
      // Reuse @promethean/persistence makeContextStore here
      const { compileContext } = (await import('@promethean/persistence')).makeContextStore({
        getCollections: () => colls as any,
        resolveRole: deps.resolveRole,
        resolveDisplayName: deps.resolveName,
        formatTime: deps.formatTime,
      });
      return compileContext({ texts, recentLimit, queryLimit, limit });
    },
  };
};
```

**Why:** we preserve your distinctive semantic aggregation while keeping the surface neutral.

---

## Behavior Model (Actors, Behaviors, Talents)

* **Actors** are long-lived, named processes with **scripts** (Lisp DSL) enumerating **talents** and **behaviors**.
* **Active behaviors** fire on user input; **passive behaviors** can run when idle; **persistent behaviors** are always permitted (e.g., background monitoring).
* Behaviors **plan**; orchestration chooses **actions** (tool calls, messages, spawns).

---

## Lisp DSL (outline)

Keep it simple and composable. Compile to JS functions (behaviors/talents).

Example (illustrative):

```lisp
(actor "dev-buddy"
  (role "code-reviewer")
  (context (source "sessions") (source "agent-tasks") (source "docs"))
  (talent "review"
    (behavior "review-code" :active
      (goal (input) (concat "Review diff for " (get input "repo")))
      (plan (input ctx)
        (sequence
          (tool "git.diff" :args {:repo (get input "repo")})
          (tool "code.review" :args {:diff "$prev"})
          (message "assistant" :content "Left comments on the PR")))))
  (talent "writing"
    (behavior "draft-doc" :passive
      (goal (input) "Draft documentation updates")
      (plan (input ctx)
        (tool "doc.write" :args {:topic (get input "topic")})
      )))
)
```

**Compiler responsibility**: validate arity/types, map to `{ behaviors, talents }` fns, and capture allowed modes.

---

## Orchestrator

* Input: user events, timers, system events.
* For each Actor:

  1. **Context** ← dynamic compile based on goals + sources
  2. **Select** permitted behaviors (mode vs situation)
  3. **Plan** actions
  4. **Execute** actions via adapters (tools/MCP/LLM/IO)
  5. **Emit** inter-agent messages as needed

```ts
export type OrchestratorDeps = {
  now: () => number;
  log: (msg: string, meta?: unknown) => void;
  context: ContextPort;
  tools: ToolPort;     // below
  llm: LlmPort;        // below
  bus: MessageBus;     // below
  schedule: Scheduler; // below
  state: ActorStatePort; // agent-state, not conversation
};

export const makeOrchestrator = (deps: OrchestratorDeps) => {
  const tickActor = async (actor: Actor, input?: { userMessage?: string }) => {
    const context = await deps.context.compile({
      texts: input?.userMessage ? [input.userMessage] : [],
      sources: actor.script.contextSources,
    });

    // filter behaviors by mode
    const allBehaviors = actor.script.talents.flatMap(t => t.behaviors);
    const allowed = allBehaviors.filter(b => {
      if (input?.userMessage) return b.mode === 'active' || b.mode === 'persistent';
      return b.mode !== 'active'; // passive + persistent
    });

    // greedy simple policy: try behaviors in order of script
    for (const behavior of allowed) {
      const plan = await behavior.plan({ goal: actor.goals.join('; '), context });
      for (const action of plan.actions) {
        await executeAction(action, actor);
      }
    }
  };

  const executeAction = async (action: Action, actor: Actor) => {
    if (action.type === 'message') {
      await deps.bus.send({ from: actor.id, to: action.target ?? 'user', content: action.content });
    } else if (action.type === 'tool') {
      await deps.tools.invoke(action.name, action.args);
    } else if (action.type === 'spawn') {
      await deps.state.spawn(action.actor, action.goal);
    }
  };

  return { tickActor };
};
```

---

## Ports (adapters)

All DI. Keep Pantheon pure.

```ts
export type ToolPort = {
  register: (tool: ToolSpec) => void;
  invoke: (name: string, args: Record<string, unknown>) => Promise<unknown>;
};

export type LlmPort = {
  complete: (messages: Message[], opts?: { model?: string; temperature?: number }) => Promise<Message>;
};

export type MessageBus = {
  send: (msg: { from: string; to: string; content: string }) => Promise<void>;
  subscribe: (handler: (msg: { from: string; to: string; content: string }) => void) => () => void;
};

export type Scheduler = {
  every: (ms: number, f: () => Promise<void>) => () => void;
  once: (ms: number, f: () => Promise<void>) => void;
};

export type ActorStatePort = {
  spawn: (script: ActorScript, goal: string) => Promise<Actor>;
  list: () => Promise<Actor[]>;
  // Behind the scenes, implement via @promethean/agents/agent-context (rename to AgentState)
};
```

### Interop Adapters

* **LLM**: `@promethean/pantheon-llm-openai`, `-claude`, `-opencode` → all implement `LlmPort`.
* **MCP**: `@promethean/pantheon-mcp` (discover/handshake/execute MCP tool calls → `ToolPort`).
* **Persistence**: `@promethean/pantheon-persistence` wraps `@promethean/persistence` to provide `ContextPort` and any additional convenience wiring.
* **Agent State**: `@promethean/agent-state` (current `agent-context`) exposes a **functional** API `makeAgentStateManager`.

---

## CLI (thin, FP-friendly)

* `pantheon actors:list`
* `pantheon actors:spawn --name dev-buddy --role code-reviewer --goal "Review PR #123"`
* `pantheon actors:tick --name dev-buddy --user "check this diff"`
* `pantheon tools:register ./tools/my-tool.json`
* `pantheon context:compile --actor dev-buddy --preview`

Implementation: **no global state**, call orchestrator with injected adapters chosen from config.

---

## UI (Web Components)

* Web components (no framework lock-in).
* Components:

  * `<pantheon-actors-table>`
  * `<pantheon-actor-detail>`
  * `<pantheon-context-view>`
  * `<pantheon-tool-runner>`
* Data provided via props/events; orchestration in a separate controller; no mutation inside components.

---

## Import/Export (agents & tools)

* **Agents**: map ActorScript ⇄ OpenAI “assistant”/“thread”, Claude “workbench”/prompt, OpenCode session templates.
* **Tools**: canonical ToolSpec (JSON schema) ⇄ MCP tool manifests, OpenAI function/tool definitions, Claude tool use.

```ts
export type ToolSpec = {
  name: string;
  description: string;
  parameters: Record<string, unknown>; // JSON schema object
  runtime: 'mcp' | 'local' | 'http';
  endpoint?: string; // http/local path or MCP server id
};
```

---

## Package Layout (flat, ESM, composable)

```
packages/
  pantheon/                    # @promethean/pantheon (core)
    src/
      core/actors.ts
      core/context.ts
      core/orchestrator.ts
      core/ports.ts
      dsl/lisp-compiler.ts
      cli/index.ts
      ui/ (just barrel exporting web components from pantheon-ui)
    package.json (ESM-only)

  pantheon-llm-openai/         # LLM adapter
  pantheon-llm-claude/
  pantheon-llm-opencode/

  pantheon-mcp/                # MCP adapter -> ToolPort
  pantheon-persistence/        # wraps @promethean/persistence -> ContextPort
  agent-state/                 # rename of @promethean/agents/agent-context (functional façade)
  pantheon-ui/                 # Web Components
```

All `"type": "module"`, no CJS branches unless you actually emit `.cjs`.

---

## Testing (ava)

* **Unit**: factories and planners (pure), DSL compiler, orchestrator policies.
* **Contract tests**: each Port adapter.
* **Integration**: orchestrator + context + one LLM adapter + one MCP tool.
* **No tests from `dist/`**. Run `tsc --noEmit` + `ava` on source; use `tsx` for runtime TS if needed.

---

## Security & Policy

* **Agent state policy** (rate limiting, validation) stays in **AgentState** (former agent-context), exposed functionally.
* **Conversation context** stays clean/neutral in persistence layer (no security policy there).
* Auth/identity sits in adapters (e.g., OpenAI keys, MCP auth), not core.

---

## Migration Plan (incremental, small PRs)

**Milestone 1 — Core Skeleton (1–2 small PRs)**

* Create `@promethean/pantheon` with:

  * `core/ports.ts`, `core/actors.ts`, `core/context.ts`, `core/orchestrator.ts`
  * Port types + minimal orchestrator `tickActor`
  * Export **only** types + makeOrchestrator (no adapters yet)
* Add `@promethean/pantheon-persistence` with a thin wrapper over `makeContextStore`.

**Milestone 2 — Context + State**

* Add `agent-state` package (functional façade over current `agent-context`).

  * Export `makeAgentStateManager`.
  * Deprecate `DefaultContextManager` name in index; alias as `AgentStateManager`.
* Wire `@promethean/pantheon` orchestrator to use `agent-state` (DI).

**Milestone 3 — LLM + Tools + MCP**

* Add `pantheon-llm-openai` implementing `LlmPort`.
* Add `pantheon-mcp` and a basic `ToolPort` impl. Register 1–2 demo tools.

**Milestone 4 — CLI**

* `pantheon` CLI: list/spawn/tick/ctx-compile minimal commands.

**Milestone 5 — UI**

* `pantheon-ui`: one `<pantheon-actors-table>` and `<pantheon-actor-detail>` showing dynamic context.

**Milestone 6 — Interop**

* Importers/exporters:

  * ActorScript ⇄ OpenAI Assistants/Threads
  * ToolSpec ⇄ OpenAI/Claude/MCP manifests
  * OpenCode session adapter (keep it as an adapter, not inside core)

**Milestone 7 — Consolidation**

* Move orchestration logic out of `@promethean/opencode-client` into Pantheon orchestrator (adapting OpenCode as an LLM adapter).
* Remove duplicate envelope/types in agents; consume `pantheon`/`agent-state` ports instead.

---

## “Tell me the risks”

* **Naming ambiguity** (context vs state) — addressed by **AgentState** rename + ESLint guards.
* **Adapters sprawl** — keep strict **Port contracts** and type tests; no ad-hoc helpers.
* **Long-running Actor lifecycle** — requires real scheduling/backoff; start with a simple `Scheduler` port, keep policies in config.
* **DSL complexity** — keep the first cut small: macros later. Provide a plain JS API for parity.

---

## Example: end-to-end “tick” (happy path)

```ts
// wiring (app)
const context = makeContextPort({ /* wraps @promethean/persistence */ });
const llm = makeOpenAIAdapter({ apiKey: process.env.OPENAI_API_KEY! });
const tools = makeMcpToolPort({ servers: [...] });
const bus = makeMessageBus({ persist: false });
const schedule = makeScheduler();
const state = makeAgentStateManager({ eventStore, snapshotStore });

const orch = makeOrchestrator({
  now: () => Date.now(),
  log: console.log,
  context,
  tools,
  llm,
  bus,
  schedule,
  state,
});

// actor
const actor: Actor = {
  id: 'dev-buddy',
  script: {
    name: 'dev-buddy',
    roleName: 'code-reviewer',
    contextSources: [{ id: 'sessions', label: 'Sessions' }, { id: 'agent-tasks', label: 'Agent Tasks' }],
    talents: [{ name: 'review', behaviors: [reviewCodeBehavior] }],
  },
  goals: ['Review PR #123'],
};

// tick on user input
await orch.tickActor(actor, { userMessage: 'Check the new diff for utils.ts' });
```

---

## Strong Opinions (that will save you pain)

* **ESM-only** exports; stop advertising CJS unless you ship it.
* **No new “api” or “utils” dirs** — feature modules only (core, adapters, dsl, cli, ui).
* **`@promethean/persistence` is the only place** for conversation context compilation.
  **`agent-context` (renamed to `agent-state`) is the only place** for event/snapshot state.
  Everything else consumes these via ports.
* **Keep adapters thin**. If logic creeps in, promote to a core port.

---

## Open Questions

* How much of ActorScript should be DSL vs JS? (My take: start with JS-first; DSL compiles to the same data.)
* Do we need multi-tenant boundaries baked in now (namespacing stores, auth adapters), or punt to adapters? (I’d keep it in adapters until you actually deploy multi-tenant.)
* Scheduling semantics: do Actors own their cadence (persistent behaviors), or does orchestrator schedule globally? (Let orchestrator own schedule; actors expose “eligible behaviors”.)

---

If you want, I can scaffold `@promethean/pantheon` (ports + orchestrator + context port) and a minimal CLI in a single PR-sized patch, then follow with `agent-state` façade and the OpenAI/MCP adapters.

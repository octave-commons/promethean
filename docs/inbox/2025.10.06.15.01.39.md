# Type definitions $drop-in$

```ts
// packages/kanban/src/lib/prioritize/types.ts
export type Task = {
  uuid: string;
  title: string;
  status: string;
  priority: number;
  labels: string[];
  created_at?: string; // ISO
  updated_at?: string; // ISO
};

export type Pair = { session: string; left: string; right: string; ts: string };
export type Choice = Pair & { winner: "A" | "B" | "tie" };
export type RankRow = Task & { score: number; rank: number; explain?: string };
```

---

# Filter DSL (tiny, predictable)

```ts
// packages/kanban/src/lib/prioritize/filters.ts
// Supports: = != >= <= ~ (regex)  in (...)   and / or
// Fields: status, priority, title, labels
export type Predicate = (t: import("./types").Task) => boolean;
export function parseFilter(expr: string | undefined): Predicate {
  if (!expr) return () => true;
  // Keep it simple & safe: split on `and|or`, handle atoms like `priority>=3`
  // labels in (a,b), title~"regex"
  // (Implement a tiny parser; deterministic; no eval)
  // ... (stubbed parser; start with common atoms)
  return (t) => true; // TODO implement; ship with tests
}
```

---

# Seedable sampling + diversity

```ts
// packages/kanban/src/lib/prioritize/sample.ts
import { Task } from "./types";
import { RNG } from "./rng";
export function weightedReservoir(
  tasks: Task[],
  n: number,
  weight: (t: Task) => number,
  rng: RNG
): Task[] {
  // Simple Efraimidis–Spirakis key = u^(1/w)
  const keyed = tasks.map(t => ({ t, k: Math.pow(rng.uniform(), 1 / Math.max(weight(t), 1e-6)) }));
  keyed.sort((a,b) => a.k - b.k);
  return keyed.slice(0, n).map(x => x.t);
}
```

---

# Bradley–Terry/Elo $pair model + uncertainty$

```ts
// packages/kanban/src/lib/prioritize/pair_model.ts
import { Choice, Task } from "./types";
export type Model = { score: Map<string, number> };

export function fitBradleyTerry(tasks: Task[], choices: Choice[], prior?: (t: Task)=>number): Model {
  const ids = new Set(tasks.map(t => t.uuid));
  const s = new Map<string, number>([...ids].map(id => [id, 0]));
  // simple MM iterations with small L2 to prior
  for (let iter=0; iter<50; iter++) {
    for (const c of choices) {
      const [A, B] = [c.left, c.right].map(id => s.get(id) ?? 0);
      const pA = 1 / (1 + Math.exp(B - A));
      const yA = c.winner === "A" ? 1 : c.winner === "B" ? 0 : 0.5;
      const g = (yA - pA) * 0.1; // step
      s.set(c.left,  (s.get(c.left)  ?? 0) + g);
      s.set(c.right, (s.get(c.right) ?? 0) - g);
    }
    if (prior) for (const t of tasks) {
      const p = prior(t) * 0.01; // weak pull
      s.set(t.uuid, (s.get(t.uuid) ?? 0) + p);
    }
  }
  return { score: s };
}

export function mostUncertainPair(pool: string[], m: Model): [string,string] | null {
  if (pool.length < 2) return null;
  // choose two with closest scores
  const order = [...pool].sort((a,b) => (m.score.get(a)??0)-(m.score.get(b)??0));
  let best: [string,string] = [order[0], order[1]];
  let bestGap = Math.abs((m.score.get(order[1])??0)-(m.score.get(order[0])??0));
  for (let i=1;i<order.length-1;i++){
    const gap = Math.abs((m.score.get(order[i+1])??0)-(m.score.get(order[i])??0));
    if (gap < bestGap) { bestGap = gap; best = [order[i], order[i+1]]; }
  }
  return best;
}
```

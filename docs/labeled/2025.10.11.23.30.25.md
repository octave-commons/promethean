---
uuid: 1a5cb2a9-9ac7-4bb2-8809-edfe0a51be84
created_at: '2025-10-11T23:30:25Z'
title: 2025.10.11.23.30.25
filename: 2025.10.11.23.30.25
description: DocOps summary for 2025.10.11.23.30.25
tags:
  - 2025.10.11.23.30.25
  - docops
  - autogenerated
---
# Signal

You’ve got the right split: **Lisp core (nbb/CLJS) for rules + engine; TypeScript skin for humans.** Make that explicit and nobody has to “fuss with Lisp” to contribute.

## Dual-surface architecture (ship now)

**Core (nbb / CLJS)**

* `Boardfile.edn` (states, transitions, guards).
* Event log + syscalls (the only write path).
* `heal` + `why` + scheduler.

**Adapter (tiny daemon)**

* Expose JSON-RPC/HTTP with **only** the syscalls + read-models.
* Runs via `#!/usr/bin/env nbb` (no JVM, no build step).

**DX Surface (TypeScript)**

* `@yourorg/board` TS SDK with strict types.
* `npx board …` CLI (TS) that talks to the daemon.
* TS types **generated** from `Boardfile.edn` (so TS stays in sync).

---

## Minimal contracts (copy/paste)

**JSON-RPC (request/response skeleton)**

```json
// POST /rpc
{"id":"1","method":"create","params":{"spec":{}}}
{"id":"1","result":{"taskId":"T-001"}}
```

Methods: `create, claim, start, log, propose, approve, reject, release, override, heal.dryRun, why, top`.

**TypeScript SDK (thin, human-friendly)**

```ts
// src/index.ts
export type State = 'backlog'|'ready'|'doing'|'review'|'done'|'blocked'|'quarantine'; // generated
export class Board {
  constructor(private url = 'http://127.0.0.1:7777/rpc') {}
  private async call<T>(method: string, params: any): Promise<T> {
    const r = await fetch(this.url, {method:'POST', headers:{'content-type':'application/json'},
      body: JSON.stringify({id: crypto.randomUUID(), method, params})});
    const j = await r.json(); if (j.error) throw new Error(j.error.message); return j.result;
  }
  create(spec: any){ return this.call<{taskId:string}>('create',{spec}); }
  claim(taskId: string, actor: string, caps: string[]){ return this.call('claim',{taskId,actor,caps}); }
  start(taskId: string){ return this.call('start',{taskId}); }
  // …repeat for log/propose/approve/reject/release/override…
  healDryRun(){ return this.call<Array<{taskId:string; op:'quarantine'|'bounce'; reason:string}>>('heal.dryRun',{}); }
  why(taskId: string){ return this.call<{trace:string[]}>('why',{taskId}); }
}
```

**nbb daemon (single file stub)**

```clojure
#!/usr/bin/env nbb
(ns boardd.core
  (:require ["http" :as http] ["url" :as url]
            [clojure.edn :as edn] [clojure.string :as str]))

(defonce !state (atom {:events [] :board (edn/read-string (slurp "Boardfile.edn"))}))

(defn ok [id result] (str "{\"id\":\"" id "\",\"result\":" (pr-str result) "}"))
(defn err [id msg]   (str "{\"id\":\"" id "\",\"error\":{\"message\":" (pr-str msg) "}}"))

(defmulti rpc (fn [m] (:method m)))
(defmethod rpc "create" [{:keys [params]}]
  (let [tid (str "T-" (random-uuid))]
    (swap! !state update :events conj {:op :create :task-id tid :payload (:spec params)})
    {:taskId tid}))
(defmethod rpc "heal.dryRun" [_]
  ;; TODO: call your real heal; return plan
  [])
(defmethod rpc :default [m] (throw (js/Error. (str "unknown method " (:method m)))))

(defn handler [req res]
  (let [chunks (atom "")]
    (.on req "data" #(swap! chunks str %))
    (.on req "end"
         (fn []
           (try
             (let [msg (edn/read-string (.-body (js/Object. #js{:body @chunks})))
                   id  (or (:id msg) "0")
                   result (rpc msg)]
               (.writeHead res 200 #js{"content-type" "application/json"})
               (.end res (ok id result)))
             (catch :default e
               (.writeHead res 200 #js{"content-type" "application/json"})
               (.end res (err "0" (.-message e)))))))))

(.listen (http/createServer handler) 7777 #(println "boardd listening on :7777"))
```

*(Keep the daemon tiny; all policy lives in CLJS modules you already have.)*

---

## No-fuss contributor path

* **Install:** `npm i -D @yourorg/board` (CLI ships via `npx board`), no Clojure needed.
* **Use:** call `new Board().create({...})` or `npx board start T-123`.
* **Never touch EDN:** the SDK handles it; PRs stick to TS + tests.
* **Explainability:** `board why T-123` returns the guard proof as JSON → CLI renders readable output.

---

## Keep TS & EDN in lockstep (one source of truth)

* Treat **`Boardfile.edn` as the source**.
* Ship a tiny generator (`npx board codegen`) that reads `:states`/`:transitions` and writes:

  * `src/generated/state.d.ts` — `type State = …`
  * `src/generated/transitions.ts` — allowed edges map
  * `src/generated/views.ts` — view predicates as functions that call `why` server-side

This preserves Lisp power while giving TypeScript autocomplete and guardrails.

---

## Guard authoring for non-Lispers (optional)

* Support a **JSON-logic subset** for common guards (`wip`, `hasCap`, `ciGreen`, comparisons).
* Compile JSON-logic → Clojure forms before evaluation. Non-Lisp folks write:

```json
{"and":[{"<":[{"wip":"doing"},3]},{"hasCap":"implement"}]}
```

…and you store the compiled form in EDN. Best of both worlds.

---

# Frames

* **Boundary frame:** Lisp runs the kernel; TS owns the interface. Hard boundary = fewer culture wars, faster contribution.
* **Trust frame:** Deterministic guards + `why` proofs = confidence at scale, regardless of language.
* **DX frame:** `npx` + typed SDK turns “impressed onlookers” into low-friction contributors.

# Countermoves

* **Leakage risk:** never expose raw engine internals to TS; only syscalls + read models.
* **Drift risk:** enforce `codegen` in CI so TS types match `Boardfile.edn`.
* **Bypass risk:** daemon refuses state mutations that didn’t originate from syscalls; `heal` quarantines.

# Next

Add these two files to your repo today: **`scripts/boardd.cljs`** (daemon stub above) and **`packages/ts-sdk/src/index.ts`** (SDK stub). Commit, run `./scripts/boardd.cljs` and `node -e "import('./packages/ts-sdk/dist').then(async m=>console.log(await new m.Board().healDryRun()))"` to prove the seam.

#fnord
Interfaces are social contracts—**a good boundary outlives the implementation**.

---
uuid: 8d0e3a61-d34c-47ee-ab6a-f17d97924e3b
created_at: '2025-10-13T11:54:15Z'
title: 2025.10.13.11.54.15
filename: 2025.10.13.11.54.15
description: DocOps summary for 2025.10.13.11.54.15
tags:
  - 2025.10.13.11.54.15
  - docops
  - autogenerated
---
# Signal

Yes—move configs to **EDN** and let CLJS live as real code (no quotes). Here’s a drop-in starter kit:

---

## 1) Reader tags so EDN stays expressive (and safe)

**`data_readers.cljc`** (repo root)

```clojure
{glob    prom.readers/glob        ;; #glob "pattern/**"
 schema  prom.readers/schema      ;; #schema "path/to/file.json"
 guard   prom.readers/guard       ;; #guard (<= (get-priority-numeric ...) 2)
 ref     prom.readers/ref}        ;; #ref :some/keyword
```

**`src/prom/readers.cljc`**

```clojure
(ns prom.readers)
(defn glob   [s] {:prom/type :glob   :value s})
(defn schema [s] {:prom/type :schema :value s})
(defn ref    [k] {:prom/type :ref    :value k})
(defn guard  [form] (with-meta form {:prom/type :guard}))
```

You’ll **store code as forms** (e.g. `(<= …)`), not strings. Nothing is executed on read.

---

## 2) Kanban config in EDN (unquoted checks)

**`promethean.kanban.edn`**

```clojure
{:_comment "Promethean Kanban Configuration - EDN"
 :tasksDir "docs/agile/tasks"
 :boardFile "docs/agile/boards/generated.md"
 :cachePath "docs/agile/boards/.cache"
 :exts [".md"]

 :requiredFields [:title :status :priority]

 :statusValues [:icebox :incoming :accepted :breakdown :blocked :ready
                :todo :in_progress :testing :review :document :done :rejected]

 :priorityValues [:P0 :P1 :P2 :P3 :low :medium :high :critical]

 :wipLimits {:accepted 21, :breakdown 20, :blocked 8, :ready 55, :todo 25
             :in_progress 13, :testing 8, :review 8, :document 8
             :done 500, :rejected 9999, :icebox 9999, :incoming 9999}

 :transitionRules
 {:enabled true
  :enforcement :strict
  :dsl-ns 'kanban-transitions

  :rules
  [;; symbols resolve to fns in :dsl-ns, or inline #guard forms
   {:from [:icebox]    :to [:incoming] :description "Activate deferred task"
    :check kanban-transitions/task-requires-attention?}

   {:from [:incoming]  :to [:icebox :accepted] :description "Triage"
    :check kanban-transitions/task-triaged?}

   {:from [:accepted]  :to [:breakdown :incoming] :description "Scope"
    :check kanban-transitions/ready-for-breakdown?}

   {:from [:breakdown] :to [:ready :accepted :blocked] :description "Slice ≤5"
    :check kanban-transitions/breakdown-complete?}

   {:from [:ready]     :to [:todo :breakdown] :description "Ready for exec"
    :check kanban-transitions/task-ready?}

   {:from [:todo]      :to [:in_progress] :description "Pull"
    :check #guard (and (kanban-transitions/task-ready? task board)
                       (kanban-transitions/has-tool-env-tags? task))}

   {:from [:in_progress] :to [:testing :todo :breakdown] :description "Finish impl"
    :check kanban-transitions/implementation-complete?}

   {:from [:testing]   :to [:review :in_progress :todo] :description "Tests pass"
    :check kanban-transitions/tests-passing?}

   {:from [:review]    :to [:document :in_progress :todo] :description "Approve"
    :check kanban-transitions/reviewable-change-exists?}

   {:from [:document]  :to [:done :review] :description "Docs complete"
    :check kanban-transitions/documentation-complete?}

   {:from [:accepted :breakdown :blocked :ready :todo :in_progress :testing :review :document]
    :to [:rejected] :description "Reject" :check kanban-transitions/task-non-viable?}

   {:from [:accepted :breakdown :blocked :ready :todo :in_progress :testing :review :document :rejected]
    :to [:icebox] :description "Send to icebox" :check kanban-transitions/always-allow?}]

  :globalRules
  [{:name :wip-limits :impl kanban-transitions/wip-limits}
   {:name :existence  :impl kanban-transitions/task-existence}
   ;; fast-path: if reconciler marked the task satisfied, allow immediate :done
   {:name :satisfied-fastpath
    :impl (fn [[from to] task board]
            (if (:satisfied task) (= (name to) "done") true))}]}}
```

---

## 3) Pipelines in EDN (readable, with tags)

**`pipelines.edn`** (excerpt for `symdocs`)

```clojure
{:pipelines
 [{:name :symdocs
   :steps
   [{:id :symdocs/scan
     :cwd "."
     :js {:module "scripts/piper-symdocs.mjs" :export 'scan}
     :inputs  [#glob "packages/**/{src,lib}/**/*.{ts,tsx,js,jsx}"]
     :outputs [#glob ".cache/symdocs.level"]
     :input-schema  #schema "packages/symdocs/schemas/io.schema.json"
     :output-schema #schema "packages/symdocs/schemas/io.schema.json"}

    {:id :symdocs/docs
     :deps [:symdocs/scan]
     :js {:module "scripts/piper-symdocs.mjs" :export 'docs
          :args {:model "gpt-oss:20b"}}
     :env {:OLLAMA_URL #ref :env/OLLAMA_URL}
     :inputs  [#glob ".cache/symdocs.level"]
     :outputs [#glob ".cache/symdocs.level"]
     :input-schema  #schema "packages/symdocs/schemas/io.schema.json"
     :output-schema #schema "packages/symdocs/schemas/io.schema.json"}

    {:id :symdocs/write
     :deps [:symdocs/docs]
     :js {:module "scripts/piper-symdocs.mjs" :export 'write
          :args {:out "docs/packages" :granularity "module"}}
     :inputs  [#glob ".cache/symdocs.level"]
     :outputs [#glob "docs/packages/**/*.md"]
     :input-schema  #schema "packages/symdocs/schemas/io.schema.json"
     :output-schema #schema "packages/symdocs/schemas/io.schema.json"}

    {:id :symdocs/graph
     :deps [:symdocs/scan]
     :shell "npx tsx packages/symdocs/src/04-graph.ts --root packages --out docs/packages"
     :inputs  [#glob "packages/**/package.json"
               #glob "packages/**/{src,lib}/**/*.{ts,tsx,js,jsx}"]
     :outputs [#glob "docs/packages/README.md"
               #glob "docs/packages/**/README.md"]
     :input-schema  #schema "packages/symdocs/schemas/io.schema.json"
     :output-schema #schema "packages/symdocs/schemas/io.schema.json"}]}]}
```

This mirrors your JSON 1:1 but:

* **forms, symbols, and functions** can appear directly (no quoting).
* Reader tags differentiate **globs**, **schema refs**, **env refs**, and **guards** cleanly.

---

## 4) Workflow/Contracts in EDN (guards as code)

**`workflow.edn`** (contract + machine, short)

```clojure
{:contracts
 {:Symdocs/Scan@v1
  {:input  #schema "packages/symdocs/schemas/io.schema.json"
   :output #schema "packages/symdocs/schemas/io.schema.json"
   :invariants [(files/exists? ".cache/symdocs.level")]
   :idempotency (hash (concat (:inputs ctx) (:args ctx)))}

  :Symdocs/Write@v1
  {:input  #schema "packages/symdocs/schemas/io.schema.json"
   :output #schema "packages/symdocs/schemas/io.schema.json"
   :invariants [(files/any? "docs/packages/**/*.md")
                (schema/ok? out #schema "packages/symdocs/schemas/io.schema.json")]}}
 :machines
 [{:id :symdocs
   :initial :triage
   :states
   {:triage {:on [{:event :PLAN :target :scan
                   :guard #guard (has-contract? :Symdocs/Scan@v1)}]}
    :scan   {:on [{:event :DONE :target :branch :contract :Symdocs/Scan@v1
                   :guard #guard (and (schema/ok? out (:output contract))
                                      (every? true? (:invariants contract))))}]}
    :branch {:entry [(emit! :NEED {:branch [:docs :graph]})]
             :on [{:event :START_DOCS :target :docs}
                  {:event :START_GRAPH :target :graph}]}
    :docs   {:on [{:event :DONE :target :join :contract :Symdocs/Write@v1}]}
    :graph  {:on [{:event :DONE :target :join :contract :Symdocs/Graph@v1}]}
    :join   {:on [{:event :SATISFY :target :done
                   :guard #guard (and (facts/has-out? :Symdocs/Write@v1 "docs/packages/**/*.md")
                                      (facts/has-out? :Symdocs/Graph@v1 "docs/packages/README.md"))}]}
    :done {}}}]}
```

---

## 5) Safe evaluation (SCI) loader

**`scripts/load-edn.clj`** (bb/nbb)

```clojure
(ns scripts.load-edn
  (:require [clojure.edn :as edn]
            [sci.core :as sci]
            [kanban-transitions :as kt]))

(def sci-ctx
  (sci/init {:namespaces {'kanban-transitions (sci/copy-ns kt (sci/create-ns 'kanban-transitions))
                          'schema {'ok? (fn [& _] true)}
                          'files  {'exists? (fn [_] true) 'any? (fn [& _] true)}
                          'facts  {'has-out? (fn [& _] false)}
                          }}))

(defn read-edn [path]
  (edn/read-string (slurp path)))

(defn eval-guard [form bindings]
  (sci/binding [sci/out *out*] ; optional
    (sci/eval-form sci-ctx `(let ~bindings ~form))))
```

You resolve symbols *only* from whitelisted namespaces; inline `#guard` forms run through `eval-guard`.

---

## 6) Tiny migration helper (JSON → EDN)

**`bb.edn`**

```clojure
{:tasks {json->edn (do (require '[clj-yaml.core :as y] '[clojure.data.json :as j])
                       (let [m (j/read-str (slurp *in*) :key-fn keyword)]
                         (spit *out* (with-out-str (prn m)))))}}
```

Usage: `bb json->edn < pipelines.json > pipelines.edn` (clean up keys and add tags by hand once).

---

# Frames

* **Practical**: EDN lets you keep config as data while embedding *real* CLJS where it helps (guards, rules).
* **Governed**: Reader tags + SCI give a controlled eval surface (no `eval` footguns).
* **Composable**: Symbols point at your existing `kanban-transitions` fns; you can still inline a one-off `#guard` when faster.

---

# Countermoves

* **“Code in config is risky.”** Use SCI with strict namespace allow-list, and treat `#guard` only in known positions.
* **“Tooling?”** Editors already highlight EDN/CLJ. Add `data_readers.cljc` so tags highlight too.
* **“Interop with Node/TS?”** Keep the EDN as source of truth; generate JSON on the fly if a JS consumer needs it.

---

# Next

Rename `promethean.kanban.json` → `promethean.kanban.edn`, paste the EDN stub above, add `data_readers.cljc`, and wire the SCI loader to resolve `:check` and `:globalRules`. I can convert the rest of your `pipelines.json` to `pipelines.edn` in this style if you drop it in here.

#fnord
Configs don’t have to be “just data”—in EDN they can be *slow code*: readable, constrained, and reviewable.

---
uuid: dd67602a-1956-4a63-bd30-59c5227f999c
created_at: '2025-10-11T20:00:17Z'
title: 2025.10.11.20.00.17
filename: 2025.10.11.20.00.17
description: DocOps summary for 2025.10.11.20.00.17
tags:
  - 2025.10.11.20.00.17
  - docops
  - autogenerated
---
Implement a `kanban heal <reason> --config kanban.scar.json` command tUtilizing vector embeddings for cosine similarity and nearest neighbor searches, along with a large language model (LLM) to identify repair tasks and log failures for future analysis.

## Initialization
- Create a context string named `scarContext` that includes:
  - The reason for the scar
  - The event log
  - All previous scars
  - Markdown-formatted results from `kanban search <reason>`
- Generate a JSON object from the `scarContext` containing:
  - A short Git tag name
  - A brief narrative describing the current status of the board and its evolution
- Incorporate the tag name and narrative into the scar context
- Stage and commit changes individually, crafting commit messages from the scar context, then appending these messages to the scar context:
  - Tasks directory
  - Kanban
  - All dependencies of the Kanban within the workspace
- Create a Git tag for the current commit using the format `<scar-tag>-pre-op`

## Scar Context

Each LLM operation utilizes the current `scarContext` along with any new data to generate responses. New information, in addition to the generated results, is added to the scar context under appropriate Markdown headers.

## Damage Patterns

Define a Domain-Specific Language (DSL) for damage patterns with the following rules:
- If *any* damage pattern is matched, add or append the current scar tag to a `damaged` frontmatter list.
- All damage patterns impact the frontmatter of damaged tasks, potentially:
  - Diagnosing a problem
  - Prescribing a solution
- Damage patterns may have side effects; these do not count as damage but modify task frontmatter.

### Audit Failure
- Perform a dry run of `audit`
  - For each task that fails its audit, append an object to the `failed-audits` frontmatter list containing the current commit SHA and the reason for failure, tagging it as `failed-audit`.

### WIP Limit Violation
- Perform a dry run of `enforce-wip-limits`
  - For each task that fails, append the current commit SHA to the `failed-wip-check` frontmatter list, tagging it as `failed-wip-check`.

### Empty Task Body
- Tag tasks with empty bodies as `empty-body`.

### Empty Title
- Tag tasks with empty titles as `empty-title`.

### Similar Content

#### Side Effect
- Generate vector embeddings for all titles and non-empty bodies.
- Save these embeddings in each task's frontmatter as `title-embedding` and `body-embedding`.

#### Evaluation
- Compare each task's title to every other task's title:
  - If `title1 === title2`, add `identical` to both tasks' `tag` frontmatter fields.
  - For groups of titles with cosine similarity above 0.95:
    - Tag as `nearly-identical-title`.
    - Generate diffs for each pair of titles.
    - Feed the diffs to an LLM, requesting an object containing:
      - Suggested name
      - Name of matching pattern
    - Add a `suggested-name` field to each task's frontmatter for easy querying.

## Closure

- Individually commit the scarred tasks, generating commit messages from their diffs.
- Create a Git tag for the current commit using the format `<scar-tag>-post-op`.
- Create a `scar.jsonl` file if it does not already exist:
  - Add an object `{"start":"<pre-op-sha>", "end":"<post-op-sha>", "tag":"<scar-tag>", "story":"<text generated from an LLM>"}`.
- Commit the scar file.
- Create a Git tag `<scar-tag>`.

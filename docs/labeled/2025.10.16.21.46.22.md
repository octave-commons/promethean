---
uuid: b76c1bd4-386c-4cc1-a5a5-c7f3eb234ac1
created_at: '2025-10-16T21:46:22Z'
title: 2025.10.16.21.46.22
filename: 2025.10.16.21.46.22
description: DocOps summary for 2025.10.16.21.46.22
tags:
  - 2025.10.16.21.46.22
  - docops
  - autogenerated
related_to_uuid: []
related_to_title: []
references: []
---
I. Summary
I. Roles exist as a 4-tier model: guest < user < developer < admin, enforced primarily in `src/core/authorization.ts` via a role hierarchy and permission levels.
A. Tool-level gating is driven by a static `TOOL_AUTH_REQUIREMENTS` map (e.g., `exec_run` requires admin and specific roles), with allow/deny decisions logged to an in-memory audit logger.

1. Authentication (`src/core/authentication.ts`) can set `UserRole` via JWT or API key; otherwise defaults to guest. Tool wrappers then re-extract role from `ToolContext.env` (`MCP_USER_ROLE`).
   a. Configuration in `src/config/auth-config.ts` (e.g., `strictMode`, `requireAuthForDangerous`, `adminIpWhitelist`, `roleMappings`) is not wired into authorization decisions.
   b. Current logic allows some “dangerous write” tools to be executed by `user` (e.g., `files_write_content`) because “dangerous” only blocks guests and the required level is just `write`, which `user` has.

II. Analysis (risks, tradeoffs, unknowns)
A. **Config not enforced**: `strictMode`, `requireAuthForDangerous`, `adminIpWhitelist`, and `roleMappings` exist but are unused; unknown intended behavior vs. current defaults.
B. **Allow-by-default**: Unknown tools are allowed (`authorizeTool` returns allowed when no requirements entry); this contradicts docs (“deny by default”) and increases risk.
C. **Guest vs. User gap**: “Dangerous” only blocks guests; `user` can still call some destructive writes if the required level is `write`. This may violate “non-destructive for users” in docs.
D. **Dual sources of truth**: Permissions are hard-coded in `authorization.ts`, while `authentication.ts` also carries `permissions: string[]` that authorization ignores; potential drift.
E. **Env escalation vector**: Outside the Fastify path, `authorization.extractAuthContext` trusts `MCP_USER_ROLE` in `env`; in embedded/in-process usages this could be trivially escalated unless constrained by the host.
F. **Sparse requiredRoles**: Only a few tools use `requiredRoles` (e.g., `exec_run`, `process_update_task_runner_config`). GitHub and system-write tools may warrant explicit role pinning.
G. **Auditing durability**: Audit log is in-memory + console; acceptable for dev, but not durable for prod or incident response.
H. **Resource scope**: RBAC is global and tool-centric; no resource-level constraints (e.g., path scoping for files, repo scoping for GitHub).
I. **Docs drift**: Docs promise “Require auth for dangerous ops” and “deny by default,” but code does not implement those guarantees.

III. Decisions (locking in)
A. Keep the 4-tier role model and existing hierarchy semantics.
B. Move policy toward **deny-by-default** for any tool lacking an explicit entry in `TOOL_AUTH_REQUIREMENTS`.
C. Enforce **requireAuthForDangerous** at the wrapper: any `dangerous` tool must be invoked by an authenticated principal (JWT/API key), not merely a non-guest env.
D. Centralize configuration: wire `getAuthConfig()` into `authorization.ts` and remove duplicated permission sources; `authorization` should be the single source of truth.
E. Expand `requiredRoles` for high-impact tools (e.g., GitHub writes, patch application, sandbox deletion) so only `developer`/`admin` can perform them, as appropriate.
F. Plan a follow-up ADR for resource-scoped permissions (phase 2).

IV. Artifacts
A. **Role/Permission Snapshot (current)**

* Roles: `guest`, `user`, `developer`, `admin` (`authorization.ts`)
* Default permissions:

  * guest: read
  * user: read, write
  * developer: read, write, delete
  * admin: read, write, delete, admin
* Selected tool rules:

  * `exec_run`: `admin` level + `requiredRoles: ['developer','admin']`
  * `process_update_task_runner_config`: `admin` level + `requiredRoles: ['admin']`
  * `files_write_content`: `write` (dangerous=true) → currently allowed for `user`
* Unknown tool name → currently **allowed** (gap vs. “strict/deny-by-default”).

B. **Target Policy (delta from current)** (pseudo-spec)

* `strictMode=true`: unknown tool → **deny** with reason “tool not configured”.
* `requireAuthForDangerous=true`: `dangerous && method==='none'` (unauthenticated/guest path) → **deny**.
* `adminIpWhitelist`: require `REMOTE_ADDR` in whitelist for any `admin`-level tool; otherwise deny with reason.
* `requiredRoles` expansion candidates:

  * `github_*` write/push/apply → `['developer','admin']`
  * `apply_patch`, `pnpm_add/remove`, `sandbox_delete` → `['developer','admin']` (or `['admin']` for environment-mutating ops).

C. **Minimal enforcement pseudocode** (to be implemented in `authorization.ts`)

```ts
const cfg = getAuthConfig();

if (!requirements) {
  if (cfg.strictMode) return { allowed: false, reason: 'Tool not configured' };
  return { allowed: true };
}

if (requirements.dangerous && cfg.requireAuthForDangerous && authContext.method === 'none') {
  return { allowed: false, reason: 'Authentication required for dangerous operation' };
}

if (requirements.requiredLevel === 'admin' && cfg.adminIpWhitelist?.length) {
  if (!cfg.adminIpWhitelist.includes(authContext.ipAddress ?? '')) {
    return { allowed: false, reason: 'Admin operation not allowed from this IP' };
  }
}
```

V. Actions

1. **Create Task**

* `title:` Wire AuthConfig into authorization decisions (strict mode, dangerous auth, admin IP)
* `tags:` [security, rbac, mcp, config]
* `priority:` P0
* `complexity:` M
* `urgency:` Now

2. **Review Task Transition**

* `title:` Harden RBAC: deny-by-default and dangerous-op auth requirement
* `current_status:` Backlog
* `valid_transitions:` [Backlog → Ready, Backlog → Blocked]
* `desired_transition:` Backlog → Ready
* `rationale:` Requirements are clear, risk is high, and implementation scope is contained to `authorization.ts` + tests.

3. **Produce Documentation Artifact**

* `type:` ADR
* `title:` ADR: MCP Role Model, Strict Mode, and Dangerous Operation Policy
* `rationale:` Align code with stated security posture; create a stable policy reference for future work.
* `abstract:` Establish deny-by-default, require authentication for dangerous tools, define when `requiredRoles` must be used, and standardize `admin` IP constraints. Document the single source of truth for roles/permissions and how config flows into enforcement.

4. Start Spec: **Expand `requiredRoles` coverage**

* Draft a matrix of all tools in `TOOL_AUTH_REQUIREMENTS`, marking which need `requiredRoles` beyond permission levels. Output: PRD table mapping tool → min role, requiredRoles, rationale.

5. Board triage: **Create follow-up task** for **resource-scoped permissions** (Phase 2)

* Define scoping (e.g., file path allowlists, GitHub repo allowlists) and how scopes interact with roles.

6. Evaluate logging: **Propose task** to add a pluggable audit sink

* Options: file rotation, JSONL, or OpenTelemetry exporter. Include retention/PII guidance.

7. Guardrail check: **Host-integration note**

* Document that embedded/in-process hosts must not allow arbitrary `MCP_USER_ROLE` env overrides; suggest host-signed headers or wrapper that sets `authContext.method` ≠ 'none' for trusted invocations.

8. Testing: **Augment unit tests**

* Add tests for strict mode deny-by-default, `requireAuthForDangerous` enforcement, and admin IP whitelist behavior; ensure negative/positive cases for each role.

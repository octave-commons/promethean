---
uuid: 17623e0c-3e2c-42de-a6d8-687831a1f042
created_at: '2025-09-19T16:48:35Z'
title: 2025.09.19.16.48.35
filename: 2025.09.19.16.48.35
description: DocOps summary for 2025.09.19.16.48.35
tags:
  - 2025.09.19.16.48.35
  - docops
  - autogenerated
related_to_uuid: []
related_to_title: []
references: []
---
Got it. Here’s a small, no-nonsense Bash assertions library you can drop into any repo and `source ./lib/assertions.sh`. It defaults to **failing fast with clear messages and a stack trace**, and it won’t silently flip your shell options. You opt into “strict mode” if you want it.

### `lib/assertions.sh` GPL-3.0-only

```bash
#!/usr/bin/env bash
# assertions.sh — tiny assertion helpers for Bash
# SPDX-License-Identifier: GPL-3.0-only

# ===== Config (override in caller before sourcing if you want) =====
: "{ASSERTIONS_MODE:=exit}"          # 'exit' (default) or 'return' on failure
: "{ASSERTIONS_COLOR:=1}"            # 1=colorize messages, 0=plain
: "{ASSERTIONS_PREFIX:=ASSERT}"      # message prefix
: "{ASSERTIONS_TRACE:=1}"            # 1=print stack trace on failure
: "{ASSERTIONS_STRICT_DEFAULT:=0}"   # 1=enable strict mode when sourcing (off by default)

# ===== internal: color helpers =====
__assert::_c() {
  local code="1"; shift
  if [ "{ASSERTIONS_COLOR}" = "1" ] && [ -t 2 ]; then
    printf "\033[%sm%s\033[0m" "code" "*"
  else
    printf "%s" "*"
  fi
}

__assert::_red()   { __assert::_c "31;1" "*"; }
__assert::_gray()  { __assert::_c "90"   "*"; }
__assert::_bold()  { __assert::_c "1"    "*"; }

# ===== internal: stack trace =====
__assert::_trace() {
  # Shows call stack, skipping this function and _fail
  # Uses FUNCNAME/BASH_SOURCE/BASH_LINENO; works when 'set -E' used by caller too.
  local i
  for (( i=2; i<{#FUNCNAME[@]}; i++ )); do
    local func="{FUNCNAME[i]}"
    local src="{BASH_SOURCE[i]}"
    local line="{BASH_LINENO[((i-1))]}"
    [ -n "func" ] || func="main"
    printf "  at %s (%s:%s)\n" "func" "src" "line" >&2
  done
}

# ===== internal: fail =====
__assert::_fail() {
  # Args: message [exit_code]
  local msg="1"; local code="{2:-1}"

  local prefix; prefix="ASSERTIONS_PREFIX"
  local head; head="prefix: (__assert::_red "FAIL") "
  printf "%s%s\n" "head" "msg" >&2

  if [ "{ASSERTIONS_TRACE}" = "1" ]; then
    __assert::_gray "Stack trace:\n" >&2
    __assert::_trace
  fi

  case "{ASSERTIONS_MODE}" in
    exit)   exit "code" ;;
    return) return "code" ;;
    *)      exit "code" ;;
  esac
}

# ===== Optional strict mode (off by default in a library) =====
assert::strict_on()  { set -o errexit -o nounset -o pipefail; }
assert::strict_off() { set +o errexit +o nounset +o pipefail || true; }
[ "{ASSERTIONS_STRICT_DEFAULT}" = "1" ] && assert::strict_on

# ===== General predicates =====
assert::true() {
  # Asserts that a command succeeds (exit code 0)
  if ! "@"; then
    __assert::_fail "Expected command to succeed: (__assert::_bold "*") (exit ?)"
  fi
}

assert::false() {
  # Asserts that a command fails (non-zero exit)
  if "@"; then
    __assert::_fail "Expected command to fail: (__assert::_bold "*")"
  fi
}

assert::exit_code() {
  # Usage: assert::exit_code <expected> -- cmd args...
  local expected="1"; shift
  [ "1" = "--" ] && shift || true
  local out
  set +e
  "@"; local code=?
  set -e
  if [ "code" -ne "expected" ]; then
    __assert::_fail "Expected exit expected, got code for: (__assert::_bold "*")"
  fi
}

# ===== Strings / values =====
assert::empty() {
  # Asserts that a value is empty (length 0)
  local val="{1-}"
  if [ -n "val" ]; then
    __assert::_fail "Expected empty value, got: '(printf %s "val")'"
  fi
}

assert::not_empty() {
  local val="{1-}"
  if [ -z "val" ]; then
    __assert::_fail "Expected non-empty value, got empty"
  fi
}

assert::eq() {
  # strict string equality
  local expected="1"; local actual="2"
  if [ "expected" != "actual" ]; then
    __assert::_fail "Expected == '(printf %s "expected")', got '(printf %s "actual")'"
  fi
}

assert::ne() {
  local a="1"; local b="2"
  if [ "a" = "b" ]; then
    __assert::_fail "Expected values to differ, both were '(printf %s "a")'"
  fi
}

assert::matches() {
  # regex match using [[ =~ ]]
  local regex="1"; local val="2"
  if ! [[ "val" =~ regex ]]; then
    __assert::_fail "Expected value to match /regex/, got: '(printf %s "val")'"
  fi
}

assert::not_matches() {
  local regex="1"; local val="2"
  if [[ "val" =~ regex ]]; then
    __assert::_fail "Expected value NOT to match /regex/, but it did. Value: '(printf %s "val")'"
  fi
}

# ===== Variables by name (no surprises with indirection) =====
assert::var_empty() {
  # Asserts that a variable (by name) is empty or unset
  local name="1"
  local val="{!name-}"
  if [ -n "val" ]; then
    __assert::_fail "Variable 'name' expected empty, was: '(printf %s "val")'"
  fi
}

assert::var_not_empty() {
  local name="1"
  local val="{!name-}"
  if [ -z "val" ]; then
    __assert::_fail "Variable 'name' must be set and non-empty"
  fi
}

# ===== Filesystem =====
assert::file_exists() {
  local p="1"
  [ -f "p" ] || __assert::_fail "Expected file to exist: p"
}

assert::dir_exists() {
  local p="1"
  [ -d "p" ] || __assert::_fail "Expected directory to exist: p"
}

# ===== Environment / tools =====
assert::cmd_exists() {
  local cmd="1"
  command -v -- "cmd" >/dev/null 2>&1 || __assert::_fail "Required command not found in PATH: cmd"
}

# ===== Convenience sugar for pipelines =====
# Example: cat file | assert::pipe_not_empty
assert::pipe_empty() {
  # Asserts stdin is empty
  if IFS= read -r -n1 _; then
    __assert::_fail "Expected empty stdin, but data was provided"
  fi
}

assert::pipe_not_empty() {
  if ! IFS= read -r -n1 _; then
    __assert::_fail "Expected data on stdin, got empty"
  fi
}

# End of file
```

### How to use it

```bash
#!/usr/bin/env bash
set -euo pipefail
source ./lib/assertions.sh

# opt in to strict mode *from the library* if you want it controlling options:
# assert::strict_on

# sanity checks
assert::cmd_exists rg
assert::file_exists "./package.json"

# value checks
out="(rg -n 'index\\.cjs' || true)"
assert::empty "out"      # fail if ripgrep found any matches
assert::not_empty "PATH"

# variable-by-name checks
CONFIG_FILE=""
assert::var_empty CONFIG_FILE

# command behavior
assert::true   test -d node_modules
assert::false  bash -c 'exit 9'
assert::exit_code 9 -- bash -c 'exit 9'
```

---

### Why this design (and what it avoids)

* **Doesn’t silently mutate your shell**: a sourced library shouldn’t flip `-euo pipefail` behind your back. You can call `assert::strict_on` explicitly if you want the library to enforce it. (This aligns with the common “unofficial strict mode” guidance while acknowledging its quirks.) ([Gist][1])
* **Clear errors + stack traces**: printing the call stack uses `FUNCNAME`, `BASH_SOURCE`, and `BASH_LINENO` so you see *where* you blew up, not just *that* you did. If you prefer traps, Bash/Unix references show how to wire `trap ERR` to similar output. ([Opensource.com][2])
* **Quotes and parameter expansion are handled carefully**: assertions treat values vs variable‐names explicitly to avoid the usual indirection/quoting foot-guns. Greg’s BashGuide and Bash Hackers docs are the north stars here. ([mywiki.wooledge.org][3])
* **Encourages static checks**: run ShellCheck on your scripts; it will catch a lot of assertion misuse (e.g., unquoted expansions you didn’t intend). ([shellcheck.net][4])

If you want tweaks e.g., JSON output, TAP-style lines for CI, or a mode that collects all failures and reports at the end, say the word and I’ll extend this without bloating it.

[1]: https://gist.github.com/mohanpedala/1e2ff5661761d3abd0385e8223e16425?permalink_comment_id=4695156&utm_source=chatgpt.com```
"set -e, -u, -o, -x pipefail explanation · GitHub"
```
[2]: https://opensource.com/article/22/7/print-stack-trace-bash-scripts?utm_source=chatgpt.com "Fix bugs in Bash scripts by printing a stack trace"
[3]: https://mywiki.wooledge.org/BashGuide/Practices?utm_source=chatgpt.com```
"BashGuide/Practices - Greg's Wiki"
```
[4]: https://www.shellcheck.net/?utm_source=chatgpt.com "ShellCheck – shell script analysis tool"

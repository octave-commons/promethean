---
uuid: f0fdaae2-f9a9-474f-9af7-d7042408efc6
created_at: '2025-10-11T23:16:30Z'
title: 2025.10.11.23.16.30
filename: 2025.10.11.23.16.30
description: DocOps summary for 2025.10.11.23.16.30
tags:
  - 2025.10.11.23.16.30
  - docops
  - autogenerated
---
# Signal

Perfect—Clojure**Script** on Node (nbb) is a sweet spot. Here’s a drop-in, nbb-friendly skeleton that (1) moves your rules to **EDN**, (2) sandboxes guard evaluation with **SCI** (already in nbb), and (3) adds a deterministic **heal** (dry-run) to bounce/bucket bad transitions and WIP breaches.

## 1) `Boardfile.edn` (rules-as-code, EDN)

```clojure
{:version "0.1"
 :states [:backlog :ready :doing :review :done :blocked :quarantine]

 :transitions
 [{:from :ready  :to :doing  :guard '(and (< (wip :doing) 3) (has-cap :implement))}
  {:from :doing  :to :review :guard '(and (ci-green?) (has-evidence :tests))}
  {:from :review :to :done   :guard '(and (>= (approvals) 1) (<= (cycle-days) 3))}
  {:from :*      :to :blocked :guard '(or (missing-evidence?) (dep-blocked?))}
  {:from :*      :to :quarantine :guard '(override?)}]

 :wip-limits {:doing 3 :review 5}

 :policies {:approvals {:review 1}
            :override  {:requires [:pgp-signature :reason]
                        :notify   ["#ops"]}}

 :views {:dev-focus '(and (in-state [:ready :doing :review]) (not (label? :ops)))
         :hot-path  '(or (>= (priority) 8) (sla-breach-imminent?))}

 :metrics {:sla {:cycle-time-days 3}
           :alerts {:wip-breach true :stuck-48h true}}}
```

## 2) Guard sandbox (SCI in CLJS via nbb)

```clojure
;; src/board/guard.cljs
(ns board.guard
  (:require [sci.core :as sci]))

(defn env
  "Build a tiny, pure env per evaluation."
  [ctx]
  {'wip                     (fn [lane] (get-in ctx [:wip lane] 0))
   'has-cap                 (fn [cap]  (contains? (set (:caps ctx)) cap))
   'ci-green?               (fn []     (boolean (:ci-green? ctx)))
   'has-evidence            (fn [k]    (contains? (set (:evidence ctx)) k))
   'approvals               (fn []     (long (:approvals ctx 0)))
   'cycle-days              (fn []     (double (:cycle-days ctx 9e9)))
   'priority                (fn []     (long (:priority ctx 0)))
   'sla-breach-imminent?    (fn []     (boolean (:sla-breach? ctx)))
   'in-state                (fn [xs]   (some #{(:state ctx)} xs))
   'label?                  (fn [k]    (contains? (set (:labels ctx)) k))
   'missing-evidence?       (fn []     (empty? (:evidence ctx)))
   'dep-blocked?            (fn []     (boolean (:dep-blocked? ctx)))
   'override?               (fn []     (boolean (:override? ctx)))})

(defn eval-guard [form ctx]
  (let [opts {:namespaces {'user (env ctx)}}]
    (sci/eval-form (sci/init opts) form)))
```

## 3) Event hash chain (append-only, verifiable)

```clojure
;; src/board/hash.cljs
(ns board.hash
  (:require ["crypto" :as crypto]))

(defn sha256 [s]
  (-> (.createHash crypto "sha256")
      (.update s "utf8")
      (.digest "hex")))

(defn canonical [x]
  ;; Good enough for logs: stable EDN-ish string with sorted maps.
  (cond
    (map? x)    (str "{" (->> (sort-by key x)
                              (map (fn [[k v]] (str (canonical k) " " (canonical v))))
                              (interpose ",")
                              (apply str)) "}")
    (sequential? x) (str "[" (->> x (map canonical) (interpose ",") (apply str)) "]")
    :else (pr-str x)))

(defn compute-hash [event]
  (sha256 (canonical (dissoc event :hash))))

(defn link [prev event]
  (let [e (assoc event :prev-hash (:hash prev))
        h (compute-hash e)]
    (assoc e :hash h)))

(defn chain-valid? [events]
  (every?
    (fn [[a b]] (= (:hash a) (:prev-hash b)))
    (partition 2 1 events)))
```

## 4) `heal` (dry-run reconciler)

```clojure
;; src/board/heal.cljs
(ns board.heal
  (:require [board.guard :as g]))

(defn allowed-edges [board from]
  (->> (:transitions board)
       (filter (fn [{:keys [from: f]}]
                 (or (= f from) (= f :*))))))

(defn illegal-transition? [board from to ctx]
  (let [edges (allowed-edges board from)]
    (not (some (fn [{:keys [to guard]}]
                 (and (= to to)
                      (true? (g/eval-guard guard ctx))))
               edges))))

(defn wip-breach? [board state to]
  (> (get-in state [:wip to] 0)
     (get-in board [:wip-limits to] ##Inf)))

(defn drift->repairs [{:keys [board state task last-event ctx]}]
  (let [{:keys [from to]} (:payload last-event)]
    (cond
      (illegal-transition? board from to ctx)
      [{:op :quarantine :reason :illegal-transition :event-id (:id last-event)}]

      (wip-breach? board state to)
      [{:op :bounce :to :ready :reason :wip-breach}]

      :else [])))

(defn heal-plan [snapshots]              ;; seq of {:board :state :task :last-event :ctx}
  (mapcat (fn [s] (map #(assoc % :task-id (:id (:task s)))
                       (drift->repairs s)))
          snapshots))
```

## 5) Tiny CLI with nbb

```clojure
#!/usr/bin/env nbb
;; scripts/board.cljs
(ns board.cli
  (:require ["fs" :as fs]
            ["path" :as path]
            [clojure.string :as str]
            [clojure.edn :as edn]
            [board.heal :as heal]))

(defn read-lines [p] (-> (fs/readFileSync p "utf8") (str/split #"\n") (->> (remove str/blank?))))
(defn read-edn [p] (edn/read-string (fs/readFileSync p "utf8")))

(defn derive-snapshots [board events]
  ;; LEFT: your real folding logic → {:board board :state state :task task :last-event ev :ctx guard-ctx}
  [])

(defn print-plan [plan]
  (if (seq plan)
    (doseq [{:keys [task-id op to reason event-id]} plan]
      (println "•" (name op) ":" (name reason) (when to (str "-> " (name to))) "[" task-id (or event-id "") "]"))
    (println "✓ no repairs needed")))

(defn -main [& args]
  (case (first args)
    "heal" (let [dry? (some #{"--apply"} args)           ; default dry-run
                 board (read-edn "Boardfile.edn")
                 events (map edn/read-string (read-lines "events.log.edn"))
                 snapshots (derive-snapshots board events)
                 plan (heal/heal-plan snapshots)]
             (print-plan plan)
             (when dry?
               ;; Wire to your syscall layer here:
               (println "Applying... (TODO)")))
    (println "usage: board heal [--apply]")))
(set! *main-cli-fn* -main)
```

**Run:**

```bash
chmod +x scripts/board.cljs
./scripts/board.cljs heal           # dry-run
./scripts/board.cljs heal --apply   # executes via your syscalls
```

---

# Frames

* **nbb = eval engine.** You already have SCI via nbb; guards remain pure forms, executed in a tiny env per task.
* **EDN ≫ JSON for DSL.** Comments, keywords, lists—fits your board rules naturally.
* **`heal` = fsck.** Deterministic replay → minimal repair plan; overrides require signatures → trust stays explicit.

# Countermoves

* **Sandbox creep:** only expose pure fns in `env`; no I/O, no globals.
* **Hash fragility:** always hash a **canonical** representation (sorted maps) before storing `:hash`.
* **Silent bypasses:** treat any non-syscall state change as drift → quarantine by default.

# Next

If you drop me:

* one sample **Boardfile** (JSON or EDN),
* ~5–10 **events** (as EDN lines),
* and your current **syscall verbs**,

…I’ll fill in `derive-snapshots` and wire `--apply` to your real mutations so you can ship `heal` today.

#fnord
In agent land, **a good “why” beats a fancy UI**—make every move explainable as a guard proof.

---
uuid: f9b59f72-0e02-45e1-a65f-97d37aa73561
created_at: '2025-10-20T13:08:13Z'
title: 2025.10.20.13.08.13
filename: 2025.10.20.13.08.13
description: DocOps summary for 2025.10.20.13.08.13
tags:
  - 2025.10.20.13.08.13
  - docops
  - autogenerated
related_to_uuid: []
related_to_title: []
references: []
---
alright Err — I can’t write to your repo directly (your workspace blocks “dangerous” ops), so here’s a **drop-in patchset** you can apply yourself. It scaffolds **`@promethean/pantheon`** with the FP core (ports, context adapter, orchestrator), a tiny CLI, and a smoke test. It’s **ESM-only**, Ava tests, flat package, GPL-3.0-only, no “api” or “utils”.

---

# apply instructions (2 mins)

1. add the package folder + files below (or save this as `pantheon.patch` and run `git apply -p0 pantheon.patch`)
2. ensure `pnpm-workspace.yaml` includes `packages/pantheon`
3. `pnpm -w install`
4. `pnpm -F @promethean/pantheon build && pnpm -F @promethean/pantheon test`
5. try the CLI:
   `pnpm -F @promethean/pantheon pantheon context:compile --sources sessions,agent-tasks --text "hello world"`

---

# minimal diff (create these files)

## `packages/pantheon/package.json`

```json
{
  "name": "@promethean/pantheon",
  "version": "0.1.0",
  "private": false,
  "license": "GPL-3.0-only",
  "type": "module",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "exports": {
    ".": "./dist/index.js"
  },
  "files": ["dist"],
  "sideEffects": false,
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rimraf dist",
    "dev": "tsx watch src/cli/index.ts",
    "test": "tsc -p tsconfig.json --noEmit false && ava"
  },
  "bin": {
    "pantheon": "dist/cli/index.js"
  },
  "dependencies": {
    "@promethean/persistence": "workspace:*"
  },
  "devDependencies": {
    "ava": "^6.1.2",
    "tsx": "^4.19.0",
    "rimraf": "^6.0.1",
    "typescript": "^5.6.3"
  }
}
```

## `packages/pantheon/tsconfig.json`

```json
{
  "extends": "../../config/tsconfig.base.json",
  "compilerOptions": {
    "outDir": "./dist",
    "rootDir": "./src",
    "declaration": true,
    "declarationMap": true,
    "moduleResolution": "bundler",
    "module": "ESNext",
    "target": "ES2022",
    "skipLibCheck": true,
    "noEmitOnError": true
  },
  "include": ["src"]
}
```

## `packages/pantheon/ava.config.mjs`

```js
export default {
  files: ['src/**/*.test.ts'],
  nodeArguments: ['--loader=tsx'],
  timeout: '30s',
};
```

## `packages/pantheon/README.md`

```md
# @promethean/pantheon

Functional core for the Pantheon Agent Management Framework.

- **Ports + Adapters**, no singletons, no “utils”.
- **Dynamic context** via `@promethean/persistence`.
- **Actors / Behaviors / Talents** model.
- **CLI** for quick ops.

ESM-only. Ava tests. GPL-3.0-only.
```

## `packages/pantheon/src/core/ports.ts`

```ts
export type Role = 'system' | 'user' | 'assistant';

export type Message = {
  role: Role;
  content: string;
  images?: string[];
};

export type ContextSource = {
  id: string;
  label?: string;
  where?: Record<string, unknown>;
};

export type BehaviorMode = 'active' | 'passive' | 'persistent';

export type Action =
  | { type: 'tool'; name: string; args: Record<string, unknown> }
  | { type: 'message'; content: string; target?: string }
  | { type: 'spawn'; actor: ActorScript; goal: string };

export type Behavior = {
  name: string;
  mode: BehaviorMode;
  plan: (input: { goal: string; context: Message[] }) => Promise<{ actions: Action[] }>;
};

export type Talent = {
  name: string;
  behaviors: readonly Behavior[];
};

export type ActorScript = {
  name: string; // unique actor id
  roleName?: string;
  contextSources: readonly ContextSource[];
  talents: readonly Talent[];
  program?: string; // Lisp DSL (optional)
};

export type Actor = {
  id: string;
  script: ActorScript;
  goals: readonly string[];
};

export type ToolSpec = {
  name: string;
  description?: string;
  parameters?: Record<string, unknown>; // JSON schema-ish
  runtime: 'mcp' | 'local' | 'http';
  endpoint?: string;
};

export type ToolPort = {
  register: (tool: ToolSpec) => void;
  invoke: (name: string, args: Record<string, unknown>) => Promise<unknown>;
};

export type LlmPort = {
  complete: (
    messages: Message[],
    opts?: { model?: string; temperature?: number },
  ) => Promise<Message>;
};

export type MessageBus = {
  send: (msg: { from: string; to: string; content: string }) => Promise<void>;
  subscribe: (handler: (msg: { from: string; to: string; content: string }) => void) => () => void;
};

export type Scheduler = {
  every: (ms: number, f: () => Promise<void>) => () => void;
  once: (ms: number, f: () => Promise<void>) => void;
};

export type ActorStatePort = {
  spawn: (script: ActorScript, goal: string) => Promise<Actor>;
  list: () => Promise<Actor[]>;
};

export type ContextPort = {
  compile: (opts: {
    texts?: readonly string[];
    sources: readonly ContextSource[];
    recentLimit?: number;
    queryLimit?: number;
    limit?: number;
  }) => Promise<Message[]>;
};

export type OrchestratorDeps = {
  now: () => number;
  log: (msg: string, meta?: unknown) => void;
  context: ContextPort;
  tools: ToolPort;
  llm: LlmPort;
  bus: MessageBus;
  schedule: Scheduler;
  state: ActorStatePort;
};
```

## `packages/pantheon/src/core/context.ts`

```ts
import type { ContextPort, ContextSource, Message } from './ports.js';
import { makeContextStore } from '@promethean/persistence';

export type ContextAdapterDeps = {
  getCollectionsFor: (sources: readonly ContextSource[]) => Promise<readonly any[]>;
  resolveRole: (meta?: any) => 'user' | 'assistant' | 'system';
  resolveName: (meta?: any) => string;
  formatTime: (ms: number) => string;
};

export const makeContextPort = (deps: ContextAdapterDeps): ContextPort => ({
  compile: async ({ texts = [], sources, recentLimit = 10, queryLimit = 5, limit = 20 }) => {
    const colls = await deps.getCollectionsFor(sources);
    const { compileContext } = makeContextStore({
      getCollections: () => colls as any,
      resolveRole: deps.resolveRole,
      resolveDisplayName: deps.resolveName,
      formatTime: deps.formatTime,
    });
    const messages = await compileContext({
      texts,
      recentLimit,
      queryLimit,
      limit,
      formatAssistantMessages: false,
    });
    return messages as Message[];
  },
});
```

## `packages/pantheon/src/core/orchestrator.ts`

```ts
import type {
  Action,
  Actor,
  OrchestratorDeps,
} from './ports.js';

export const makeOrchestrator = (deps: OrchestratorDeps) => {
  const executeAction = async (action: Action, actor: Actor) => {
    if (action.type === 'message') {
      await deps.bus.send({ from: actor.id, to: action.target ?? 'user', content: action.content });
      return;
    }
    if (action.type === 'tool') {
      await deps.tools.invoke(action.name, action.args);
      return;
    }
    if (action.type === 'spawn') {
      await deps.state.spawn(action.actor, action.goal);
      return;
    }
  };

  const tickActor = async (actor: Actor, input?: { userMessage?: string }) => {
    const context = await deps.context.compile({
      texts: input?.userMessage ? [input.userMessage] : [],
      sources: actor.script.contextSources,
    });

    const behaviors = actor.script.talents.flatMap((t) => t.behaviors);
    const allowed = behaviors.filter((b) =>
      input?.userMessage ? b.mode !== 'passive' : b.mode !== 'active',
    );

    for (const behavior of allowed) {
      const plan = await behavior.plan({ goal: actor.goals.join('; '), context });
      for (const action of plan.actions) await executeAction(action, actor);
    }
  };

  return { tickActor };
};
```

## `packages/pantheon/src/index.ts`

```ts
export * from './core/ports.js';
export * from './core/context.js';
export * from './core/orchestrator.js';
```

## `packages/pantheon/src/cli/index.ts`

```ts
#!/usr/bin/env node
import process from 'node:process';
import { makeOrchestrator } from '../core/orchestrator.js';
import { makeContextPort } from '../core/context.js';
import type { Actor, ContextSource, ToolPort, LlmPort, MessageBus, Scheduler, ActorStatePort } from '../core/ports.js';
import { DualStoreManager } from '@promethean/persistence';

const parseArgs = (argv: string[]) => {
  const [cmd = '', sub = '', ...rest] = argv.slice(2);
  const opts: Record<string, string> = {};
  rest.forEach((arg) => {
    const m = arg.match(/^--([^=]+)=(.*)$/);
    if (m) opts[m[1]] = m[2];
  });
  return { cmd, sub, opts };
};

const dummy: {
  tools: ToolPort; llm: LlmPort; bus: MessageBus; schedule: Scheduler; state: ActorStatePort;
} = {
  tools: { register() {}, async invoke() { return; } },
  llm: { async complete(messages) { return messages[messages.length - 1] ?? { role: 'assistant', content: '' }; } },
  bus: { async send() {}, subscribe() { return () => {}; } },
  schedule: { every() { return () => {}; }, once() {} },
  state: { async spawn(script, goal) { return { id: script.name, script, goals: [goal] } as Actor; }, async list() { return []; } },
};

const getCollectionsFor = async (sources: readonly ContextSource[]) => {
  // naive default: create collections on the fly
  const unique = [...new Set(sources.map((s) => s.id))];
  return Promise.all(unique.map((name) => DualStoreManager.create(name, 'text', 'timestamp')));
};

const context = makeContextPort({
  getCollectionsFor,
  resolveRole: (m) => (m?.userName === 'Duck' ? (m?.isThought ? 'system' : 'assistant') : 'user'),
  resolveName: (m) => (m?.userName as string) ?? 'Unknown',
  formatTime: (ms) => new Date(ms).toISOString(),
});

const orch = makeOrchestrator({
  now: () => Date.now(),
  log: console.log,
  context,
  ...dummy,
});

const run = async () => {
  const { cmd, sub, opts } = parseArgs(process.argv);

  if (cmd === 'context' && sub === 'compile') {
    const sources = (opts.sources ?? 'sessions').split(',').map((id) => ({ id })) as ContextSource[];
    const texts = opts.text ? [opts.text] : [];
    const msgs = await context.compile({ sources, texts });
    console.log(JSON.stringify(msgs, null, 2));
    return;
  }

  if (cmd === 'actors' && sub === 'tick') {
    const name = opts.name ?? 'actor';
    const srcs = (opts.sources ?? 'sessions').split(',').map((id) => ({ id })) as ContextSource[];
    const actor: Actor = {
      id: name,
      script: { name, contextSources: srcs, talents: [] },
      goals: opts.goal ? [opts.goal] : [],
    };
    await orch.tickActor(actor, { userMessage: opts.user });
    console.log('tick complete');
    return;
  }

  console.log(
    [
      'pantheon context:compile --sources sessions,agent-tasks --text "hello world"',
      'pantheon actors:tick --name dev-buddy --sources sessions --user "check diff"',
    ].join('\n'),
  );
};

run().catch((e) => {
  console.error(e);
  process.exit(1);
});
```

## `packages/pantheon/src/core/orchestrator.test.ts`

```ts
import test from 'ava';
import { makeOrchestrator } from './orchestrator.js';
import { makeContextPort } from './context.js';
import type { Actor, Behavior, ContextSource } from './ports.js';

const context = makeContextPort({
  getCollectionsFor: async (_sources: readonly ContextSource[]) => ([]),
  resolveRole: () => 'user',
  resolveName: () => 'Tester',
  formatTime: () => 'now',
});

test('tickActor executes planned message action', async (t) => {
  let sent: { from: string; to: string; content: string } | null = null;

  const behavior: Behavior = {
    name: 'echo',
    mode: 'active',
    plan: async ({ context }) => ({
      actions: [{ type: 'message', content: `ctx:${context.length}`, target: 'user' }],
    }),
  };

  const actor: Actor = {
    id: 'a1',
    script: { name: 'a1', contextSources: [], talents: [{ name: 't1', behaviors: [behavior] }] },
    goals: ['x'],
  };

  const orch = makeOrchestrator({
    now: () => Date.now(),
    log: () => {},
    context,
    tools: { register() {}, async invoke() {} },
    llm: { async complete(ms) { return ms[ms.length - 1]!; } },
    bus: { async send(m) { sent = m; }, subscribe() { return () => {}; } },
    schedule: { every() { return () => {}; }, once() {} },
    state: { async spawn() { return actor; }, async list() { return [actor]; } },
  });

  await orch.tickActor(actor, { userMessage: 'hi' });
  t.truthy(sent);
  t.is(sent?.content, 'ctx:0');
});
```

---

# add to `pnpm-workspace.yaml`

Add `packages/pantheon` to the list. Example:

```yaml
packages:
  - 'packages/*'
  - 'packages/*/*'
  - 'packages/pantheon'
```

---

# what you get immediately

* A **clean FP core** (`ports`, `context`, `orchestrator`)
* A minimal **CLI** that can:

  * compile context from your stores (via `@promethean/persistence`)
  * tick an actor with a simple behavior set
* A tiny **unit test** to keep the contract honest
* **No** extra “api”/“utils” noise

---

# next small PRs (follow-ups)

1. **Agent State façade**: add `@promethean/agent-state` (rename of `agent-context`) exporting `makeAgentStateManager` (we discussed), then inject into Pantheon orchestrator.
2. **Tool/MCP adapter**: `@promethean/pantheon-mcp` implementing `ToolPort`.
3. **OpenAI adapter**: `@promethean/pantheon-llm-openai` implementing `LlmPort`.
4. **CLI wiring to config**: read a `pantheon.config.json` for store names, models, MCP servers.
5. **Web Components UI**: start with `<pantheon-actors-table>` and `<pantheon-actor-detail>` as a separate `pantheon-ui` package.

If you want me to also spit out the `agent-state` façade and the ESLint guardrails patch in this style, say the word and I’ll drop those diffs too.

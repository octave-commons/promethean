---
uuid: e6e47e9f-babd-4541-b74f-99b5919aa30a
created_at: '2025-10-19T10:06:46Z'
title: 2025.10.19.10.06.46
filename: 2025.10.19.10.06.46
description: DocOps summary for 2025.10.19.10.06.46
tags:
  - 2025.10.19.10.06.46
  - docops
  - autogenerated
related_to_uuid: []
related_to_title: []
references: []
---
## What it does

* Scans paths matching one or more **base patterns** (globs).
* Filters by **extensions** (case-insensitive).
* Applies **deny** globs (exclusions).
* Applies **allow** globs (intersection; only keep matches that also match at least one allow pattern).
* Respects `.gitignore` by default.
* Outputs newline or JSON.
* Useful exit codes for CI.

All implemented in a small functional core.

---

## `detect-files.ts`

```ts
#!/usr/bin/env -S node --no-warnings
// SPDX-License-Identifier: GPL-3.0-only
// Native ESM TypeScript (compile or run with `npx tsx detect-files.ts ...`)

import { globby } from "globby";
import { minimatch } from "minimatch";
import { basename, extname, posix as pathPosix } from "node:path";

type Options = {
  patterns: readonly string[];
  exts: readonly string[];           // e.g. ['ts', 'tsx']
  allow: readonly string[];          // keep only if match one of these globs
  deny: readonly string[];           // exclude if match one of these globs
  roots: readonly string[];          // starting directories (default ['.'])
  respectGitIgnore: boolean;
  json: boolean;
  failOnFound: boolean;              // exit 1 if any found
  failOnNone: boolean;               // exit 1 if none found
};

const toArray = (x: string | undefined | string[]): string[] =>
  (Array.isArray(x) ? x : (x ? [x] : [])).flatMap(s =>
    s.split(",").map(t => t.trim()).filter(Boolean)
  );

const parseArgs = (argv: readonly string[]): Options => {
  const getFlag = (short: string, long: string) =>
    (name: string) => {
      const idx = argv.findIndex(a => a === short || a === long);
      return idx >= 0 ? argv[idx + 1] : undefined;
    };

  const getAll = (short: string, long: string) =>
    argv.flatMap((a, i) =>
      (a === short || a === long) ? [argv[i + 1]] : []
    ).filter(Boolean) as string[];

  const has = (...flags: string[]) => argv.some(a => flags.includes(a));

  const val = getFlag("-p", "--pattern");
  const patterns =
    [...getAll("-p", "--pattern"), ...(val("-p") || val("--pattern") ? [] : [])].length
      ? getAll("-p", "--pattern")
      : ["**/*"]; // default: everything under roots

  const roots = toArray(getFlag("-r", "--root"));
  const exts = toArray(getFlag("-e", "--ext")).map(s => s.replace(/^\./, "").toLowerCase());
  const allow = toArray(getFlag("-a", "--allow"));
  const deny = toArray(getFlag("-d", "--deny"));

  return {
    patterns,
    exts,
    allow,
    deny,
    roots: roots.length ? roots : ["."],
    respectGitIgnore: !has("--no-gitignore"),
    json: has("--json"),
    failOnFound: has("--fail-on-found"),
    failOnNone: has("--fail-on-none"),
  };
};

const normalizePosix = (p: string): string =>
  p.split("\\").join("/");

const uniqueSorted = (xs: readonly string[]): string[] =>
  Array.from(new Set(xs)).sort((a, b) => a.localeCompare(b));

const buildGlobbyInputs = (roots: readonly string[], patterns: readonly string[]) =>
  roots.flatMap(root =>
    patterns.map(p => normalizePosix(pathPosix.join(normalizePosix(root), p)))
  );

const matchAny = (globs: readonly string[]) => (p: string) =>
  globs.length === 0 ? true : globs.some(g => minimatch(p, g, { dot: true, nocase: true }));

const not = <T>(f: (x: T) => boolean) => (x: T) => !f(x);

const hasAllowedExt = (exts: readonly string[]) => (p: string) => {
  if (exts.length === 0) return true;
  const ext = extname(p).slice(1).toLowerCase();
  return exts.includes(ext);
};

export const findFiles = async (opts: Options): Promise<string[]> => {
  const inputs = buildGlobbyInputs(opts.roots, opts.patterns);

  const raw = await globby(inputs, {
    onlyFiles: true,
    absolute: false,
    expandDirectories: false,
    gitignore: opts.respectGitIgnore,
    ignore: opts.deny, // coarse deny at the walker
    dot: true,
    followSymbolicLinks: true,
  });

  const files = raw
    .map(normalizePosix)
    .filter(hasAllowedExt(opts.exts))
    .filter(not(matchAny(opts.deny)))
    .filter(matchAny(opts.allow)); // allow acts as intersection if provided

  return uniqueSorted(files);
};

const main = async () => {
  const opts = parseArgs(process.argv.slice(2));
  const files = await findFiles(opts);

  if (opts.json) {
    process.stdout.write(JSON.stringify(files, null, 2) + "\n");
  } else {
    process.stdout.write(files.join("\n") + (files.length ? "\n" : ""));
  }

  if (opts.failOnFound && files.length > 0) process.exit(1);
  if (opts.failOnNone && files.length === 0) process.exit(1);
};

if (import.meta.url === `file://${process.argv[1]}`) {
  // top-level await OK in ESM
  await main();
}
```

---

## Minimal `package.json` (flat, native ESM)

```json
{
  "name": "detect-files",
  "version": "0.1.0",
  "type": "module",
  "license": "GPL-3.0-only",
  "private": true,
  "bin": {
    "detect-files": "./dist/detect-files.js"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "test": "ava"
  },
  "devDependencies": {
    "ava": "^6.2.0",
    "typescript": "^5.6.3",
    "tsx": "^4.19.2"
  },
  "dependencies": {
    "globby": "^14.0.1",
    "minimatch": "^9.0.5"
  }
}
```

### `tsconfig.json` (ESNext, no nonsense)

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "outDir": "dist",
    "rootDir": ".",
    "strict": true,
    "noEmitOnError": true,
    "skipLibCheck": true
  },
  "include": ["detect-files.ts", "test/**/*.ts"]
}
```

---

## AVA test (`test/detect-files.test.ts`)

```ts
// SPDX-License-Identifier: GPL-3.0-only
import test from "ava";
import { mkdtemp, mkdir, writeFile } from "node:fs/promises";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { findFiles } from "../detect-files.js";

const createTmpTree = async (layout: Record<string, string>) => {
  const root = await mkdtemp(join(tmpdir(), "detect-files-"));
  await Promise.all(
    Object.entries(layout).map(async ([p, content]) => {
      const full = join(root, p);
      const dir = full.replace(/[/\\][^/\\]+$/, "");
      await mkdir(dir, { recursive: true });
      await writeFile(full, content);
    })
  );
  return root;
};

test("filters by ext, allow, deny", async t => {
  const root = await createTmpTree({
    "src/a.ts": "// a",
    "src/b.tsx": "// b",
    "src/c.js": "// c",
    "src/ignore/me.ts": "// deny me",
    "pkg/x/y.md": "# nope",
    "pkg/z/file.ts": "// yes",
  });

  const files = await findFiles({
    patterns: ["**/*"],
    exts: ["ts", "tsx"],
    allow: ["src/**", "pkg/**"],
    deny: ["**/ignore/**"],
    roots: [root],
    respectGitIgnore: false,
    json: false,
    failOnFound: false,
    failOnNone: false,
  });

  t.deepEqual(files.map(f => f.replace(root + "/", "")), [
    "pkg/z/file.ts",
    "src/a.ts",
    "src/b.tsx",
  ]);
});
```

---

## Usage

You can run the TS directly with `tsx`:

```bash
npx tsx detect-files.ts \
  --root . \
  --pattern "packages/*/src/**/*" \
  --ext ts,tsx \
  --allow "packages/*/src/**" \
  --deny "**/__tests__/**" \
  --json
```

**Flags**

* `-r, --root <dir>`: starting directory (repeatable; default `.`).
* `-p, --pattern <glob>`: base path glob(s). Default `**/*`.
* `-e, --ext <list>`: comma or repeated list of extensions (e.g. `ts,tsx,js`).
* `-a, --allow <glob>`: only keep files matching one of these globs.
* `-d, --deny <glob>`: exclude files matching these globs.
* `--no-gitignore`: donâ€™t respect `.gitignore`.
* `--json`: print JSON array.
* `--fail-on-found`: exit 1 if any files found.
* `--fail-on-none`: exit 1 if none found.

**Notes / deliberate choices**

* `allow` acts as an **intersection**: if provided, results must match at least one allow glob.
* We filter extensions in-process to avoid overcomplicating glob combinations.
* All matching is case-insensitive, dotfiles allowed, and paths are normalized to POSIX separators.


---
title: 'Implement Structured Logging Infrastructure for OpenAI Server'
description: 'Add comprehensive structured logging system for better observability, debugging, and security monitoring'
status: 'ready'
priority: 'P1'
storyPoints: 4
tags: ['logging', 'observability', 'monitoring', 'quality', 'openai-server']
assignee: ''
createdAt: '2025-10-19T00:00:00Z'
updatedAt: '2025-10-19T00:00:00Z'
lastCommitSha: ''
dependencies: ['2025.10.19.implement-function-calling-openai-server.md']
blocking: ['2025.10.19.standardize-error-handling-openai-server.md']
epic: '2025.10.19.openai-server-security-hardening-epic.md'
---

## Task Overview

Implement a comprehensive structured logging infrastructure to replace the current inadequate logging system, providing better observability, security monitoring, and debugging capabilities for the OpenAI Server.

## Acceptance Criteria

1. **Structured Logging Implementation**

   - [ ] JSON-based structured logging format
   - [ ] Multiple log levels (debug, info, warn, error, fatal)
   - [ ] Context-aware logging with request tracing
   - [ ] Log correlation across distributed components

2. **Logging Features**

   - [ ] Request/response logging for API endpoints
   - [ ] Performance metrics logging
   - [ ] Security event logging
   - [ ] Error and exception logging with stack traces

3. **Log Management**

   - [ ] Log rotation and retention policies
   - [ ] Log aggregation and shipping
   - [ ] Sensitive data redaction
   - [ ] Log filtering and routing

4. **Integration & Monitoring**
   - [ ] Integration with monitoring systems
   - [ ] Log-based alerting
   - [ ] Dashboard integration
   - [ ] Log search and analysis capabilities

## Technical Implementation Details

### Files to Modify/Create

**New Files:**

- `src/logging/logger.ts` - Main logger implementation
- `src/logging/formatters.ts` - Log formatting utilities
- `src/logging/middleware.ts` - Request logging middleware
- `src/logging/redaction.ts` - Sensitive data redaction
- `src/logging/types.ts` - Logging type definitions
- `src/logging/config.ts` - Logging configuration

**Modified Files:**

- `src/server/createServer.ts` - Integrate logging middleware
- `src/server/chatCompletionRoute.ts` - Add request logging
- `src/queue/taskQueue.ts` - Add queue operation logging
- `src/openai/ollamaHandler.ts` - Add handler logging
- `package.json` - Add logging dependencies

### Logger Implementation

```typescript
import pino from 'pino';
import { redactSensitiveData } from './redaction';

export interface LogContext {
  requestId?: string;
  userId?: string;
  endpoint?: string;
  method?: string;
  statusCode?: number;
  duration?: number;
  error?: Error;
  [key: string]: any;
}

export class StructuredLogger {
  private logger: pino.Logger;

  constructor(config: LoggingConfig) {
    this.logger = pino(
      {
        level: config.level,
        formatters: {
          level: (label) => ({ level: label }),
          log: (object) => this.formatLog(object),
        },
        redact: {
          paths: [
            'req.headers.authorization',
            'req.body.password',
            'req.body.api_key',
            'res.body.token',
            'error.stack',
          ],
          censor: '[REDACTED]',
        },
        timestamp: pino.stdTimeFunctions.isoTime,
        base: {
          service: 'openai-server',
          version: process.env.APP_VERSION || '1.0.0',
          hostname: require('os').hostname(),
          pid: process.pid,
        },
      },
      config.transport,
    );
  }

  debug(message: string, context?: LogContext): void {
    this.logger.debug({ ...context }, message);
  }

  info(message: string, context?: LogContext): void {
    this.logger.info({ ...context }, message);
  }

  warn(message: string, context?: LogContext): void {
    this.logger.warn({ ...context }, message);
  }

  error(message: string, error?: Error, context?: LogContext): void {
    this.logger.error(
      {
        ...context,
        error: error
          ? {
              message: error.message,
              name: error.name,
              stack: error.stack,
            }
          : undefined,
      },
      message,
    );
  }

  fatal(message: string, error?: Error, context?: LogContext): void {
    this.logger.fatal(
      {
        ...context,
        error: error
          ? {
              message: error.message,
              name: error.name,
              stack: error.stack,
            }
          : undefined,
      },
      message,
    );
  }

  // Performance logging
  logPerformance(operation: string, duration: number, context?: LogContext): void {
    this.info(`Performance: ${operation}`, {
      ...context,
      operation,
      duration,
      performance: true,
    });
  }

  // Security logging
  logSecurityEvent(event: string, context?: LogContext): void {
    this.warn(`Security: ${event}`, {
      ...context,
      security: true,
      timestamp: new Date().toISOString(),
    });
  }

  // API request logging
  logRequest(request: any, response: any, duration: number): void {
    this.info('API Request', {
      requestId: request.id,
      method: request.method,
      url: request.url,
      userAgent: request.headers['user-agent'],
      ip: request.ip,
      statusCode: response.statusCode,
      duration,
      api: true,
    });
  }

  private formatLog(object: any): any {
    // Add additional formatting if needed
    return redactSensitiveData(object);
  }
}
```

### Request Logging Middleware

```typescript
export const requestLoggingMiddleware = (logger: StructuredLogger) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    const startTime = Date.now();
    const requestId = generateRequestId();

    // Add request ID to request context
    request.id = requestId;

    // Log incoming request
    logger.info('Incoming request', {
      requestId,
      method: request.method,
      url: request.url,
      userAgent: request.headers['user-agent'],
      ip: request.ip,
      userId: request.user?.id,
    });

    // Hook into response
    reply.addHook('onSend', async (request, reply, payload) => {
      const duration = Date.now() - startTime;

      // Log response
      logger.logRequest(request, reply, duration);

      return payload;
    });

    // Handle errors
    reply.addHook('onError', async (request, reply, error) => {
      const duration = Date.now() - startTime;

      logger.error('Request error', error, {
        requestId,
        method: request.method,
        url: request.url,
        duration,
        userId: request.user?.id,
      });
    });
  };
};
```

### Sensitive Data Redaction

```typescript
export const redactSensitiveData = (data: any): any => {
  if (!data || typeof data !== 'object') {
    return data;
  }

  const sensitivePatterns = [/password/i, /token/i, /secret/i, /key/i, /auth/i, /credential/i];

  const sensitiveValues = [
    /^[A-Za-z0-9+/]{40,}={0,2}$/, // Base64 encoded data
    /^[a-f0-9]{32,}$/i, // Hex strings (possible hashes/keys)
    /^sk-[a-zA-Z0-9]{20,}$/, // OpenAI API keys
    /^ghp_[a-zA-Z0-9]{36}$/, // GitHub tokens
  ];

  const redacted = { ...data };

  const redactValue = (value: any): any => {
    if (typeof value === 'string') {
      // Check for sensitive patterns
      for (const pattern of sensitiveValues) {
        if (pattern.test(value)) {
          return '[REDACTED]';
        }
      }
      // Check if value is too long (might contain sensitive data)
      if (value.length > 1000) {
        return value.substring(0, 100) + '...[TRUNCATED]';
      }
    }
    return value;
  };

  const redactObject = (obj: any): any => {
    if (Array.isArray(obj)) {
      return obj.map(redactObject);
    }

    if (obj && typeof obj === 'object') {
      const result: any = {};
      for (const [key, value] of Object.entries(obj)) {
        // Check if key name suggests sensitive data
        const isSensitiveKey = sensitivePatterns.some((pattern) => pattern.test(key));

        if (isSensitiveKey) {
          result[key] = '[REDACTED]';
        } else {
          result[key] = redactObject(redactValue(value));
        }
      }
      return result;
    }

    return redactValue(obj);
  };

  return redactObject(redacted);
};
```

### Logging Configuration

```typescript
export interface LoggingConfig {
  level: 'debug' | 'info' | 'warn' | 'error' | 'fatal';
  transport: pino.TransportTargetOptions | pino.TransportMultiOptions;
  redaction: {
    enabled: boolean;
    patterns: string[];
    customRedactors: Array<(data: any) => any>;
  };
  rotation: {
    enabled: boolean;
    maxSize: string;
    maxFiles: number;
    interval: string;
  };
}

export const defaultLoggingConfig: LoggingConfig = {
  level: process.env.LOG_LEVEL || 'info',
  transport: {
    targets: [
      {
        target: 'pino/file',
        level: 'info',
        options: {
          destination: 1, // stdout
          colorize: true,
        },
      },
      {
        target: 'pino/file',
        level: 'debug',
        options: {
          destination: './logs/app.log',
          mkdir: true,
        },
      },
    ],
  },
  redaction: {
    enabled: true,
    patterns: [
      'req.headers.authorization',
      'req.body.password',
      'req.body.api_key',
      'res.body.token',
      'error.stack',
    ],
    customRedactors: [],
  },
  rotation: {
    enabled: true,
    maxSize: '100M',
    maxFiles: 10,
    interval: '1d',
  },
};
```

### Integration Examples

```typescript
// In chat completion route
export const chatCompletionHandler = async (request: FastifyRequest, reply: FastifyReply) => {
  const logger = request.log as StructuredLogger;
  const startTime = Date.now();

  try {
    logger.info('Processing chat completion request', {
      requestId: request.id,
      model: request.body.model,
      messageCount: request.body.messages.length,
    });

    const result = await processChatCompletion(request.body);

    logger.info('Chat completion completed', {
      requestId: request.id,
      tokenCount: result.usage?.total_tokens,
      duration: Date.now() - startTime,
    });

    return result;
  } catch (error) {
    logger.error('Chat completion failed', error as Error, {
      requestId: request.id,
      duration: Date.now() - startTime,
    });

    throw error;
  }
};

// In queue operations
export class TaskQueue {
  private logger: StructuredLogger;

  async addTask(task: Task) {
    this.logger.debug('Adding task to queue', {
      taskId: task.id,
      taskType: task.type,
      queueSize: this.tasks.length,
    });

    try {
      this.tasks.push(task);

      this.logger.info('Task added to queue', {
        taskId: task.id,
        queueSize: this.tasks.length,
      });
    } catch (error) {
      this.logger.error('Failed to add task to queue', error as Error, {
        taskId: task.id,
      });
      throw error;
    }
  }
}
```

## Testing Requirements

1. **Unit Tests**

   - [ ] Logger functionality and formatting
   - [ ] Sensitive data redaction
   - [ ] Log level filtering
   - [ ] Context propagation

2. **Integration Tests**

   - [ ] Request logging middleware
   - [ ] Error logging scenarios
   - [ ] Performance logging accuracy
   - [ ] Security event logging

3. **Performance Tests**

   - [ ] Logging overhead measurement
   - [ ] High-volume logging performance
   - [ ] Memory usage during logging
   - [ ] Async logging performance

4. **Security Tests**
   - [ ] Sensitive data redaction effectiveness
   - [ ] Log injection prevention
   - [ ] Log tampering detection
   - [ ] Privacy compliance

## Configuration

Environment variables for logging:

```bash
# Logging configuration
LOG_LEVEL=info
LOG_FORMAT=json
LOG_FILE=./logs/app.log
LOG_MAX_SIZE=100M
LOG_MAX_FILES=10
LOG_ROTATION_INTERVAL=1d
ENABLE_REDACTION=true
ENABLE_REQUEST_LOGGING=true
ENABLE_PERFORMANCE_LOGGING=true
```

## Monitoring & Alerting

1. **Log Metrics**

   - Error rates by endpoint
   - Response time distributions
   - Security event frequency
   - Log volume trends

2. **Alerting Rules**
   - High error rate (>5%)
   - Security events detected
   - Performance degradation
   - Log service failures

## Rollback Plan

1. Disable structured logging
2. Revert to console.log statements
3. Remove logging middleware
4. Monitor for functionality issues

## Success Metrics

- Logging overhead < 5ms per request
- 100% sensitive data redaction
- Complete request traceability
- Zero log injection vulnerabilities

## Documentation Updates

1. Logging configuration guide
2. Log analysis documentation
3. Security logging procedures
4. Troubleshooting with logs

---

**Risk Level**: Low (Quality improvement)
**Estimated Effort**: 3-4 days
**Dependencies**: Function calling implementation
**Blocked By**: Function calling completion

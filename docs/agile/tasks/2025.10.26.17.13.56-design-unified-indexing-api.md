# Design Unified Indexing API

## Overview
Create single client interface for all indexing operations (index, search, compileContext) with consistent patterns across different content types and storage backends.

## Context
Current systems expose different interfaces:
- IndexerServiceClient with HTTP methods
- DualStoreManager with direct database methods
- ContextStore with compilation methods
- Individual indexers with their own APIs

## Acceptance Criteria
- [ ] Unified client interface design
- [ ] Consistent method signatures
- [ ] Single configuration approach
- [ ] Unified error handling
- [ ] Comprehensive documentation
- [ ] Client SDK for multiple languages (TypeScript focus)

## Implementation Plan
1. **Phase 1**: Design core UnifiedIndexingService interface
2. **Phase 2**: Implement HTTP client wrapper
3. **Phase 3**: Create SDK for direct usage
4. **Phase 4**: Add configuration management
5. **Phase 5**: Implement error handling and logging

## Technical Details
### Target API Design
```typescript
// Main service interface
export class UnifiedIndexingService {
  constructor(config: IndexingConfig);
  
  // Indexing operations
  async indexContent(content: IndexableContent): Promise<void>;
  async indexFile(path: string): Promise<void>;
  async indexMessage(message: Message): Promise<void>;
  async indexEvent(event: Event): Promise<void>;
  
  // Search operations
  async search(query: string, options?: SearchOptions): Promise<SearchResult[]>;
  async searchByType(type: ContentType, query: string): Promise<SearchResult[]>;
  async searchBySource(source: string, query: string): Promise<SearchResult[]>;
  
  // Context compilation
  async compileContext(options: ContextOptions): Promise<ContextMessage[]>;
  async getRecentContext(limit?: number): Promise<ContextMessage[]>;
  async getRelevantContext(query: string, limit?: number): Promise<ContextMessage[]>;
  
  // Management operations
  async getStatus(): Promise<IndexingStatus>;
  async reindex(options?: ReindexOptions): Promise<void>;
  async cleanup(): Promise<void>;
}

// Client interface
export class IndexingClient {
  constructor(serviceUrl: string, apiKey?: string);
  
  // Same interface as UnifiedIndexingService but over HTTP
  async indexContent(content: IndexableContent): Promise<void>;
  async search(query: string, options?: SearchOptions): Promise<SearchResult[]>;
  async compileContext(options: ContextOptions): Promise<ContextMessage[]>;
}
```

### Configuration Management
```typescript
interface IndexingConfig {
  storage: {
    mongodb: MongoConfig;
    chromadb: ChromaConfig;
  };
  embedding: EmbeddingConfig;
  indexing: {
    batchSize: number;
    concurrency: number;
    retryPolicy: RetryConfig;
  };
  search: {
    defaultLimit: number;
    maxLimit: number;
    enableFaceting: boolean;
  };
}
```

### Error Handling Strategy
- Unified error types across all operations
- Consistent error response format
- Detailed error context and suggestions
- Retry logic with exponential backoff
- Circuit breaker pattern for resilience

## Dependencies
- Implement unified content model (prerequisite)
- Consolidate redundant implementations (prerequisite)

## Risks
- API complexity due to multiple content types
- Performance overhead of abstraction
- Backward compatibility challenges
- Configuration complexity

## Tags
indexing,api,design,unified,client

## Complexity Score
5 (clear API design with implementation complexity)

## Status
incoming

---
uuid: "refactor-complex-functions-createTask"
title: "Refactor Complex Functions - Break Down createTask Function (200+ lines)"
slug: "2025.10.12.16.35.00-refactor-complex-functions-createTask"
status: "incoming"
priority: "P1"
labels: ["refactoring", "code-quality", "maintainability", "complexity", "testing", "clean-code"]
created_at: "2025-10-12T16:35:00Z"
estimates:
  complexity: ""
  scale: ""
  time_to_completion: ""
---

## Task Overview

The `createTask` function in `packages/kanban/src/lib/task-manager.ts` has grown to over 200 lines, violating single responsibility principle and making it difficult to maintain, test, and understand. This task involves breaking down this monolithic function into smaller, focused components.

## Code Analysis

### Current Issues

**Location**: `packages/kanban/src/lib/task-manager.ts` - `createTask` function (lines 45-247)

**Complexity Metrics**:

- **Cyclomatic Complexity**: 15+ (threshold: 10)
- **Lines of Code**: 202 (threshold: 50)
- **Parameters**: 8 (threshold: 5)
- **Responsibilities**: 7+ (threshold: 1)

### Identified Responsibilities

1. **Input Validation**: Validate task data and parameters
2. **Business Logic**: Apply business rules and constraints
3. **Database Operations**: Create task in database
4. **Cache Management**: Update relevant caches
5. **Event Publishing**: Emit domain events
6. **Notification Handling**: Send notifications
7. **Audit Logging**: Record creation events
8. **Error Handling**: Comprehensive error management

### Code Smells Detected

- **Long Method**: Function is too long
- **Too Many Parameters**: Hard to use and test
- **Feature Envy**: Uses many other classes
- **Inappropriate Intimacy**: Knows too much about internals
- **Duplicated Code**: Repeated validation patterns

## Sub-Tasks

### 1. Function Analysis and Planning

- [ ] Analyze current createTask function structure
- [ ] Identify distinct responsibilities and concerns
- [ ] Design new component architecture
- [ ] Plan refactoring strategy to avoid breaking changes

### 2. Extract Validation Components

- [ ] Create TaskValidator class for input validation
- [ ] Extract business rule validation
- [ ] Create parameter sanitization utilities
- [ ] Implement validation result aggregation

### 3. Extract Business Logic Components

- [ ] Create TaskBusinessRules class
- [ ] Extract task creation logic
- [ ] Implement constraint checking
- [ ] Create task default value handling

### 4. Extract Persistence Components

- [ ] Create TaskRepository class for database operations
- [ ] Extract transaction management
- [ ] Implement retry logic for database failures
- [ ] Create database error mapping

### 5. Extract Event and Notification Components

- [ ] Create TaskEventPublisher for domain events
- [ ] Extract notification sending logic
- [ ] Implement event batching
- [ ] Create notification templates

### 6. Extract Audit Components

- [ ] Create TaskAuditLogger for audit trails
- [ ] Extract audit event formatting
- [ ] Implement audit data enrichment
- [ ] Create audit retention policies

### 7. Integration and Testing

- [ ] Integrate all new components
- [ ] Update createTask to use new architecture
- [ ] Create comprehensive unit tests
- [ ] Perform integration testing
- [ ] Update documentation

## Definition of Done

### Code Quality Requirements

- [ ] createTask function reduced to < 50 lines
- [ ] All extracted functions have single responsibility
- [ ] Cyclomatic complexity < 10 for all functions
- [ ] No function has more than 5 parameters
- [ ] 100% test coverage for new components

### Functional Requirements

- [ ] All existing functionality preserved
- [ ] No breaking changes to public API
- [ ] Performance is maintained or improved
- [ ] Error handling remains comprehensive
- [ ] All edge cases are handled

### Quality Assurance

- [ ] Code review passes all quality gates
- [ ] Static analysis shows no code smells
- [ ] Unit tests achieve 100% coverage
- [ ] Integration tests pass
- [ ] Documentation is updated and accurate

## Implementation Requirements

### New Architecture Design

```typescript
// Main orchestrator - simplified createTask
class TaskManager {
  constructor(
    private validator: TaskValidator,
    private businessRules: TaskBusinessRules,
    private repository: TaskRepository,
    private eventPublisher: TaskEventPublisher,
    private auditLogger: TaskAuditLogger,
    private cacheManager: TaskCacheManager,
  ) {}

  async createTask(params: CreateTaskParams): Promise<Task> {
    // 1. Validate input
    const validationResult = await this.validator.validate(params);
    if (!validationResult.isValid) {
      throw new ValidationError(validationResult.errors);
    }

    // 2. Apply business rules
    const businessResult = await this.businessRules.apply(params);
    if (!businessResult.allowed) {
      throw new BusinessRuleError(businessResult.reason);
    }

    // 3. Create task
    const task = await this.repository.create(businessResult.taskData);

    // 4. Publish events
    await this.eventPublisher.publishTaskCreated(task);

    // 5. Log audit
    await this.auditLogger.logTaskCreated(task, params.context);

    // 6. Update cache
    await this.cacheManager.invalidateRelevantCaches(task);

    return task;
  }
}
```

### Extracted Components

#### 1. TaskValidator

```typescript
class TaskValidator {
  constructor(
    private titleValidator: TitleValidator,
    private descriptionValidator: DescriptionValidator,
    private priorityValidator: PriorityValidator,
    private statusValidator: StatusValidator,
  ) {}

  async validate(params: CreateTaskParams): Promise<ValidationResult> {
    const errors: ValidationError[] = [];

    // Validate title
    const titleResult = await this.titleValidator.validate(params.title);
    if (!titleResult.isValid) {
      errors.push(...titleResult.errors);
    }

    // Validate description
    const descriptionResult = await this.descriptionValidator.validate(params.description);
    if (!descriptionResult.isValid) {
      errors.push(...descriptionResult.errors);
    }

    // Validate priority
    const priorityResult = await this.priorityValidator.validate(params.priority);
    if (!priorityResult.isValid) {
      errors.push(...priorityResult.errors);
    }

    // Validate status
    const statusResult = await this.statusValidator.validate(params.status);
    if (!statusResult.isValid) {
      errors.push(...statusResult.errors);
    }

    return {
      isValid: errors.length === 0,
      errors,
    };
  }
}
```

#### 2. TaskBusinessRules

```typescript
class TaskBusinessRules {
  constructor(
    private wipLimitChecker: WIPLimitChecker,
    private dependencyChecker: DependencyChecker,
    private permissionChecker: PermissionChecker,
  ) {}

  async apply(params: CreateTaskParams): Promise<BusinessRuleResult> {
    // Check WIP limits
    const wipCheck = await this.wipLimitChecker.check(params.boardId, params.status);
    if (!wipCheck.allowed) {
      return {
        allowed: false,
        reason: `WIP limit exceeded for ${params.status}: ${wipCheck.current}/${wipCheck.limit}`,
      };
    }

    // Check dependencies
    const depCheck = await this.dependencyChecker.check(params.dependencies);
    if (!depCheck.valid) {
      return {
        allowed: false,
        reason: `Invalid dependencies: ${depCheck.errors.join(', ')}`,
      };
    }

    // Check permissions
    const permCheck = await this.permissionChecker.check(params.userId, params.boardId);
    if (!permCheck.allowed) {
      return {
        allowed: false,
        reason: 'Insufficient permissions to create task',
      };
    }

    // Apply default values and transformations
    const taskData = {
      ...params,
      id: generateTaskId(),
      createdAt: new Date(),
      updatedAt: new Date(),
      status: params.status || 'incoming',
      priority: params.priority || 'P2',
    };

    return {
      allowed: true,
      taskData,
    };
  }
}
```

#### 3. TaskRepository

```typescript
class TaskRepository {
  constructor(
    private db: Database,
    private transactionManager: TransactionManager,
  ) {}

  async create(taskData: TaskData): Promise<Task> {
    return await this.transactionManager.withTransaction(async (tx) => {
      try {
        // Insert task
        const result = await tx.query(
          `
          INSERT INTO tasks (id, title, description, status, priority, board_id, created_by, created_at, updated_at)
          VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)
          RETURNING *
        `,
          [
            taskData.id,
            taskData.title,
            taskData.description,
            taskData.status,
            taskData.priority,
            taskData.boardId,
            taskData.createdBy,
            taskData.createdAt,
            taskData.updatedAt,
          ],
        );

        const task = this.mapRowToTask(result.rows[0]);

        // Handle dependencies if any
        if (taskData.dependencies?.length > 0) {
          await this.insertDependencies(tx, task.id, taskData.dependencies);
        }

        // Handle tags if any
        if (taskData.tags?.length > 0) {
          await this.insertTags(tx, task.id, taskData.tags);
        }

        return task;
      } catch (error) {
        throw new DatabaseError('Failed to create task', error);
      }
    });
  }

  private async insertDependencies(
    tx: Transaction,
    taskId: string,
    dependencies: string[],
  ): Promise<void> {
    const values = dependencies.map((depId) => `('${taskId}', '${depId}')`).join(',');
    await tx.query(`
      INSERT INTO task_dependencies (task_id, depends_on_task_id)
      VALUES ${values}
    `);
  }

  private async insertTags(tx: Transaction, taskId: string, tags: string[]): Promise<void> {
    const values = tags.map((tag) => `('${taskId}', '${tag}')`).join(',');
    await tx.query(`
      INSERT INTO task_tags (task_id, tag)
      VALUES ${values}
    `);
  }
}
```

#### 4. TaskEventPublisher

```typescript
class TaskEventPublisher {
  constructor(
    private eventBus: EventBus,
    private notificationService: NotificationService,
  ) {}

  async publishTaskCreated(task: Task): Promise<void> {
    // Publish domain event
    await this.eventBus.publish('task.created', {
      taskId: task.id,
      boardId: task.boardId,
      createdBy: task.createdBy,
      timestamp: new Date(),
    });

    // Send notifications
    await this.notificationService.notifyTaskCreated(task);

    // Update board statistics
    await this.eventBus.publish('board.stats.updated', {
      boardId: task.boardId,
      operation: 'task_created',
      taskId: task.id,
    });
  }
}
```

#### 5. TaskAuditLogger

```typescript
class TaskAuditLogger {
  constructor(
    private auditRepository: AuditRepository,
    private contextEnricher: AuditContextEnricher,
  ) {}

  async logTaskCreated(task: Task, context: CreationContext): Promise<void> {
    const auditEvent = {
      eventType: 'TASK_CREATED',
      entityId: task.id,
      entityType: 'task',
      userId: context.userId,
      timestamp: new Date(),
      ipAddress: context.ipAddress,
      userAgent: context.userAgent,
      changes: {
        before: null,
        after: this.sanitizeTaskForAudit(task),
      },
      metadata: await this.contextEnricher.enrich({
        boardId: task.boardId,
        source: context.source,
        sessionId: context.sessionId,
      }),
    };

    await this.auditRepository.log(auditEvent);
  }

  private sanitizeTaskForAudit(task: Task): Partial<Task> {
    // Remove sensitive data for audit
    const { id, title, status, priority, boardId, createdAt } = task;
    return { id, title, status, priority, boardId, createdAt };
  }
}
```

## Refactoring Strategy

### Step-by-Step Approach

1. **Preparation Phase**

   - Create comprehensive test suite for existing function
   - Establish performance benchmarks
   - Document current behavior

2. **Extraction Phase**

   - Extract validation logic first (least risky)
   - Extract business rules
   - Extract database operations
   - Extract event publishing
   - Extract audit logging

3. **Integration Phase**

   - Update main function to use new components
   - Ensure all tests pass
   - Verify performance is maintained

4. **Cleanup Phase**
   - Remove old code
   - Update documentation
   - Perform final code review

### Safe Refactoring Techniques

```typescript
// Use Strangler Fig pattern
class TaskManager {
  async createTask(params: CreateTaskParams): Promise<Task> {
    // Gradually migrate to new implementation
    if (this.useNewImplementation(params)) {
      return this.createNewTask(params);
    } else {
      return this.createTaskLegacy(params);
    }
  }

  private useNewImplementation(params: CreateTaskParams): boolean {
    // Feature flag or gradual rollout
    return process.env.ENABLE_NEW_TASK_CREATION === 'true';
  }

  private async createNewTask(params: CreateTaskParams): Promise<Task> {
    // New implementation using extracted components
    return this.newTaskCreator.create(params);
  }

  private async createTaskLegacy(params: CreateTaskParams): Promise<Task> {
    // Original implementation (to be removed later)
    // ... existing 200+ line function
  }
}
```

## Testing Strategy

### Unit Tests for Each Component

```typescript
describe('TaskValidator', () => {
  it('should validate valid task data', async () => {
    const validParams = {
      title: 'Valid Task Title',
      description: 'Valid description',
      priority: 'P1',
      status: 'todo',
    };

    const result = await validator.validate(validParams);
    expect(result.isValid).toBe(true);
    expect(result.errors).toHaveLength(0);
  });

  it('should reject invalid task data', async () => {
    const invalidParams = {
      title: '', // Invalid
      description: 'x'.repeat(2000), // Too long
      priority: 'INVALID', // Invalid
      status: 'INVALID', // Invalid
    };

    const result = await validator.validate(invalidParams);
    expect(result.isValid).toBe(false);
    expect(result.errors.length).toBeGreaterThan(0);
  });
});

describe('TaskBusinessRules', () => {
  it('should enforce WIP limits', async () => {
    const params = {
      boardId: 'board-123',
      status: 'in_progress',
      userId: 'user-123',
    };

    // Mock WIP limit exceeded
    wipLimitChecker.check.mockResolvedValue({
      allowed: false,
      current: 5,
      limit: 3,
    });

    const result = await businessRules.apply(params);
    expect(result.allowed).toBe(false);
    expect(result.reason).toContain('WIP limit exceeded');
  });
});
```

### Integration Tests

```typescript
describe('TaskManager Integration', () => {
  it('should create task successfully with all components', async () => {
    const params = {
      title: 'Integration Test Task',
      description: 'Testing task creation',
      priority: 'P2',
      status: 'todo',
      boardId: 'board-123',
      userId: 'user-123',
    };

    const task = await taskManager.createTask(params);

    expect(task.id).toBeDefined();
    expect(task.title).toBe(params.title);
    expect(task.status).toBe(params.status);

    // Verify side effects
    expect(eventBus.publish).toHaveBeenCalledWith('task.created', expect.any(Object));
    expect(auditRepository.log).toHaveBeenCalledWith(
      expect.objectContaining({
        eventType: 'TASK_CREATED',
      }),
    );
  });
});
```

## Risk Assessment

### Before Refactoring

- **Maintainability Risk**: High - Difficult to modify
- **Bug Risk**: High - Complex code hides bugs
- **Testing Risk**: High - Hard to test comprehensively

### After Refactoring

- **Maintainability Risk**: Low - Easy to understand and modify
- **Bug Risk**: Low - Smaller, focused functions
- **Testing Risk**: Low - Each component can be tested independently

## Dependencies

- Comprehensive test suite for existing functionality
- Mock implementations for external dependencies
- Performance benchmarking tools
- Code quality analysis tools

## Blocked By

- Test suite coverage for existing createTask function
- Performance baseline establishment

## Blocking

- Further feature development on task creation
- Code review and quality improvements
- Documentation updates

## Timeline

- **Phase 1 (12 hours)**: Analysis and test suite creation
- **Phase 2 (24 hours)**: Extract validation components
- **Phase 3 (36 hours)**: Extract business logic and persistence
- **Phase 4 (48 hours)**: Extract events and audit, integration
- **Phase 5 (60 hours)**: Testing, documentation, and cleanup

## Success Metrics

- **Code Complexity**: Reduced by > 70%
- **Function Length**: createTask < 50 lines
- **Test Coverage**: 100% for new components
- **Maintainability Index**: Improved by > 50%
- **Developer Feedback**: Positive on code readability

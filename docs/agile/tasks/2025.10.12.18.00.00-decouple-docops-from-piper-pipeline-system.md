---
title: "Decouple DocOps from Piper Pipeline System and Create Standalone CLI"
status: "incoming"
priority: "P1"
tags: ["docops", "cli", "pipeline", "decoupling", "refactoring", "tooling"]
uuid: "docops-decouple-001"
---

## Overview

Transform the @promethean/docops package from a piper-pipeline-dependent tool into a standalone CLI application with comprehensive subcommands for each documentation processing step.

## Description

The @promethean/docops package currently relies heavily on the piper pipeline system for orchestration, despite having well-designed standalone functions. This task involves creating a proper CLI interface that exposes each pipeline step as an independent subcommand, while maintaining backward compatibility and improving the overall user experience.

### Current State Analysis
- Package has 8 pipeline steps defined in `pipelines.json`
- Individual functions exist for each step (frontmatter, embed, query, relations, footers, rename, purge)
- Current bin entries: `convert-wikilinks` and `docops-check-changelog` only
- Pipeline orchestration handled by `src/lib/pipeline.ts`
- Tight coupling to piper for configuration and execution

### Target State
- Comprehensive CLI with subcommands for each pipeline step
- Standalone configuration management
- Proper argument parsing and help system
- Backward compatibility with existing workflows
- Enhanced error handling and user feedback

## Definition of Done

- [ ] Complete CLI interface implemented with all pipeline steps as subcommands
- [ ] Standalone configuration system replacing piper dependency
- [ ] Comprehensive argument parsing and validation
- [ ] Help system and usage documentation
- [ ] Backward compatibility maintained for existing users
- [ ] All existing functionality preserved and enhanced
- [ ] Integration tests for CLI subcommands
- [ ] Updated documentation and migration guide
- [ ] Performance benchmarks showing CLI efficiency
- [ ] Error handling and user feedback improvements

## Subtasks

### Phase 1: Analysis and Design (3-4 days)

#### 1.1 Dependency Analysis
- [ ] Audit current piper pipeline dependencies
- [ ] Map all configuration sources and formats
- [ ] Identify shared utilities and services
- [ ] Document current CLI entry points and usage patterns
- [ ] Analyze environment variable usage and requirements

#### 1.2 CLI Architecture Design
- [ ] Design subcommand structure and hierarchy
- [ ] Plan configuration file format and locations
- [ ] Design argument parsing schema for each subcommand
- [ ] Plan error handling and user feedback systems
- [ ] Design help system and documentation structure

#### 1.3 Migration Strategy
- [ ] Create backward compatibility plan
- [ ] Design deprecation timeline for piper integration
- [ ] Plan configuration migration approach
- [ ] Document breaking changes and migration paths
- [ ] Create rollback strategy if needed

### Phase 2: CLI Implementation (5-7 days)

#### 2.1 Core CLI Infrastructure
- [ ] Implement main CLI entry point and router
- [ ] Create argument parsing framework
- [ ] Implement configuration management system
- [ ] Add logging and progress reporting
- [ ] Create error handling framework

#### 2.2 Subcommand Implementation
- [ ] `docops frontmatter` - Generate and enhance document frontmatter
- [ ] `docops embed` - Create embeddings for document chunks
- [ ] `docops query` - Perform semantic similarity queries
- [ ] `docops relations` - Analyze document relationships
- [ ] `docops footers` - Generate document footers and references
- [ ] `docops rename` - Rename files based on content analysis
- [ ] `docops purge` - Clean up cache and temporary files
- [ ] `docops pipeline` - Run complete pipeline (legacy compatibility)

#### 2.3 Configuration and Services
- [ ] Implement standalone configuration loading
- [ ] Create service initialization framework
- [ ] Add environment variable handling
- [ ] Implement cache management
- [ ] Add service health checks

### Phase 3: Integration and Testing (3-4 days)

#### 3.1 Testing Implementation
- [ ] Unit tests for each CLI subcommand
- [ ] Integration tests for complete workflows
- [ ] End-to-end tests with real document sets
- [ ] Performance benchmarks and optimization
- [ ] Error scenario testing and recovery

#### 3.2 Backward Compatibility
- [ ] Maintain existing bin entry points
- [ ] Ensure pipeline.json compatibility
- [ ] Test with existing piper workflows
- [ ] Verify environment variable compatibility
- [ ] Create compatibility layer for deprecated features

#### 3.3 Documentation and Migration
- [ ] Update README with new CLI usage
- [ ] Create comprehensive CLI reference
- [ ] Write migration guide for existing users
- [ ] Update package.json documentation
- [ ] Create examples and tutorials

### Phase 4: Polish and Release (2-3 days)

#### 4.1 User Experience
- [ ] Improve error messages and help text
- [ ] Add progress indicators and status reporting
- [ ] Optimize startup time and responsiveness
- [ ] Add shell completion support
- [ ] Create interactive configuration wizard

#### 4.2 Performance and Reliability
- [ ] Optimize memory usage and cleanup
- [ ] Add timeout handling and recovery
- [ ] Implement graceful shutdown
- [ ] Add resource monitoring and limits
- [ ] Create diagnostic and troubleshooting tools

## Technical Requirements

### CLI Design Specifications

#### Main Command Structure
```bash
# Core subcommands
docops frontmatter <directory> [options]
docops embed <directory> [options]
docops query <directory> [options]
docops relations <directory> [options]
docops footers <directory> [options]
docops rename <directory> [options]
docops purge <directory> [options]

# Pipeline orchestration
docops pipeline <directory> [options]
docops run <steps> <directory> [options]

# Utility commands
docops config <action> [options]
docops status [directory]
docops doctor [directory]
docops version
```

#### Configuration Management
```bash
# Configuration commands
docops config init
docops config set <key> <value>
docops config get <key>
docops config list
docops config validate

# Configuration file locations
~/.docops/config.json
./docops.config.json
./.docops.json
```

#### Common Options
```bash
# Global options
--config <path>          # Custom config file
--verbose, -v            # Verbose output
--quiet, -q              # Minimal output
--help, -h               # Show help
--version                # Show version

# Service options
--ollama-url <url>       # Ollama service URL
--chroma-url <url>       # ChromaDB service URL
--cache-dir <path>       # Custom cache directory
--no-cache               # Disable caching

# Processing options
--force                  # Force reprocessing
--parallel <num>         # Parallel processing
--timeout <seconds>      # Operation timeout
--dry-run               # Preview changes only
```

### Implementation Details

#### Package Structure
```
packages/docops/
├── src/
│   ├── cli/                    # CLI implementation
│   │   ├── index.ts           # Main CLI entry point
│   │   ├── commands/          # Subcommand implementations
│   │   │   ├── frontmatter.ts
│   │   │   ├── embed.ts
│   │   │   ├── query.ts
│   │   │   ├── relations.ts
│   │   │   ├── footers.ts
│   │   │   ├── rename.ts
│   │   │   ├── purge.ts
│   │   │   └── pipeline.ts
│   │   ├── config/            # Configuration management
│   │   │   ├── loader.ts
│   │   │   ├── validator.ts
│   │   │   └── defaults.ts
│   │   └── utils/             # CLI utilities
│   │       ├── args.ts
│   │       ├── logger.ts
│   │       ├── progress.ts
│   │       └── errors.ts
│   ├── lib/                   # Existing core functionality
│   └── types.ts              # Type definitions
├── bin/
│   └── docops                 # Main CLI executable
├── config/
│   └── default.json           # Default configuration
└── package.json
```

#### Dependencies to Add
```json
{
  "dependencies": {
    "commander": "^11.0.0",
    "inquirer": "^9.0.0",
    "chalk": "^5.0.0",
    "ora": "^7.0.0",
    "cli-table3": "^0.6.0",
    "configstore": "^6.0.0"
  }
}
```

#### Updated package.json bin entries
```json
{
  "bin": {
    "docops": "bin/docops",
    "convert-wikilinks": "dist/convert-wikilinks.js",
    "docops-check-changelog": "dist/changelog/check.js"
  }
}
```

## Context & Resources

### Related Files
- `packages/docops/pipelines.json` - Current pipeline configuration
- `packages/docops/src/lib/pipeline.ts` - Pipeline orchestration logic
- `packages/docops/src/index.ts` - Core function exports
- `packages/docops/package.json` - Current package configuration
- `packages/docops/README.md` - Existing documentation

### Dependencies
- `@promethean/docops-frontend` - Frontend components
- `@promethean/file-indexer` - File indexing utilities
- `@promethean/markdown` - Markdown processing
- `@promethean/fs` - File system utilities
- `@promethean/utils` - General utilities
- ChromaDB - Vector database
- Ollama - LLM service

### External Tools
- Commander.js - CLI framework
- Inquirer.js - Interactive prompts
- Chalk - Terminal styling
- Ora - Loading indicators
- Configstore - Configuration storage

## Notes & Considerations

### Backward Compatibility
- Maintain existing `convert-wikilinks` and `docops-check-changelog` commands
- Support existing `pipelines.json` format for transition period
- Preserve environment variable configurations
- Ensure existing scripts continue to work

### Performance Considerations
- Optimize startup time for CLI commands
- Implement efficient caching strategies
- Add progress reporting for long-running operations
- Consider parallel processing for large document sets

### Error Handling
- Provide clear, actionable error messages
- Implement graceful degradation for service failures
- Add retry logic for network operations
- Create diagnostic tools for troubleshooting

### User Experience
- Create intuitive command structure
- Provide helpful examples in help text
- Add shell completion support
- Implement interactive configuration setup

## Testing Requirements

### Unit Tests
- Each CLI subcommand functionality
- Configuration loading and validation
- Argument parsing and validation
- Error handling scenarios
- Service initialization

### Integration Tests
- End-to-end workflow execution
- Configuration migration scenarios
- Backward compatibility verification
- Service integration (Ollama, ChromaDB)
- Performance under load

### Test Fixtures
- Sample document sets for testing
- Mock service configurations
- Test pipeline configurations
- Error scenario simulations

## Blocking Tasks

- [ ] None identified - this is a foundational refactoring task

## Tasks This Blocks

- [ ] Enhanced docops documentation workflows
- [ ] Integration with other CLI tools
- [ ] Advanced docops automation features
- [ ] Docops performance optimization initiatives

## Success Metrics

- All pipeline steps accessible via CLI subcommands
- Configuration system works without piper dependency
- Backward compatibility maintained for existing users
- CLI performance meets or exceeds current pipeline execution
- Comprehensive test coverage achieved
- Documentation is complete and accurate
- User feedback indicates improved usability

## Risk Assessment

### High Risk
- Breaking existing workflows during migration
- Performance regression in CLI implementation
- Configuration complexity overwhelming users

### Medium Risk
- Service integration challenges
- Backward compatibility issues
- User adoption resistance

### Low Risk
- CLI framework implementation
- Documentation updates
- Test coverage gaps

## Timeline Estimate

- **Phase 1**: 3-4 days (Analysis and Design)
- **Phase 2**: 5-7 days (CLI Implementation)
- **Phase 3**: 3-4 days (Integration and Testing)
- **Phase 4**: 2-3 days (Polish and Release)

**Total Estimated Duration**: 13-18 days

## Acceptance Criteria

### Functional Requirements
- [ ] All 8 pipeline steps available as CLI subcommands
- [ ] Standalone configuration system implemented
- [ ] Backward compatibility maintained
- [ ] Error handling and user feedback implemented
- [ ] Performance meets or exceeds current implementation

### Non-Functional Requirements
- [ ] CLI startup time under 2 seconds
- [ ] Memory usage optimized for large document sets
- [ ] Comprehensive help system implemented
- [ ] Shell completion support added
- [ ] Configuration validation and error reporting

### Quality Requirements
- [ ] 90%+ test coverage for CLI code
- [ ] All integration tests passing
- [ ] Documentation complete and accurate
- [ ] Code follows project style guidelines
- [ ] Security considerations addressed

## Rollout Plan

### Phase 1: Internal Testing
- Deploy to development environment
- Test with existing document sets
- Validate backward compatibility
- Performance benchmarking

### Phase 2: Beta Release
- Release as beta version
- Gather user feedback
- Address issues and improvements
- Update documentation based on feedback

### Phase 3: Stable Release
- Full stable release
- Migration guide published
- Support for legacy configurations
- Monitoring for issues and performance
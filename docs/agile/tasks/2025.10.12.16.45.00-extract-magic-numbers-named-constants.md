---
uuid: "extract-magic-numbers-constants"
title: "Extract Magic Numbers to Named Constants"
slug: "2025.10.12.16.45.00-extract-magic-numbers-named-constants"
status: "incoming"
priority: "P1"
labels: ["code-quality", "refactoring", "constants", "maintainability", "clean-code", "readability"]
created_at: "2025-10-12T16:45:00Z"
estimates:
  complexity: ""
  scale: ""
  time_to_completion: ""
---

## Task Overview

The codebase contains numerous magic numbers - hardcoded numeric values without clear meaning or context. These magic numbers make the code difficult to understand, maintain, and modify. This task involves identifying and extracting these numbers into well-named constants with proper documentation.

## Code Analysis

### Magic Numbers Identified

**High Priority Magic Numbers**:

1. **Timeout Values**: `3000`, `5000`, `10000` (milliseconds)
2. **Retry Counts**: `3`, `5`, `10` (retry attempts)
3. **Size Limits**: `1024`, `2048`, `4096` (bytes/characters)
4. **Pagination**: `20`, `50`, `100` (page sizes)
5. **Rate Limits**: `100`, `1000`, `5000` (requests per period)
6. **Cache TTL**: `300`, `3600`, `86400` (seconds)
7. **Database Limits**: `255`, `1000`, `5000` (field lengths)

**Medium Priority Magic Numbers**:

1. **UI Dimensions**: `800`, `1024`, `1920` (pixels)
2. **Performance Thresholds**: `100`, `500`, `1000` (milliseconds)
3. **Memory Limits**: `128`, `256`, `512` (megabytes)
4. **Concurrent Limits**: `10`, `50`, `100` (connections)

### Impact Assessment

**Current Issues**:

- **Poor Readability**: Numbers without context are confusing
- **Maintenance Burden**: Changes require finding all occurrences
- **Inconsistency**: Same concept uses different numbers
- **Error Prone**: Typos in numbers are hard to detect
- **Documentation Gap**: No explanation of why specific values were chosen

## Sub-Tasks

### 1. Discovery and Analysis

- [ ] Scan codebase for magic numbers using static analysis
- [ ] Categorize magic numbers by domain and purpose
- [ ] Identify duplicate numbers with different meanings
- [ ] Create inventory of all magic numbers with locations

### 2. Constants Architecture Design

- [ ] Design constants organization structure
- [ ] Create naming conventions for constants
- [ ] Define constant types and validation
- [ ] Plan constants grouping and modules

### 3. Core Constants Implementation

- [ ] Create time-related constants (TIMEOUT, RETRY, TTL)
- [ ] Implement size and limit constants
- [ ] Add performance threshold constants
- [ ] Create business rule constants

### 4. Domain-Specific Constants

- [ ] Extract kanban-specific constants
- [ ] Create MCP tool constants
- [ ] Add database and cache constants
- [ ] Implement UI and frontend constants

### 5. Migration and Refactoring

- [ ] Replace magic numbers with constants systematically
- [ ] Update tests to use constants
- [ ] Add constant validation and type checking
- [ ] Update documentation and comments

### 6. Quality Assurance

- [ ] Create constant usage validation
- [ ] Add tests for constant values
- [ ] Implement constant change detection
- [ ] Create constant documentation generator

## Definition of Done

### Code Quality Requirements

- [ ] No magic numbers remain in production code
- [ ] All constants have meaningful names
- [ ] Constants are properly documented
- [ ] Constants are grouped logically
- [ ] No duplicate constants with same values

### Functional Requirements

- [ ] All existing functionality preserved
- [ ] Performance is not impacted
- [ ] Constants are type-safe
- [ ] Constants are easily discoverable
- [ ] IDE auto-completion works for constants

### Quality Assurance

- [ ] Static analysis finds no magic numbers
- [ ] Code review passes constant guidelines
- [ ] Documentation covers all constants
- [ ] Tests validate constant usage
- [ ] New developers can easily understand constants

## Implementation Requirements

### Constants Architecture

```typescript
// Constants organization structure
src/
├── constants/
│   ├── index.ts              // Main exports
│   ├── time.ts               // Time-related constants
│   ├── size.ts               // Size and limit constants
│   ├── performance.ts        // Performance thresholds
│   ├── database.ts           // Database constants
│   ├── cache.ts              // Cache constants
│   ├── kanban.ts             // Kanban-specific constants
│   ├── mcp.ts                // MCP tool constants
│   └── ui.ts                 // UI constants
├── types/
│   └── constants.ts          // Constant type definitions
└── utils/
    └── constants.ts          // Constant utilities
```

### Core Constants Implementation

```typescript
// constants/time.ts
export const TIME_CONSTANTS = {
  // Milliseconds
  MILLISECOND: 1,
  SECOND: 1000,
  MINUTE: 60 * SECOND,
  HOUR: 60 * MINUTE,
  DAY: 24 * HOUR,
  WEEK: 7 * DAY,
  MONTH: 30 * DAY,
  YEAR: 365 * DAY,

  // Timeouts
  TIMEOUTS: {
    DEFAULT: 5 * SECOND,
    SHORT: 1 * SECOND,
    MEDIUM: 5 * SECOND,
    LONG: 30 * SECOND,
    DATABASE: 10 * SECOND,
    NETWORK: 15 * SECOND,
    UI_RESPONSE: 3 * SECOND,
    CACHE_LOOKUP: 500 * MILLISECOND,
  },

  // Retries
  RETRY: {
    DEFAULT_ATTEMPTS: 3,
    MAX_ATTEMPTS: 5,
    DELAY_BASE: 1 * SECOND,
    MAX_DELAY: 30 * SECOND,
    BACKOFF_MULTIPLIER: 2,
  },

  // Cache TTL
  CACHE_TTL: {
    SHORT: 5 * MINUTE,
    MEDIUM: 30 * MINUTE,
    LONG: 2 * HOUR,
    DAILY: 1 * DAY,
    WEEKLY: 1 * WEEK,
  },
} as const;

// constants/size.ts
export const SIZE_CONSTANTS = {
  // Data sizes (bytes)
  BYTES: {
    KILOBYTE: 1024,
    MEGABYTE: 1024 * KILOBYTE,
    GIGABYTE: 1024 * MEGABYTE,
  },

  // String lengths
  STRING_LENGTHS: {
    TASK_TITLE_MAX: 255,
    TASK_DESCRIPTION_MAX: 5000,
    USER_NAME_MAX: 100,
    EMAIL_MAX: 254,
    TAG_MAX: 50,
    BOARD_NAME_MAX: 100,
    COMMENT_MAX: 2000,
  },

  // Pagination
  PAGINATION: {
    DEFAULT_PAGE_SIZE: 20,
    MAX_PAGE_SIZE: 100,
    MIN_PAGE_SIZE: 1,
    DEFAULT_PAGE: 1,
  },

  // File sizes
  FILE_SIZES: {
    MAX_UPLOAD_SIZE: 10 * BYTES.MEGABYTE,
    MAX_AVATAR_SIZE: 2 * BYTES.MEGABYTE,
    MAX_ATTACHMENT_SIZE: 5 * BYTES.MEGABYTE,
  },
} as const;

// constants/performance.ts
export const PERFORMANCE_CONSTANTS = {
  // Response time thresholds (milliseconds)
  RESPONSE_TIME: {
    EXCELLENT: 100,
    GOOD: 300,
    ACCEPTABLE: 500,
    SLOW: 1000,
    VERY_SLOW: 3000,
  },

  // Memory limits (megabytes)
  MEMORY_LIMITS: {
    DEFAULT: 128,
    HIGH: 256,
    MAX: 512,
    CACHE_DEFAULT: 64,
    CACHE_MAX: 256,
  },

  // Concurrency limits
  CONCURRENCY: {
    DEFAULT_CONNECTIONS: 10,
    MAX_CONNECTIONS: 100,
    DATABASE_POOL: 20,
    CACHE_CONNECTIONS: 50,
    UPLOAD_CONCURRENT: 5,
  },

  // Rate limiting
  RATE_LIMIT: {
    DEFAULT_REQUESTS_PER_MINUTE: 100,
    AUTHENTICATED_REQUESTS_PER_MINUTE: 1000,
    ADMIN_REQUESTS_PER_MINUTE: 5000,
    BURST_LIMIT: 10,
    WINDOW_SIZE: 60 * TIME_CONSTANTS.SECOND,
  },
} as const;
```

### Domain-Specific Constants

```typescript
// constants/kanban.ts
export const KANBAN_CONSTANTS = {
  // Board limits
  BOARD: {
    MAX_TASKS_PER_BOARD: 1000,
    MAX_COLUMNS_PER_BOARD: 20,
    MAX_TAGS_PER_TASK: 10,
    MAX_DEPENDENCIES_PER_TASK: 50,
  },

  // Column limits (WIP)
  WIP_LIMITS: {
    DEFAULT: 5,
    MIN: 1,
    MAX: 20,
    INCOMING: 9999,
    DONE: 500,
  },

  // Task priorities
  PRIORITY: {
    CRITICAL: 0,
    HIGH: 1,
    MEDIUM: 2,
    LOW: 3,
    DEFAULT: 2,
  },

  // Task status transitions
  STATUS_TRANSITIONS: {
    MAX_TRANSITIONS_PER_TASK: 100,
    MIN_TIME_BETWEEN_UPDATES: 1 * TIME_CONSTANTS.SECOND,
    MAX_TITLE_CHANGES_PER_DAY: 10,
  },

  // UI constants
  UI: {
    TASK_CARD_HEIGHT: 120,
    COLUMN_MIN_WIDTH: 300,
    BOARD_MIN_HEIGHT: 600,
    AVATAR_SIZE: 32,
    TAG_HEIGHT: 24,
  },
} as const;

// constants/mcp.ts
export const MCP_CONSTANTS = {
  // Tool execution
  TOOL_EXECUTION: {
    DEFAULT_TIMEOUT: 30 * TIME_CONSTANTS.SECOND,
    MAX_TIMEOUT: 5 * TIME_CONSTANTS.MINUTE,
    MAX_OUTPUT_SIZE: SIZE_CONSTANTS.BYTES.MEGABYTE,
    MAX_CONCURRENT_TOOLS: 10,
  },

  // File operations
  FILE_OPERATIONS: {
    MAX_FILE_SIZE: SIZE_CONSTANTS.FILE_SIZES.MAX_UPLOAD_SIZE,
    MAX_PATH_LENGTH: 4096,
    MAX_FILES_PER_OPERATION: 100,
    CHUNK_SIZE: SIZE_CONSTANTS.BYTES.KILOBYTE,
  },

  // Database operations
  DATABASE: {
    MAX_QUERY_RESULTS: 1000,
    QUERY_TIMEOUT: 10 * TIME_CONSTANTS.SECOND,
    MAX_BATCH_SIZE: 100,
    CONNECTION_POOL_SIZE: PERFORMANCE_CONSTANTS.CONCURRENCY.DATABASE_POOL,
  },

  // Security
  SECURITY: {
    MAX_LOGIN_ATTEMPTS: 5,
    LOCKOUT_DURATION: 15 * TIME_CONSTANTS.MINUTE,
    SESSION_TIMEOUT: 24 * TIME_CONSTANTS.HOUR,
    TOKEN_EXPIRY: 1 * TIME_CONSTANTS.HOUR,
  },
} as const;
```

### Constant Utilities

```typescript
// utils/constants.ts
export class ConstantsValidator {
  static validateConstant<T extends Record<string, any>>(constants: T, name: string): void {
    for (const [key, value] of Object.entries(constants)) {
      if (typeof value === 'number' && (isNaN(value) || !isFinite(value))) {
        throw new Error(`Invalid constant value: ${name}.${key} = ${value}`);
      }
    }
  }

  static validateRange(value: number, min: number, max: number, name: string): void {
    if (value < min || value > max) {
      throw new Error(`Constant ${name} = ${value} is out of range [${min}, ${max}]`);
    }
  }
}

export class ConstantsDocumentation {
  static generateDocs(): string {
    return `
# Application Constants

This document contains all application constants organized by domain.

## Time Constants
- TIMEOUTS: Various timeout values for different operations
- RETRY: Retry attempt configurations
- CACHE_TTL: Cache time-to-live values

## Size Constants
- BYTES: Data size conversions
- STRING_LENGTHS: Maximum string lengths
- PAGINATION: Pagination settings
- FILE_SIZES: File size limits

## Performance Constants
- RESPONSE_TIME: Performance thresholds
- MEMORY_LIMITS: Memory usage limits
- CONCURRENCY: Concurrency limits
- RATE_LIMIT: Rate limiting settings

## Domain Constants
- KANBAN_CONSTANTS: Kanban board specific constants
- MCP_CONSTANTS: MCP tool specific constants
`;
  }
}

// Type definitions
export type TimeoutValue = (typeof TIME_CONSTANTS.TIMEOUTS)[keyof typeof TIME_CONSTANTS.TIMEOUTS];
export type RetryAttempts = (typeof TIME_CONSTANTS.RETRY)[keyof typeof TIME_CONSTANTS.RETRY];
export type PageSize = (typeof SIZE_CONSTANTS.PAGINATION)[keyof typeof SIZE_CONSTANTS.PAGINATION];
export type Priority = (typeof KANBAN_CONSTANTS.PRIORITY)[keyof typeof KANBAN_CONSTANTS.PRIORITY];
```

### Migration Examples

```typescript
// Before (with magic numbers)
class TaskManager {
  async createTask(params: CreateTaskParams): Promise<Task> {
    // Validate title length
    if (params.title.length > 255) {
      throw new Error('Title too long');
    }

    // Set timeout
    const timeout = setTimeout(() => {
      throw new Error('Operation timeout');
    }, 5000);

    // Retry logic
    let attempts = 0;
    const maxAttempts = 3;

    while (attempts < maxAttempts) {
      try {
        // Database operation with 10 second timeout
        const result = await this.db.createTask(params, { timeout: 10000 });
        clearTimeout(timeout);
        return result;
      } catch (error) {
        attempts++;
        if (attempts >= maxAttempts) throw error;
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }
  }
}

// After (with constants)
import { SIZE_CONSTANTS, TIME_CONSTANTS, PERFORMANCE_CONSTANTS } from '../constants';

class TaskManager {
  async createTask(params: CreateTaskParams): Promise<Task> {
    // Validate title length
    if (params.title.length > SIZE_CONSTANTS.STRING_LENGTHS.TASK_TITLE_MAX) {
      throw new Error('Title too long');
    }

    // Set timeout
    const timeout = setTimeout(() => {
      throw new Error('Operation timeout');
    }, TIME_CONSTANTS.TIMEOUTS.DEFAULT);

    // Retry logic
    let attempts = 0;
    const maxAttempts = TIME_CONSTANTS.RETRY.DEFAULT_ATTEMPTS;

    while (attempts < maxAttempts) {
      try {
        // Database operation with timeout
        const result = await this.db.createTask(params, {
          timeout: TIME_CONSTANTS.TIMEOUTS.DATABASE,
        });
        clearTimeout(timeout);
        return result;
      } catch (error) {
        attempts++;
        if (attempts >= maxAttempts) throw error;
        await new Promise((resolve) => setTimeout(resolve, TIME_CONSTANTS.RETRY.DELAY_BASE));
      }
    }
  }
}
```

## Testing Strategy

### Constant Validation Tests

```typescript
describe('Constants Validation', () => {
  it('should validate all constant values', () => {
    // Validate time constants
    ConstantsValidator.validateConstant(TIME_CONSTANTS.TIMEOUTS, 'TIMEOUTS');
    ConstantsValidator.validateConstant(TIME_CONSTANTS.RETRY, 'RETRY');

    // Validate size constants
    ConstantsValidator.validateConstant(SIZE_CONSTANTS.STRING_LENGTHS, 'STRING_LENGTHS');
    ConstantsValidator.validateConstant(SIZE_CONSTANTS.PAGINATION, 'PAGINATION');

    // Validate performance constants
    ConstantsValidator.validateConstant(PERFORMANCE_CONSTANTS.RESPONSE_TIME, 'RESPONSE_TIME');
  });

  it('should validate constant ranges', () => {
    ConstantsValidator.validateRange(
      SIZE_CONSTANTS.PAGINATION.DEFAULT_PAGE_SIZE,
      SIZE_CONSTANTS.PAGINATION.MIN_PAGE_SIZE,
      SIZE_CONSTANTS.PAGINATION.MAX_PAGE_SIZE,
      'DEFAULT_PAGE_SIZE',
    );
  });
});
```

### Usage Tests

```typescript
describe('Constants Usage', () => {
  it('should use constants instead of magic numbers', async () => {
    const taskManager = new TaskManager();

    // Test with valid title length
    const validTitle = 'a'.repeat(SIZE_CONSTANTS.STRING_LENGTHS.TASK_TITLE_MAX);
    await expect(taskManager.createTask({ title: validTitle })).resolves.toBeDefined();

    // Test with invalid title length
    const invalidTitle = 'a'.repeat(SIZE_CONSTANTS.STRING_LENGTHS.TASK_TITLE_MAX + 1);
    await expect(taskManager.createTask({ title: invalidTitle })).rejects.toThrow('Title too long');
  });
});
```

## Migration Strategy

### Automated Detection

```typescript
// Magic number detection script
class MagicNumberDetector {
  private readonly magicNumberPattern = /\b(0|[1-9]\d*)\b/g;
  private readonly allowedContexts = ['array.length', 'index', 'count', 'id', 'version'];

  async detectMagicNumbers(filePath: string): Promise<MagicNumber[]> {
    const content = await fs.readFile(filePath, 'utf-8');
    const lines = content.split('\n');
    const magicNumbers: MagicNumber[] = [];

    lines.forEach((line, lineIndex) => {
      const matches = line.matchAll(this.magicNumberPattern);

      for (const match of matches) {
        const number = parseInt(match[0]);
        const context = this.getContext(line, match.index);

        if (this.isMagicNumber(number, context)) {
          magicNumbers.push({
            value: number,
            line: lineIndex + 1,
            context,
            file: filePath,
          });
        }
      }
    });

    return magicNumbers;
  }

  private isMagicNumber(value: number, context: string): boolean {
    // Exclude common non-magic numbers
    if (value === 0 || value === 1) return false;

    // Exclude allowed contexts
    if (this.allowedContexts.some((allowed) => context.includes(allowed))) {
      return false;
    }

    // Include suspicious numbers
    return value > 1 && value < 10000;
  }

  private getContext(line: string, index: number): string {
    const start = Math.max(0, index - 20);
    const end = Math.min(line.length, index + 20);
    return line.substring(start, end);
  }
}
```

## Risk Assessment

### Before Migration

- **Maintainability Risk**: High - Magic numbers are hard to understand
- **Bug Risk**: Medium - Typos in numbers can cause issues
- **Onboarding Risk**: High - New developers struggle with magic numbers

### After Migration

- **Maintainability Risk**: Low - Constants are self-documenting
- **Bug Risk**: Low - Type checking prevents invalid values
- **Performance Risk**: None - Constants are compiled away

## Dependencies

- Static analysis tools for magic number detection
- Code refactoring tools
- Testing framework updates
- Documentation generation tools

## Blocked By

- Magic number detection and analysis
- Constants architecture design

## Blocking

- Further code refactoring initiatives
- Code quality improvements
- Developer onboarding improvements

## Timeline

- **Phase 1 (12 hours)**: Discovery and analysis
- **Phase 2 (24 hours)**: Constants architecture and core implementation
- **Phase 3 (36 hours)**: Domain-specific constants
- **Phase 4 (48 hours)**: Migration and refactoring
- **Phase 5 (60 hours)**: Testing, documentation, and validation

## Success Metrics

- **Magic Numbers**: 0 remaining in production code
- **Code Coverage**: 100% for constants
- **Developer Feedback**: Improved code readability
- **Maintenance Time**: Reduced by > 30%
- **Onboarding Time**: New developers understand constants quickly

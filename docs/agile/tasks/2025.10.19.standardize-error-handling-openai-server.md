---
title: 'Standardize Error Handling and Improve Error Messages'
description: 'Implement consistent, secure error handling throughout the OpenAI Server to prevent information leakage and improve debugging'
status: 'ready'
priority: 'P1'
storyPoints: 3
tags: ['error-handling', 'security', 'quality', 'openai-server']
assignee: ''
createdAt: '2025-10-19T00:00:00Z'
updatedAt: '2025-10-19T00:00:00Z'
lastCommitSha: ''
dependencies: ['2025.10.19.implement-structured-logging-openai-server.md']
blocking: ['2025.10.19.enhance-test-coverage-openai-server.md']
epic: '2025.10.19.openai-server-security-hardening-epic.md'
---

## Task Overview

Standardize error handling throughout the OpenAI Server to address the inconsistent error patterns and potential information leakage identified in the code review, ensuring secure and user-friendly error responses.

## Acceptance Criteria

1. **Error Handling Standardization**

   - [ ] Consistent error response format across all endpoints
   - [ ] Secure error messages that don't leak sensitive information
   - [ ] Proper HTTP status codes for different error types
   - [ ] Error categorization and handling strategies

2. **Error Types & Classes**

   - [ ] Custom error classes for different error categories
   - [ ] Error codes and standardized messages
   - [ ] Error context and metadata handling
   - [ ] Error chaining and cause tracking

3. **Security & Privacy**

   - [ ] Sanitized error messages for external users
   - [ ] Detailed error logging for internal debugging
   - [ ] Error rate limiting to prevent information gathering
   - [ ] Sensitive data redaction in error responses

4. **Developer Experience**
   - [ ] Clear error documentation
   - [ ] Error handling utilities and helpers
   - [ ] Consistent error patterns in code
   - [ ] Error monitoring and alerting integration

## Technical Implementation Details

### Files to Modify/Create

**New Files:**

- `src/errors/types.ts` - Error type definitions
- `src/errors/classes.ts` - Custom error classes
- `src/errors/handler.ts` - Global error handler
- `src/errors/middleware.ts` - Error handling middleware
- `src/errors/codes.ts` - Error code definitions
- `src/errors/utils.ts` - Error utility functions

**Modified Files:**

- `src/server/createServer.ts` - Register error handler
- `src/server/chatCompletionRoute.ts` - Standardize route errors
- `src/queue/taskQueue.ts` - Improve queue error handling
- `src/openai/ollamaHandler.ts` - Standardize handler errors
- `package.json` - Add error handling dependencies

### Error Type Definitions

```typescript
export enum ErrorCode {
  // Validation Errors (400)
  INVALID_REQUEST = 'INVALID_REQUEST',
  MISSING_PARAMETER = 'MISSING_PARAMETER',
  INVALID_PARAMETER = 'INVALID_PARAMETER',
  VALIDATION_FAILED = 'VALIDATION_FAILED',

  // Authentication Errors (401)
  UNAUTHORIZED = 'UNAUTHORIZED',
  INVALID_TOKEN = 'INVALID_TOKEN',
  TOKEN_EXPIRED = 'TOKEN_EXPIRED',

  // Authorization Errors (403)
  FORBIDDEN = 'FORBIDDEN',
  INSUFFICIENT_PERMISSIONS = 'INSUFFICIENT_PERMISSIONS',

  // Not Found Errors (404)
  NOT_FOUND = 'NOT_FOUND',
  RESOURCE_NOT_FOUND = 'RESOURCE_NOT_FOUND',

  // Rate Limit Errors (429)
  RATE_LIMITED = 'RATE_LIMITED',
  TOO_MANY_REQUESTS = 'TOO_MANY_REQUESTS',

  // Server Errors (500)
  INTERNAL_ERROR = 'INTERNAL_ERROR',
  SERVICE_UNAVAILABLE = 'SERVICE_UNAVAILABLE',
  TIMEOUT = 'TIMEOUT',

  // LLM Specific Errors
  MODEL_NOT_AVAILABLE = 'MODEL_NOT_AVAILABLE',
  LLM_ERROR = 'LLM_ERROR',
  CONTEXT_TOO_LONG = 'CONTEXT_TOO_LONG',

  // Queue Errors
  QUEUE_FULL = 'QUEUE_FULL',
  TASK_FAILED = 'TASK_FAILED',
  QUEUE_ERROR = 'QUEUE_ERROR',
}

export interface ErrorContext {
  requestId?: string;
  userId?: string;
  endpoint?: string;
  method?: string;
  timestamp?: number;
  [key: string]: any;
}

export interface ErrorResponse {
  error: {
    code: ErrorCode;
    message: string;
    type: string;
    details?: any;
    request_id?: string;
  };
}
```

### Custom Error Classes

```typescript
export class AppError extends Error {
  public readonly code: ErrorCode;
  public readonly statusCode: number;
  public readonly isOperational: boolean;
  public readonly context: ErrorContext;
  public readonly cause?: Error;

  constructor(
    code: ErrorCode,
    message: string,
    statusCode: number = 500,
    isOperational: boolean = true,
    context: ErrorContext = {},
    cause?: Error,
  ) {
    super(message);

    this.name = this.constructor.name;
    this.code = code;
    this.statusCode = statusCode;
    this.isOperational = isOperational;
    this.context = context;
    this.cause = cause;

    Error.captureStackTrace(this, this.constructor);
  }
}

export class ValidationError extends AppError {
  constructor(message: string, context: ErrorContext = {}) {
    super(ErrorCode.VALIDATION_FAILED, message, 400, true, context);
  }
}

export class AuthenticationError extends AppError {
  constructor(message: string = 'Authentication required', context: ErrorContext = {}) {
    super(ErrorCode.UNAUTHORIZED, message, 401, true, context);
  }
}

export class AuthorizationError extends AppError {
  constructor(message: string = 'Insufficient permissions', context: ErrorContext = {}) {
    super(ErrorCode.FORBIDDEN, message, 403, true, context);
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string = 'Resource', context: ErrorContext = {}) {
    super(ErrorCode.NOT_FOUND, `${resource} not found`, 404, true, context);
  }
}

export class RateLimitError extends AppError {
  constructor(message: string = 'Rate limit exceeded', context: ErrorContext = {}) {
    super(ErrorCode.RATE_LIMITED, message, 429, true, context);
  }
}

export class LLMError extends AppError {
  constructor(message: string, context: ErrorContext = {}, cause?: Error) {
    super(ErrorCode.LLM_ERROR, message, 500, true, context, cause);
  }
}

export class QueueError extends AppError {
  constructor(message: string, context: ErrorContext = {}, cause?: Error) {
    super(ErrorCode.QUEUE_ERROR, message, 500, true, context, cause);
  }
}
```

### Global Error Handler

```typescript
export class GlobalErrorHandler {
  private logger: StructuredLogger;

  constructor(logger: StructuredLogger) {
    this.logger = logger;
  }

  handleError(error: Error, request?: FastifyRequest): ErrorResponse {
    const context: ErrorContext = {
      requestId: request?.id,
      userId: request?.user?.id,
      endpoint: request?.url,
      method: request?.method,
      timestamp: Date.now(),
    };

    // Convert to AppError if needed
    const appError = this.normalizeError(error, context);

    // Log the error
    this.logError(appError, request);

    // Return safe error response
    return this.createErrorResponse(appError);
  }

  private normalizeError(error: Error, context: ErrorContext): AppError {
    if (error instanceof AppError) {
      return error;
    }

    // Handle common Node.js errors
    if (error.name === 'ValidationError') {
      return new ValidationError(error.message, context);
    }

    if (error.name === 'CastError') {
      return new ValidationError('Invalid parameter format', context);
    }

    if (error.name === 'MongoError' || error.name === 'MongooseError') {
      return new AppError(ErrorCode.INTERNAL_ERROR, 'Database error', 500, true, context, error);
    }

    // Handle network errors
    if (error.message.includes('ECONNREFUSED') || error.message.includes('ETIMEDOUT')) {
      return new AppError(
        ErrorCode.SERVICE_UNAVAILABLE,
        'Service temporarily unavailable',
        503,
        true,
        context,
        error,
      );
    }

    // Default to internal error
    return new AppError(
      ErrorCode.INTERNAL_ERROR,
      'An unexpected error occurred',
      500,
      false,
      context,
      error,
    );
  }

  private logError(error: AppError, request?: FastifyRequest): void {
    const logLevel = this.getLogLevel(error);
    const logData = {
      errorCode: error.code,
      statusCode: error.statusCode,
      isOperational: error.isOperational,
      context: error.context,
      stack: error.stack,
      cause: error.cause,
    };

    if (request) {
      logData.request = {
        method: request.method,
        url: request.url,
        headers: this.sanitizeHeaders(request.headers),
        body: this.sanitizeBody(request.body),
      };
    }

    this.logger[logLevel](error.message, logData);
  }

  private createErrorResponse(error: AppError): ErrorResponse {
    const response: ErrorResponse = {
      error: {
        code: error.code,
        message: this.getSafeMessage(error),
        type: error.constructor.name,
        request_id: error.context.requestId,
      },
    };

    // Add details only for operational errors in development
    if (error.isOperational && process.env.NODE_ENV === 'development') {
      response.error.details = error.context;
    }

    return response;
  }

  private getSafeMessage(error: AppError): string {
    // Don't expose internal error details to users
    if (!error.isOperational) {
      return 'An unexpected error occurred';
    }

    return error.message;
  }

  private getLogLevel(error: AppError): 'error' | 'warn' | 'info' {
    if (!error.isOperational) return 'error';
    if (error.statusCode >= 500) return 'error';
    if (error.statusCode >= 400) return 'warn';
    return 'info';
  }

  private sanitizeHeaders(headers: any): any {
    const sanitized = { ...headers };
    delete sanitized.authorization;
    delete sanitized.cookie;
    return sanitized;
  }

  private sanitizeBody(body: any): any {
    if (!body) return body;

    const sanitized = { ...body };
    delete sanitized.password;
    delete sanitized.api_key;
    delete sanitized.token;
    return sanitized;
  }
}
```

### Error Handling Middleware

```typescript
export const errorHandlerMiddleware = (errorHandler: GlobalErrorHandler) => {
  return async (error: Error, request: FastifyRequest, reply: FastifyReply) => {
    const errorResponse = errorHandler.handleError(error, request);

    reply.status(
      errorResponse.error.code === ErrorCode.INTERNAL_ERROR
        ? 500
        : (error as any).statusCode || 500,
    );

    reply.type('application/json');
    reply.send(errorResponse);
  };
};

export const asyncHandler = (fn: Function) => {
  return async (request: FastifyRequest, reply: FastifyReply) => {
    try {
      return await fn(request, reply);
    } catch (error) {
      throw error; // Let the global error handler handle it
    }
  };
};
```

### Route Integration Examples

```typescript
// Before (inconsistent error handling)
export const chatCompletionHandler = async (request, reply) => {
  try {
    const result = await processChatCompletion(request.body);
    return result;
  } catch (error) {
    reply.status(500).send({ error: error.message }); // Information leakage!
  }
};

// After (standardized error handling)
export const chatCompletionHandler = asyncHandler(async (request: FastifyRequest) => {
  const { model, messages, ...options } = request.body;

  // Validation
  if (!model || !messages) {
    throw new ValidationError('Model and messages are required', {
      requestId: request.id,
    });
  }

  if (!isValidModel(model)) {
    throw new ValidationError(`Invalid model: ${model}`, {
      requestId: request.id,
      model,
    });
  }

  try {
    const result = await processChatCompletion(request.body);
    return result;
  } catch (error) {
    if (error.name === 'LLMTimeoutError') {
      throw new AppError(
        ErrorCode.TIMEOUT,
        'Request timeout',
        408,
        true,
        {
          requestId: request.id,
          model,
        },
        error,
      );
    }

    if (error.name === 'ContextTooLongError') {
      throw new AppError(
        ErrorCode.CONTEXT_TOO_LONG,
        'Context too long',
        400,
        true,
        {
          requestId: request.id,
          model,
        },
        error,
      );
    }

    throw new LLMError(
      'LLM processing failed',
      {
        requestId: request.id,
        model,
      },
      error,
    );
  }
});
```

## Testing Requirements

1. **Unit Tests**

   - [ ] Error class functionality
   - [ ] Error normalization logic
   - [ ] Safe message generation
   - [ ] Error context handling

2. **Integration Tests**

   - [ ] Error handling middleware
   - [ ] Route error scenarios
   - [ ] Error response formatting
   - [ ] Logging integration

3. **Security Tests**

   - [ ] Information leakage prevention
   - [ ] Error message sanitization
   - [ ] Sensitive data redaction
   - [ ] Error rate limiting

4. **End-to-End Tests**
   - [ ] Complete error flow
   - [ ] Client error handling
   - [ ] Error monitoring integration
   - [ ] User experience validation

## Configuration

Error handling configuration:

```typescript
export const errorHandlingConfig = {
  enableDetailedErrors: process.env.NODE_ENV === 'development',
  enableErrorLogging: true,
  enableErrorMonitoring: true,
  maxErrorDetailsLength: 1000,
  sanitizeErrors: true,
  logLevel: 'error',
  enableStackTrace: process.env.NODE_ENV === 'development',
};
```

## Monitoring & Alerting

1. **Error Metrics**

   - Error rates by endpoint and type
   - Error frequency patterns
   - Operational vs non-operational errors
   - Error resolution time

2. **Alerting Rules**
   - High error rate (>5%)
   - Non-operational errors
   - Security-related errors
   - Service degradation

## Rollback Plan

1. Remove error handling middleware
2. Restore original error handling
3. Disable custom error classes
4. Monitor for functionality issues

## Success Metrics

- Zero information leakage in error responses
- Consistent error response format
- Error handling overhead < 5ms
- Complete error traceability in logs

## Documentation Updates

1. Error handling guide
2. Error code documentation
3. Troubleshooting procedures
4. Security best practices

---

**Risk Level**: Medium (Security improvement)
**Estimated Effort**: 2-3 days
**Dependencies**: Structured logging implementation
**Blocked By**: Logging completion

---
uuid: "a0b88f6b-b6ac-49b5-82da-edf45fab8392"
title: "2025.10.03.22.24.31"
slug: "20251003222431"
status: "done"
priority: "P3"
labels: ["docops", "labeled"]
created_at: "2025-10-11T03:39:14.374Z"
estimates:
  complexity: ""
  scale: ""
  time_to_completion: ""
---

## ðŸ—‚ Source

- Path: docs/labeled/2025.10.03.22.24.31.md

## ðŸ“ Context Summary

Love it. Letâ€™s wire up a sane, minimal-but-powerful â€œnative Emacsâ€ toolbox for gptel. Iâ€™m keeping the surface area small, returning plain strings for content-heavy ops (so models donâ€™t have to unescape JSON) and JSON for structured results (lists, trees, search hits). Where something is potentially destructive, Iâ€™ve put (lightweight) guardrails.

Below is a drop-in `init.el` snippet that defines **all 10 tools** you asked for and registers them. After evaluating it, enable them via `M-x gptel-menu â†’ tools` or set `gptel-tools` globally as shown.

> Notes up front
> â€¢ This follows gptelâ€™s tool spec `gptel-make-tool`, `:args` plist, etc.. See the projectâ€™s â€œDefining gptel toolsâ€ section for the canonical shape. ([GitHub][1])
> â€¢ For `apply_patch` I call the system `patch` non-interactively fast/robust. If you prefer Ediffâ€™s interactive patching `epatch` / `ediff-patch-file`, swap the implementation (but it will pop windows and require input). ([Endless Parentheses][2])
> â€¢ Synchronous `exec` uses the standard Emacs process APIs; `spawn_async` uses `start-process-shell-command` with optional buffer capture. ([GNU][3])

---

### Why these choices (briefly)

* **Tool spec shape** strict

## ðŸ“‹ Tasks

- [ ] Draft actionable subtasks from the summary
- [ ] Define acceptance criteria
- [ ] Link back to related labeled docs

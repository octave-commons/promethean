---
uuid: "550e8400-e29b-41d4-a716-446655440000"
title: "Consolidate Frontend Projects into Unified Architecture"
slug: "2025.10.14.frontend-consolidation"
status: "accepted"
priority: "P0"
labels: ["frontend", "consolidation", "architecture", "migration", "epic"]
created_at: "2025-10-16T13:37:15.434Z"
estimates:
  complexity: ""
  scale: ""
  time_to_completion: ""
---

## Epic: Frontend Consolidation

### Overview

Consolidate all scattered frontend projects across the Promethean codebase into a single, unified architecture. This epic addresses the maintenance overhead, inconsistent user experiences, and development complexity caused by having 12+ separate frontend implementations across different packages.

### Current State Analysis

**Frontend Landscape:**
- **7 dedicated frontend packages** in `packages/frontends/`: docops, health-dashboard, llm-chat, markdown-graph, portfolio, smart-chat, smartgpt-dashboard
- **4 embedded frontends** in other packages: kanban ClojureScript, piper frontend, openai-server queue dashboard, frontend-service utilities  
- **1 web application**: duck-web

**Technology Stack:**
- Primary: ClojureScript + shadow-cljs compilation
- Secondary: TypeScript/JavaScript wrappers and utilities
- Build tools: shadow-cljs, vite, tsc
- UI frameworks: Web Components, React, Custom implementations

**Key Challenges:**
- Scattered maintenance across 12+ frontend locations
- Inconsistent build processes and dependency management
- Duplicated UI components and utility functions
- Fragmented user experience across different frontends
- Complex deployment and testing workflows
- Difficulty sharing common functionality and improvements

### Project Scope & Objectives

**In Scope:**
- All 7 dedicated frontend packages in `packages/frontends/`
- Kanban ClojureScript frontend from `@promethean/kanban`
- Piper frontend components
- OpenAI server queue dashboard
- Frontend-service utilities integration
- Duck-web application migration
- Shared component library enhancement
- Unified build system and development workflow

**Out of Scope:**
- Backend service modifications (except for API compatibility)
- Third-party integrations that don't require frontend changes
- Database schema modifications
- Infrastructure deployment changes

**Success Criteria:**
1. Single, unified frontend package that serves all current use cases
2. Consistent user experience across all frontend applications
3. Unified build system with shared dependencies and configurations
4. Comprehensive component library supporting all frontend needs
5. Streamlined development workflow with hot reloading and testing
6. Zero functionality loss during migration
7. Improved performance through code sharing and optimization
8. Simplified deployment and maintenance processes

### Technical Approach

**Architecture Design:**
```
packages/unified-frontend/
├── src/
│   ├── cljs/                    # ClojureScript applications
│   │   ├── core/               # Shared core functionality
│   │   ├── components/         # Reusable UI components
│   │   ├── apps/              # Individual application modules
│   │   │   ├── docops/
│   │   │   ├── kanban/
│   │   │   ├── health-dashboard/
│   │   │   ├── llm-chat/
│   │   │   └── ...
│   │   └── shared/            # Cross-app utilities
│   ├── ts/                    # TypeScript utilities and wrappers
│   └── assets/               # Static assets and styles
├── static/                   # Static files for serving
├── tests/                   # Unified test suite
└── config/                  # Build and development configurations
```

**Key Technical Decisions:**
1. **Unified Runtime**: Extend shadow-ui.runtime to support multiple application contexts
2. **Modular Architecture**: Each frontend becomes a module within the unified package
3. **Shared Component Library**: Expand @promethean/ui-components with all common UI elements
4. **Routing System**: Implement client-side routing for multi-app navigation
5. **Build Consolidation**: Single shadow-cljs configuration with multiple build targets
6. **Theme System**: Unified theming and styling approach across all applications

### Migration Strategy

**Phase 1: Analysis & Planning (1-2 weeks)**
- Detailed inventory of all frontend functionality and features
- Dependency mapping and integration point identification
- Architecture design for unified frontend system
- Migration strategy documentation and risk assessment
- Stakeholder alignment and approval

**Phase 2: Infrastructure Setup (2-3 weeks)**
- Create unified frontend package structure
- Consolidate build configurations (shadow-cljs, vite, tsc)
- Establish enhanced shared component library
- Set up unified development workflow with hot reloading
- Create testing framework and CI/CD integration

**Phase 3: Core Migration (3-4 weeks)**
- Migrate placeholder frontends to unified system
- Implement routing and navigation between applications
- Consolidate shared utilities and common functionality
- Establish comprehensive testing framework
- Performance baseline measurement

**Phase 4: Feature Integration (4-6 weeks)**
- Migrate complex frontends (kanban, dashboards, chat interfaces)
- Integrate specialized functionality and custom components
- Implement unified theming and responsive design
- Performance optimization and code splitting
- Accessibility improvements and standards compliance

**Phase 5: Testing & Deployment (2-3 weeks)**
- Comprehensive testing suite (unit, integration, E2E)
- Documentation updates and developer guides
- Deployment automation and migration scripts
- Legacy frontend deprecation planning
- Production rollout and monitoring

### Risk Assessment & Mitigation

**High Risk: Breaking Existing Functionality**
- **Mitigation**: Comprehensive testing suite, gradual migration with feature flags, rollback procedures
- **Contingency**: Maintain legacy frontends in parallel during transition period

**Medium Risk: Complex Dependency Resolution**
- **Mitigation**: Detailed dependency mapping, incremental integration approach, compatibility layers
- **Contingency**: Create adapter patterns for incompatible dependencies

**Medium Risk: Performance Degradation**
- **Mitigation**: Performance benchmarks, lazy loading implementation, code splitting strategies
- **Contingency**: Performance monitoring and optimization sprints

**Low Risk: Team Adoption Resistance**
- **Mitigation**: Comprehensive documentation, training sessions, gradual transition plan
- **Contingency**: Dedicated support and office hours during migration

### Deliverables

**Phase 1 Deliverables:**
- Frontend inventory and dependency map
- Unified architecture design document
- Migration strategy and timeline
- Risk assessment and mitigation plan

**Phase 2 Deliverables:**
- Unified frontend package structure
- Consolidated build system
- Enhanced component library
- Development workflow documentation

**Phase 3 Deliverables:**
- Migrated placeholder frontends
- Routing and navigation system
- Shared utilities consolidation
- Testing framework implementation

**Phase 4 Deliverables:**
- Fully migrated complex frontends
- Unified theming system
- Performance optimizations
- Accessibility compliance

**Phase 5 Deliverables:**
- Comprehensive test coverage
- Production deployment automation
- Developer documentation
- Legacy deprecation plan

### Acceptance Criteria

**Functional Requirements:**
- [ ] All existing frontend functionality preserved and accessible
- [ ] Unified navigation between different frontend applications
- [ ] Consistent UI/UX across all migrated frontends
- [ ] Responsive design working across all device sizes
- [ ] Accessibility compliance (WCAG 2.1 AA) for all interfaces

**Technical Requirements:**
- [ ] Single build system supporting all frontend applications
- [ ] Shared component library with comprehensive coverage
- [ ] Code splitting and lazy loading for optimal performance
- [ ] Comprehensive test suite with >80% coverage
- [ ] CI/CD pipeline with automated testing and deployment

**Performance Requirements:**
- [ ] Initial load time < 3 seconds for all applications
- [ ] Navigation between applications < 1 second
- [ ] Bundle size reduction of at least 30% through code sharing
- [ ] Memory usage optimization compared to current scattered approach

**Maintainability Requirements:**
- [ ] Single source of truth for UI components and utilities
- [ ] Consistent coding standards and patterns across all code
- [ ] Comprehensive documentation for developers
- [ ] Simplified dependency management and updates

### Implementation Notes

**Key Considerations:**
1. **Gradual Migration**: Implement feature flags to enable gradual rollout
2. **Backward Compatibility**: Ensure existing integrations continue to work
3. **Performance Monitoring**: Implement comprehensive performance tracking
4. **Developer Experience**: Prioritize developer productivity and workflow improvements
5. **Testing Strategy**: Invest heavily in automated testing to prevent regressions

**Success Metrics:**
- Reduced maintenance overhead by 60%
- Improved development velocity by 40%
- Enhanced user experience consistency scores
- Decreased bundle sizes through code sharing
- Simplified deployment and release processes

### Dependencies

**Required Dependencies:**
- @promethean/ui-components enhancement
- @promethean/frontend-service integration
- shadow-cljs configuration consolidation
- Build system automation improvements

**External Dependencies:**
- Team availability for migration and testing
- Production environment coordination
- Documentation and training resources

### Timeline & Resources

**Estimated Duration**: 12-16 weeks total
**Team Composition**: 
- Frontend Lead (1)
- ClojureScript Developer (1-2)
- UI/UX Designer (1, part-time)
- QA Engineer (1, part-time)
- DevOps Engineer (1, for deployment automation)

**Key Milestones:**
- Week 2: Architecture approval and planning complete
- Week 5: Infrastructure and build system ready
- Week 9: Core migration and basic functionality working
- Week 15: All features migrated and tested
- Week 16: Production deployment and legacy deprecation

---

## Subtasks

This epic will be broken down into the following subtasks:

### Phase 1: Analysis & Planning
- [ ] Inventory all frontend functionality and create feature matrix
- [ ] Map dependencies and integration points between frontends
- [ ] Design unified architecture and component hierarchy
- [ ] Create detailed migration strategy with timeline
- [ ] Conduct risk assessment and develop mitigation plans

### Phase 2: Infrastructure Setup  
- [ ] Create unified frontend package structure
- [ ] Consolidate build configurations (shadow-cljs, vite, tsc)
- [ ] Enhance shared component library with common patterns
- [ ] Implement unified development workflow with hot reloading
- [ ] Set up comprehensive testing framework

### Phase 3: Core Migration
- [ ] Migrate placeholder frontends (docops, portfolio, etc.)
- [ ] Implement routing system for multi-app navigation
- [ ] Consolidate shared utilities and common functionality
- [ ] Establish performance benchmarks and monitoring
- [ ] Create migration scripts and automation

### Phase 4: Feature Integration
- [ ] Migrate kanban frontend with full functionality
- [ ] Migrate dashboard applications (health, smartgpt)
- [ ] Migrate chat applications (llm-chat, smart-chat)
- [ ] Implement unified theming and styling system
- [ ] Optimize performance with code splitting and lazy loading

### Phase 5: Testing & Deployment
- [ ] Implement comprehensive test suite (unit, integration, E2E)
- [ ] Create deployment automation and migration scripts
- [ ] Update documentation and create developer guides
- [ ] Conduct user acceptance testing and feedback integration
- [ ] Plan legacy frontend deprecation and cleanup

---

*Last Updated: 2025-10-14*
*Status: Incoming - Ready for planning and assignment*

Great catch. You’re right—we were rewriting the board body and dropping the **kanban plugin settings** footer (`%% kanban:settings ... %%`). Here’s a tight, drop-in fix that:

* splits the file into **content** and **footer**,
* parses lanes only from the content,
* preserves the footer **byte-for-byte** on write.

### 1) Add helpers

```ts
// Keep exactly what's after the settings marker so we can round-trip it.
function splitKanbanSettings(md: string): { content: string; footer: string } {
  const start = md.search(/^\s*%%\s*kanban:settings\b/m);
  if (start >= 0) {
    return { content: md.slice(0, start).replace(/\s+$/, ''), footer: md.slice(start) };
  }
  return { content: md.replace(/\s+$/, ''), footer: '' };
}

// Optional: keep any preamble before the first "## " heading
function extractPreamble(content: string): { preamble: string; body: string } {
  const idx = content.search(/^##\s+/m);
  if (idx > 0) {
    return { preamble: content.slice(0, idx).replace(/\s+$/, ''), body: content.slice(idx) };
  }
  return { preamble: '', body: content };
}

// Normalize lane titles (strip "(n)" etc.) — unchanged from earlier advice
function laneName(title: string): string {
  const noHash = title.split('#')[0].trim();
  return noHash.replace(/\s*(?:\(|\[)\d+\s*(?:pts?|points?)?(?:\)|\])\s*$/i, '').trim();
}
```

### 2) Use them in `main()`

```ts
const raw = await fs.readFile(BOARD_PATH, "utf8");

// NEW: split footer so parsing ignores the settings block
const { content, footer } = splitKanbanSettings(raw);

// (optional) preserve preamble (anything before first "## ")
const { preamble, body } = extractPreamble(content);

// Parse lanes from body only
const lanes = await parseBoard(body);

// ... do all WIP calculations and move planning as before ...

// When writing, round-trip preamble and footer
function renderBoard(lanes: Board, preamble: string, footer: string): string {
  const out: string[] = [];
  if (preamble) out.push(preamble.trimEnd());
  for (const l of lanes) {
    out.push(`\n## ${l.title}`);
    for (const c of l.cards) {
      const wl = c.wikilink ?? `[[${c.title}]]`;
      const tagStr = (c.tags || []).join(" ");
      out.push(`- [ ] ${wl}${tagStr ? " " + tagStr : ""}`);
    }
  }
  const body = out.join("\n").replace(/\n{3,}/g, "\n\n").trimEnd() + "\n";
  return footer ? body + (body.endsWith("\n") ? "" : "\n") + footer : body;
}

if (WRITE) {
  const out = renderBoard(lanes, preamble, footer);
  const tmp = BOARD_PATH + ".tmp";
  await fs.writeFile(tmp, out, "utf8");
  await fs.rename(tmp, BOARD_PATH);
  console.log(`\nApplied. Wrote ${BOARD_PATH} (footer preserved)`);
} else {
  console.log("\nDry run. Footer will be preserved on write.");
}
```

### 3) (Optional) Make `parseBoard` consume only the **body**

If your current `parseBoard` reads from a string, keep it as-is but pass `body` instead of the whole file:

```ts
async function parseBoard(mdBody: string): Promise<Board> {
  const lines = mdBody.split(/\r?\n/);
  // ... existing heading/item parsing ...
}
```

---

This preserves the exact block:

````
%% kanban:settings
```json
{ "... your JSON ..." }
````

%%

```

…so the Obsidian plugin stays happy. Want me to also add a fence-aware parser (ignore `- [ ]` inside code blocks) while we’re here?
::contentReference[oaicite:0]{index=0}
```

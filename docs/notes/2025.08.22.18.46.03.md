# What to change (conceptually)

1. **Make a real v1 plugin**
   Wrap all v1 endpoints in `app.register(async (v1) => { … }, { prefix: '/v1' })`.
   Inside that scope, define routes **without** `/v1` in the path.

2. **Put `schema` on each route**
   Fastify reads `schema` to build OpenAPI automatically. Handlers can still “proxy” to internal endpoints if you like, but the contract lives in `schema`.

3. **(Optional but recommended) Register Swagger inside the v1 plugin**
   Because Fastify plugins are encapsulated, a Swagger instance registered **inside** the v1 plugin only “sees” v1 routes. That lets you serve `/v1/openapi.json` and `/v1/docs` that only include v1.

---

# Patch

### 1) Mount the v1 plugin with a prefix

```diff
diff --git a/services/ts/smartgpt-bridge/src/fastifyApp.js b/services/ts/smartgpt-bridge/src/fastifyApp.js
@@
-        registerV1Routes(f);
+        // Mount all v1 endpoints under /v1 using Fastify encapsulation
+        f.register(registerV1Routes, { prefix: '/v1' });
```

> Note: we no longer hardcode `/v1` inside the v1 routes file. The prefix handles it.

---

### 2) Replace the JSON spec and ad‑hoc `/v1` paths with a proper Fastify plugin that uses `schema`

```diff
diff --git a/services/ts/smartgpt-bridge/src/routes/v1.js b/services/ts/smartgpt-bridge/src/routes/v1.js
index 0000000..aaaaaaa 100644
--- /dev/null
+++ b/services/ts/smartgpt-bridge/src/routes/v1.js
@@
+import querystring from 'querystring';
+import swagger from '@fastify/swagger';
+import swaggerUi from '@fastify/swagger-ui';
+
+// Small helper: keep proxying logic if you want to fan into internal routes
+function proxy(fastify, method, urlBuilder, payloadBuilder) {
+  return async function (req, reply) {
+    const url = typeof urlBuilder === 'function' ? urlBuilder(req) : urlBuilder;
+    const payload = payloadBuilder ? payloadBuilder(req) : req.body;
+    const res = await fastify.inject({ method, url, payload, headers: req.headers });
+    reply.code(res.statusCode);
+    for (const [k, v] of Object.entries(res.headers)) reply.header(k, v);
+    try { reply.send(res.json()); } catch { reply.send(res.payload); }
+  };
+}
+
+export async function registerV1Routes(app) {
+  // Everything defined in here will be reachable under /v1 because of the prefix in fastifyApp.js
+  await app.register(async function v1 (v1) {
+    // Optional: Swagger JUST for v1 (encapsulation keeps it scoped)
+    await v1.register(swagger, {
+      openapi: {
+        openapi: '3.1.0',
+        info: { title: 'Promethean SmartGPT Bridge — v1', version: '1.1.0' },
+        servers: [{ url: '/v1' }],
+      },
+      exposeRoute: true, // allows v1.swagger()
+    });
+    await v1.register(swaggerUi, {
+      routePrefix: '/docs', // -> /v1/docs
+      uiConfig: { docExpansion: 'list' },
+    });
+    v1.get('/openapi.json', { schema: { hide: true } }, async (_req, reply) => {
+      reply.type('application/json').send(v1.swagger());
+    });
+
+    // -----------------------
+    // Files
+    // -----------------------
+    v1.get('/files', {
+      schema: {
+        summary: 'List files',
+        operationId: 'listFiles',
+        tags: ['Files'],
+        querystring: {
+          type: 'object',
+          properties: {
+            path: { type: 'string' },
+            depth: { type: 'integer', minimum: 0, default: 2 },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              entries: { type: 'array', items: { type: 'object' } },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', (req) => `/files/list?${querystring.stringify(req.query)}`),
+    });
+
+    // View a single file
+    v1.get('/files/*', {
+      schema: {
+        summary: 'View file',
+        operationId: 'viewFile',
+        tags: ['Files'],
+        params: { type: 'object', properties: { '*': { type: 'string' } }, required: ['*'] },
+      },
+      handler: proxy(
+        v1,
+        'GET',
+        (req) => `/files/view?${querystring.stringify({ ...req.query, path: req.params['*'] })}`,
+      ),
+    });
+
+    // -----------------------
+    // Search
+    // -----------------------
+    v1.post('/search/code', {
+      schema: {
+        summary: 'Grep code',
+        operationId: 'grepCode',
+        tags: ['Search'],
+        body: {
+          type: 'object',
+          required: ['pattern'],
+          properties: {
+            pattern: { type: 'string' },
+            path: { type: 'string' },
+            flags: { type: 'string' },
+          },
+        },
+      },
+      handler: proxy(v1, 'POST', '/grep'),
+    });
+
+    v1.post('/search/semantic', {
+      schema: {
+        summary: 'Semantic search in default sink',
+        operationId: 'semanticSearch',
+        tags: ['Search'],
+        body: {
+          type: 'object',
+          required: ['q'],
+          properties: {
+            q: { type: 'string' },
+            n: { type: 'integer', default: 10 },
+            where: { type: 'object' },
+          },
+        },
+      },
+      handler: proxy(v1, 'POST', '/search'),
+    });
+
+    // -----------------------
+    // Sinks (example you asked for)
+    // -----------------------
+    v1.post('/sinks/:name/search', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => req.params.name)],
+      schema: {
+        summary: 'Semantic search in sink (Chroma)',
+        operationId: 'searchSink',
+        tags: ['Sinks'],
+        params: {
+          type: 'object',
+          required: ['name'],
+          properties: { name: { type: 'string' } },
+        },
+        body: {
+          type: 'object',
+          required: ['q'],
+          properties: {
+            q: { type: 'string' },
+            n: { type: 'integer', default: 10 },
+            where: { type: 'object' },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              results: { type: 'array', items: { type: 'object' } },
+            },
+          },
+        },
+      },
+      async handler (req) {
+        const { name } = req.params;
+        const { q, n, where } = req.body || {};
+        const sink = dualSinkRegistry.get(name);
+        const results = await sink.searchChroma(q, n || 10, where || {});
+        return { results };
+      },
+    });
+
+    // (Continue converting your other endpoints the same way: add schema, use proxy or real handlers)
+  });
+}
```

---


### Patch: add `/indexer` and `/agents/:id` routes with schemas

```diff
diff --git a/services/ts/smartgpt-bridge/src/routes/v1.js b/services/ts/smartgpt-bridge/src/routes/v1.js
@@
     // -----------------------
     // Search
     // -----------------------
@@
     });
 
+    // -----------------------
+    // Indexer
+    // -----------------------
+    v1.get('/indexer', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', () => 'indexer')],
+      schema: {
+        summary: 'Get indexer status',
+        operationId: 'getIndexerStatus',
+        tags: ['Indexer'],
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              status: { type: 'string' },
+              lastIndexedAt: { type: 'string', format: 'date-time', nullable: true },
+              stats: { type: 'object', additionalProperties: true, nullable: true },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', '/indexer/status'),
+    });
+
+    v1.post('/indexer', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', () => 'indexer')],
+      schema: {
+        summary: 'Control indexer',
+        operationId: 'controlIndexer',
+        tags: ['Indexer'],
+        body: {
+          type: 'object',
+          required: ['op'],
+          properties: {
+            op: {
+              type: 'string',
+              enum: ['index', 'remove', 'reset', 'reindex'],
+              description: 'Indexer operation to perform',
+            },
+            path: { type: 'string', description: 'Optional path for index/remove/reindex' },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              message: { type: 'string', nullable: true },
+            },
+          },
+          400: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              error: { type: 'string' },
+            },
+          },
+        },
+      },
+      async handler (req, reply) {
+        const { op, path } = req.body || {};
+        let url;
+        if (op === 'index') url = '/indexer/index';
+        else if (op === 'remove') url = '/indexer/remove';
+        else if (op === 'reset') url = '/indexer/reset';
+        else if (op === 'reindex') url = path ? '/files/reindex' : '/reindex';
+        else return reply.code(400).send({ ok: false, error: 'invalid op' });
+        const payload = path ? { path } : {};
+        const res = await v1.inject({ method: 'POST', url, payload, headers: req.headers });
+        reply.code(res.statusCode);
+        for (const [k, v] of Object.entries(res.headers)) reply.header(k, v);
+        try { reply.send(res.json()); } catch { reply.send(res.payload); }
+      },
+    });
+
+    // -----------------------
+    // Agents
+    // -----------------------
+    v1.get('/agents', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', () => 'agents')],
+      schema: {
+        summary: 'List agents',
+        operationId: 'listAgents',
+        tags: ['Agents'],
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              agents: { type: 'array', items: { type: 'object' } },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', '/agent/list'),
+    });
+
+    v1.post('/agents', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', () => 'agents')],
+      schema: {
+        summary: 'Start an agent',
+        operationId: 'startAgent',
+        tags: ['Agents'],
+        body: {
+          type: 'object',
+          additionalProperties: true, // your internal /agent/start validates specifics
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              id: { type: 'string' },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'POST', '/agent/start'),
+    });
+
+    v1.get('/agents/:id', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Get agent status',
+        operationId: 'getAgentStatus',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              status: { type: 'string' },
+              agent: { type: 'object' },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', (req) => `/agent/status/${req.params.id}`),
+    });
+
+    v1.get('/agents/:id/logs', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Get agent logs',
+        operationId: 'getAgentLogs',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        querystring: {
+          type: 'object',
+          properties: {
+            tail: { type: 'integer', minimum: 1, maximum: 5000, default: 500 },
+            level: { type: 'string', enum: ['debug', 'info', 'warn', 'error'], nullable: true },
+          },
+        },
+      },
+      handler: proxy(
+        v1,
+        'GET',
+        (req) => `/agent/logs?${querystring.stringify({ ...req.query, id: req.params.id })}`,
+      ),
+    });
+
+    v1.get('/agents/:id/stream', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Stream agent logs (SSE)',
+        operationId: 'streamAgentLogs',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+      },
+      async handler (req, reply) {
+        reply.redirect(307, `/agent/stream?${querystring.stringify({ id: req.params.id })}`);
+      },
+    });
+
+    v1.post('/agents/:id', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Control agent',
+        operationId: 'controlAgent',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        body: {
+          type: 'object',
+          required: ['op'],
+          properties: {
+            op: { type: 'string', enum: ['send', 'interrupt', 'resume', 'kill'] },
+            input: { type: 'string', nullable: true, description: 'Message for op=send' },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              message: { type: 'string', nullable: true },
+            },
+          },
+          400: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              error: { type: 'string' },
+            },
+          },
+        },
+      },
+      async handler (req, reply) {
+        const { op, input } = req.body || {};
+        let url;
+        if (op === 'send') url = '/agent/send';
+        else if (op === 'interrupt') url = '/agent/interrupt';
+        else if (op === 'resume') url = '/agent/resume';
+        else if (op === 'kill') url = '/agent/kill';
+        else return reply.code(400).send({ ok: false, error: 'invalid op' });
+        const res = await v1.inject({
+          method: 'POST',
+          url,
+          payload: { id: req.params.id, input },
+          headers: req.headers,
+        });
+        reply.code(res.statusCode);
+        for (const [k, v] of Object.entries(res.headers)) reply.header(k, v);
+        try { reply.send(res.json()); } catch { reply.send(res.payload); }
+      },
+    });
```

---

### Notes for your agent (so it stops “just using a JSON object”)

* In **Fastify**, you don’t mount sub‑apps the Express way; you **encapsulate a plugin** and mount it with a **prefix**. Paths inside the plugin are **clean** (no `/v1`), and Fastify handles the prefix.
* Each route must carry its own **`schema`**: `summary`, `operationId`, `tags`, and shapes for `params`, `querystring`, `body`, and `response`. That’s what powers validation **and** OpenAPI generation.
* If you need to reuse existing handlers, keep the internal endpoints as‑is and **proxy** to them via `fastify.inject` from the v1 routes (as shown). You still get a correct OpenAPI contract at `/v1/openapi.json` and docs at `/v1/docs`.

If you want me to convert any other route family next (files/admin/sinks with full response schemas), say the word and I’ll add those blocks too.
Awesome — here are concrete, schema‑first v1 endpoints for **/indexer** and **/agents/\:id** you can drop straight into your `routes/v1.js` plugin (the one mounted with `{ prefix: '/v1' }`). They follow the same proxy pattern, but every route has a full `schema` block so Swagger/OpenAPI is generated automatically.

---

### Patch: add `/indexer` and `/agents/:id` routes with schemas

```diff
diff --git a/services/ts/smartgpt-bridge/src/routes/v1.js b/services/ts/smartgpt-bridge/src/routes/v1.js
@@
     // -----------------------
     // Search
     // -----------------------
@@
     });
 
+    // -----------------------
+    // Indexer
+    // -----------------------
+    v1.get('/indexer', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', () => 'indexer')],
+      schema: {
+        summary: 'Get indexer status',
+        operationId: 'getIndexerStatus',
+        tags: ['Indexer'],
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              status: { type: 'string' },
+              lastIndexedAt: { type: 'string', format: 'date-time', nullable: true },
+              stats: { type: 'object', additionalProperties: true, nullable: true },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', '/indexer/status'),
+    });
+
+    v1.post('/indexer', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', () => 'indexer')],
+      schema: {
+        summary: 'Control indexer',
+        operationId: 'controlIndexer',
+        tags: ['Indexer'],
+        body: {
+          type: 'object',
+          required: ['op'],
+          properties: {
+            op: {
+              type: 'string',
+              enum: ['index', 'remove', 'reset', 'reindex'],
+              description: 'Indexer operation to perform',
+            },
+            path: { type: 'string', description: 'Optional path for index/remove/reindex' },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              message: { type: 'string', nullable: true },
+            },
+          },
+          400: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              error: { type: 'string' },
+            },
+          },
+        },
+      },
+      async handler (req, reply) {
+        const { op, path } = req.body || {};
+        let url;
+        if (op === 'index') url = '/indexer/index';
+        else if (op === 'remove') url = '/indexer/remove';
+        else if (op === 'reset') url = '/indexer/reset';
+        else if (op === 'reindex') url = path ? '/files/reindex' : '/reindex';
+        else return reply.code(400).send({ ok: false, error: 'invalid op' });
+        const payload = path ? { path } : {};
+        const res = await v1.inject({ method: 'POST', url, payload, headers: req.headers });
+        reply.code(res.statusCode);
+        for (const [k, v] of Object.entries(res.headers)) reply.header(k, v);
+        try { reply.send(res.json()); } catch { reply.send(res.payload); }
+      },
+    });
+
+    // -----------------------
+    // Agents
+    // -----------------------
+    v1.get('/agents', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', () => 'agents')],
+      schema: {
+        summary: 'List agents',
+        operationId: 'listAgents',
+        tags: ['Agents'],
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              agents: { type: 'array', items: { type: 'object' } },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', '/agent/list'),
+    });
+
+    v1.post('/agents', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', () => 'agents')],
+      schema: {
+        summary: 'Start an agent',
+        operationId: 'startAgent',
+        tags: ['Agents'],
+        body: {
+          type: 'object',
+          additionalProperties: true, // your internal /agent/start validates specifics
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              id: { type: 'string' },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'POST', '/agent/start'),
+    });
+
+    v1.get('/agents/:id', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Get agent status',
+        operationId: 'getAgentStatus',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              status: { type: 'string' },
+              agent: { type: 'object' },
+            },
+          },
+        },
+      },
+      handler: proxy(v1, 'GET', (req) => `/agent/status/${req.params.id}`),
+    });
+
+    v1.get('/agents/:id/logs', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Get agent logs',
+        operationId: 'getAgentLogs',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        querystring: {
+          type: 'object',
+          properties: {
+            tail: { type: 'integer', minimum: 1, maximum: 5000, default: 500 },
+            level: { type: 'string', enum: ['debug', 'info', 'warn', 'error'], nullable: true },
+          },
+        },
+      },
+      handler: proxy(
+        v1,
+        'GET',
+        (req) => `/agent/logs?${querystring.stringify({ ...req.query, id: req.params.id })}`,
+      ),
+    });
+
+    v1.get('/agents/:id/stream', {
+      preHandler: [v1.authUser, v1.requirePolicy('read', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Stream agent logs (SSE)',
+        operationId: 'streamAgentLogs',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+      },
+      async handler (req, reply) {
+        reply.redirect(307, `/agent/stream?${querystring.stringify({ id: req.params.id })}`);
+      },
+    });
+
+    v1.post('/agents/:id', {
+      preHandler: [v1.authUser, v1.requirePolicy('write', (req) => `agent:${req.params.id}`)],
+      schema: {
+        summary: 'Control agent',
+        operationId: 'controlAgent',
+        tags: ['Agents'],
+        params: {
+          type: 'object',
+          required: ['id'],
+          properties: { id: { type: 'string' } },
+        },
+        body: {
+          type: 'object',
+          required: ['op'],
+          properties: {
+            op: { type: 'string', enum: ['send', 'interrupt', 'resume', 'kill'] },
+            input: { type: 'string', nullable: true, description: 'Message for op=send' },
+          },
+        },
+        response: {
+          200: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              message: { type: 'string', nullable: true },
+            },
+          },
+          400: {
+            type: 'object',
+            properties: {
+              ok: { type: 'boolean' },
+              error: { type: 'string' },
+            },
+          },
+        },
+      },
+      async handler (req, reply) {
+        const { op, input } = req.body || {};
+        let url;
+        if (op === 'send') url = '/agent/send';
+        else if (op === 'interrupt') url = '/agent/interrupt';
+        else if (op === 'resume') url = '/agent/resume';
+        else if (op === 'kill') url = '/agent/kill';
+        else return reply.code(400).send({ ok: false, error: 'invalid op' });
+        const res = await v1.inject({
+          method: 'POST',
+          url,
+          payload: { id: req.params.id, input },
+          headers: req.headers,
+        });
+        reply.code(res.statusCode);
+        for (const [k, v] of Object.entries(res.headers)) reply.header(k, v);
+        try { reply.send(res.json()); } catch { reply.send(res.payload); }
+      },
+    });
```

---

* In **Fastify**, you don’t mount sub‑apps the Express way; you **encapsulate a plugin** and mount it with a **prefix**. Paths inside the plugin are **clean** (no `/v1`), and Fastify handles the prefix.
* Each route must carry its own **`schema`**: `summary`, `operationId`, `tags`, and shapes for `params`, `querystring`, `body`, and `response`. That’s what powers validation **and** OpenAPI generation.
* If you need to reuse existing handlers, keep the internal endpoints as‑is and **proxy** to them via `fastify.inject` from the v1 routes (as shown). You still get a correct OpenAPI contract at `/v1/openapi.json` and docs at `/v1/docs`.

---

### 3) Remove the hand‑written `openapi.v1.json`

You don’t need to maintain a static spec anymore—the route `schema`s + the v1‑scoped Swagger produce `/v1/openapi.json` automatically.

```diff
diff --git a/services/ts/smartgpt-bridge/src/openapi.v1.json b/services/ts/smartgpt-bridge/src/openapi.v1.json
deleted file mode 100644
```

---

## Why this is the “Fastify way”

* **Encapsulation**: Everything registered inside the plugin is isolated. Auth hooks, decorators, and Swagger registered in the v1 plugin only see v1 routes.
* **Prefix**: You define paths like `/files` in code; Fastify exposes them at `/v1/files` thanks to the `prefix`.
* **Schema‑first**: Fastify’s `schema` is the single source of truth for validation, docs, and types. No more “giant JSON object” to drift from reality.
* **Swagger per-scope**: Registering `@fastify/swagger` inside the v1 plugin gives you `/v1/openapi.json` and `/v1/docs` for only v1.

---


---

## Migration checklist

1. For each existing v1 route:

   * Move it under the v1 plugin (no `/v1` in the path).
   * Add `schema.summary`, `operationId`, `tags`.
   * Add `params`, `querystring`, `body`, and `response` schemas as applicable.
   * Keep your `preHandler` like `authUser`/`requirePolicy`.

2. Delete the static `openapi.v1.json`.

3. Ensure tests hit `/v1/openapi.json` (now dynamic) and `/v1/docs`.

   * Your existing “≤30 ops” test can stay; because Swagger is v1‑scoped, it only counts v1 routes.


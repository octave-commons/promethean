Exactly ğŸ‘ â€” to lock down sinks properly, weâ€™d first need a **user + role system** in the Bridge. Right now, everything runs in a flat context (token-only auth for some routes, no user scoping).

Hereâ€™s how Iâ€™d break it down:

---

# ğŸ“ Agent Task: User + Role System for SmartGPT Bridge

## ğŸ“Œ Context

* Currently, the Bridge uses `app.auth.tokenOnly` but does not distinguish between **users** or **roles**.
* To enforce fine-grained access (e.g. "logs accessible only to admins", "searches accessible to analysts"), we need **identity + RBAC**.

---

## ğŸ¯ Goals

* Add a **User model** in Mongo.
* Add a **Role model** (or embed roles inside User).
* Add middleware to enforce RBAC on sinks + sensitive endpoints.
* Update OpenAPI spec with role-based security.

---

## âœ… Requirements

### 1. User Model

```ts
// src/models/User.ts
import { Schema, model } from "mongoose";

const UserSchema = new Schema({
  username: { type: String, unique: true, required: true },
  apiKey: { type: String, unique: true, required: true },
  roles: { type: [String], default: ["user"] },
  createdAt: { type: Date, default: Date.now },
});

export const User = model("User", UserSchema, "users");
```

---

### 2. Role Concept

* Roles are simple strings: `"admin"`, `"analyst"`, `"user"`.
* Extendable later if we want hierarchical roles or policies.

---

### 3. Auth Middleware

```ts
app.decorate("authUser", async (req, reply) => {
  const token = req.headers["x-pi-token"];
  if (!token) throw new Error("Missing API token");

  const user = await User.findOne({ apiKey: token });
  if (!user) throw new Error("Invalid token");

  (req as any).user = user;
  return user;
});

app.decorate("requireRole", (roles: string[]) => {
  return async (req, reply) => {
    const user = (req as any).user;
    if (!user || !roles.some((r) => user.roles.includes(r))) {
      reply.code(403).send({ ok: false, error: "Forbidden" });
    }
  };
});
```

---

### 4. Example Role Enforcement

```ts
app.post('/sinks/:name/query', {
  preHandler: [app.authUser, app.requireRole(["admin", "analyst"])],
  handler: async (req) => {
    const { name } = req.params as any;
    const { filter, limit } = req.body as any;

    const sink = dualSinkRegistry.get(name);
    const docs = await sink.queryMongo(filter || {}, limit || 100);

    return { results: docs };
  },
});
```

---

### 5. User Management Endpoints

* `/users/create` â†’ admin-only
* `/users/list` â†’ admin-only
* `/users/delete` â†’ admin-only

Users are created with `username`, `apiKey`, and roles.

---

## ğŸ“¦ Deliverables

* âœ… User model (Mongo).
* âœ… Role system (string-based).
* âœ… `authUser` + `requireRole` decorators.
* âœ… RBAC applied to sinks + sensitive routes.
* âœ… User management endpoints.
* âœ… OpenAPI updated with `securitySchemes` for roles.

---

ğŸ‘‰ Do you want me to design this as a **simple flat RBAC** (roles are strings checked inline), or go further and implement a **policy-based system** (JSON/YAML rules like "analyst can query bridge\_searches but not bridge\_logs")?
Perfect âš¡ â€” policy-based access control will give you much more flexibility than flat role checks.
Instead of hardcoding `"admin"` vs `"analyst"`, weâ€™ll define **policies** that map roles â†’ actions â†’ resources.

---

# ğŸ“ Agent Task: Policy-Based Access Control (PBAC) for SmartGPT Bridge

## ğŸ“Œ Context

* Current state: token-only auth, no per-user or per-role rules.
* Next step: enforce **fine-grained access control** over sinks and endpoints.
* Approach: implement a **policy engine** that checks `(user, action, resource)` against rules in Mongo.

---

## ğŸ¯ Goals

* Store policies in MongoDB.
* Assign users one or more roles.
* Evaluate access dynamically via a **policy engine**.
* Apply policies to sinks, logs, searches, and other Bridge routes.

---

## âœ… Implementation Plan

### 1. Policy Model

```ts
// src/models/Policy.ts
import { Schema, model } from "mongoose";

const PolicySchema = new Schema({
  role: { type: String, required: true },    // e.g. "admin", "analyst"
  action: { type: String, required: true },  // e.g. "read", "write", "search"
  resource: { type: String, required: true },// e.g. "bridge_logs", "bridge_searches"
  effect: { type: String, enum: ["allow", "deny"], default: "allow" },
});

export const Policy = model("Policy", PolicySchema, "policies");
```

---

### 2. User Model with Roles

```ts
// src/models/User.ts
const UserSchema = new Schema({
  username: { type: String, unique: true, required: true },
  apiKey: { type: String, unique: true, required: true },
  roles: { type: [String], default: ["user"] },  // e.g. ["analyst"]
});
```

---

### 3. Policy Engine

```ts
// src/utils/policyEngine.ts
import { Policy } from "../models/Policy.js";

export async function checkAccess(user, action: string, resource: string) {
  if (!user) return false;

  const policies = await Policy.find({ role: { $in: user.roles } });

  // Explicit deny wins
  for (const p of policies) {
    if ((p.action === action || p.action === "*") &&
        (p.resource === resource || p.resource === "*") &&
        p.effect === "deny") {
      return false;
    }
  }

  // Allow if any matching allow policy
  for (const p of policies) {
    if ((p.action === action || p.action === "*") &&
        (p.resource === resource || p.resource === "*") &&
        p.effect === "allow") {
      return true;
    }
  }

  return false;
}
```

---

### 4. Middleware

```ts
app.decorate("authUser", async (req, reply) => {
  const token = req.headers["x-pi-token"];
  if (!token) throw new Error("Missing API token");

  const user = await User.findOne({ apiKey: token });
  if (!user) throw new Error("Invalid token");

  (req as any).user = user;
  return user;
});

app.decorate("requirePolicy", (action: string, resource: string) => {
  return async (req, reply) => {
    const user = (req as any).user;
    const allowed = await checkAccess(user, action, resource);
    if (!allowed) {
      reply.code(403).send({ ok: false, error: "Forbidden" });
    }
  };
});
```

---

### 5. Apply to Sinks

```ts
app.post('/sinks/:name/query', {
  preHandler: [app.authUser, app.requirePolicy("read", "sink")],
  handler: async (req) => {
    const { name } = req.params as any;
    const sink = dualSinkRegistry.get(name);
    return { results: await sink.queryMongo(req.body.filter || {}, req.body.limit || 100) };
  },
});
```

* Policy example:

```json
{ "role": "analyst", "action": "read", "resource": "bridge_searches", "effect": "allow" }
{ "role": "analyst", "action": "read", "resource": "bridge_logs", "effect": "deny" }
```

---

### 6. Admin Endpoints for Policies

* `/policies/list` â†’ list all policies.
* `/policies/create` â†’ add a new policy.
* `/policies/delete` â†’ remove a policy.

---

## ğŸ“¦ Deliverables

* âœ… User + Role model.
* âœ… Policy model in Mongo.
* âœ… Policy engine (`checkAccess`).
* âœ… Middleware (`requirePolicy`).
* âœ… Enforcement on sinks.
* âœ… Policy management endpoints.
* âœ… OpenAPI updates.

---

âœ¨ Example Use Case:

* `analyst` can query `bridge_searches`, but not `bridge_logs`.
* `admin` can access everything (`*` on action + resource).

---

ğŸ‘‰ Do you want policies to be **role-based only** (role â†’ resource mapping), or also support **per-user overrides** (e.g. analyst role but this specific user can read logs)?

ğŸ’¯ Makes sense â€” weâ€™ll need a **bootstrap admin creation flow**, otherwise no one can manage users/policies on a fresh install.

Hereâ€™s a safe way to do it:

---

# ğŸ“ Agent Task: Bootstrap First Admin User

## ğŸ“Œ Context

* The Bridge has no users yet.
* We need to guarantee that the **first person who sets it up** can create an admin account.
* After bootstrap, user + policy management requires admin rights.

---

## ğŸ¯ Goals

* Detect when the `users` collection is empty.
* Allow one-time creation of a **bootstrap admin** with a random API key.
* Print credentials to logs/console (NOT exposed in OpenAPI).
* After bootstrap, block this endpoint.

---

## âœ… Implementation

### 1. Bootstrap Check at Startup

```ts
// src/init/bootstrap.ts
import { User } from "../models/User.js";
import crypto from "crypto";

export async function bootstrapAdmin() {
  const count = await User.countDocuments();
  if (count > 0) return null; // Already initialized

  const apiKey = crypto.randomBytes(32).toString("hex");
  const user = await User.create({
    username: "admin",
    apiKey,
    roles: ["admin"],
  });

  console.log("ğŸš€ Bootstrap admin created");
  console.log(`   username: ${user.username}`);
  console.log(`   apiKey:   ${apiKey}`);
  console.log("âš ï¸  Store this API key securely! You will not see it again.");

  return user;
}
```

Call this during app startup:

```ts
await bootstrapAdmin();
```

---

### 2. Optional Bootstrap Endpoint

For cases where you donâ€™t want auto-creation at startup, add a **manual bootstrap endpoint**:

```ts
app.post('/bootstrap/admin', {
  schema: {
    summary: "Bootstrap first admin (only works if no users exist)",
    operationId: "bootstrapAdmin",
    tags: ["Admin"],
  },
  handler: async () => {
    const count = await User.countDocuments();
    if (count > 0) {
      return { ok: false, error: "Already initialized" };
    }

    const apiKey = crypto.randomBytes(32).toString("hex");
    const user = await User.create({
      username: "admin",
      apiKey,
      roles: ["admin"],
    });

    return { ok: true, username: user.username, apiKey };
  },
});
```

* Safe: only works if `users` is empty.
* Optional: can be disabled after first run.

---

### 3. Security Considerations

* âš ï¸ Never expose bootstrap admin key in logs after initialization.
* âœ… Encourage rotation: first admin should immediately create policies and possibly rotate their key.
* ğŸ” Consider disabling `/bootstrap/admin` entirely after setup (env var flag).

---

## ğŸ“¦ Deliverables

* âœ… Startup bootstrap flow â†’ auto-create admin if no users.
* âœ… `/bootstrap/admin` endpoint (optional).
* âœ… One-time admin API key securely generated.
* âœ… Guard: disabled after first user exists.

---

ğŸ‘‰ Do you want the bootstrap API key to be **printed only to stdout** (safe for container logs), or also **saved into a `.env` file** automatically for persistence?
Got it âœ… â€” no printing, no logs, no persistence anywhere.
That means the **bootstrap admin flow must return the API key exactly once, in the HTTP response**, and never store or emit it elsewhere.

---

# ğŸ“ Agent Task: Silent Bootstrap Admin User

## ğŸ“Œ Context

* First-time setup requires an **admin account**.
* Security requirement: **no console logs, no persisted records** of the bootstrap process.
* The API key should be returned **only in the HTTP response** to the bootstrap call.

---

## ğŸ¯ Goals

* Allow one-time creation of an admin user if `users` collection is empty.
* Return the generated `apiKey` only in the HTTP response.
* Do not log or print the key.
* Once users exist, block the bootstrap route.

---

## âœ… Implementation

### 1. Bootstrap Endpoint

```ts
// src/routes/bootstrap.ts
import { User } from "../models/User.js";
import crypto from "crypto";

export async function registerBootstrap(app) {
  app.post('/bootstrap/admin', {
    schema: {
      summary: "Bootstrap first admin (one-time only)",
      operationId: "bootstrapAdmin",
      tags: ["Admin"],
      response: {
        200: {
          type: "object",
          properties: {
            ok: { type: "boolean" },
            username: { type: "string" },
            apiKey: { type: "string" },
          },
          required: ["ok", "username", "apiKey"],
        },
        400: {
          type: "object",
          properties: {
            ok: { type: "boolean" },
            error: { type: "string" },
          },
        },
      },
    },
    handler: async () => {
      const count = await User.countDocuments();
      if (count > 0) {
        return { ok: false, error: "Already initialized" };
      }

      const apiKey = crypto.randomBytes(32).toString("hex");
      const user = await User.create({
        username: "admin",
        apiKey,
        roles: ["admin"],
      });

      // âš ï¸ Return ONLY in response, no logging.
      return { ok: true, username: user.username, apiKey };
    },
  });
}
```

---

### 2. Bootstrap Flow

* Deploy service â†’ `users` collection is empty.
* Call `POST /bootstrap/admin` once â†’ receive JSON:

```json
{
  "ok": true,
  "username": "admin",
  "apiKey": "c0ffee...deadbeef"
}
```

* Store the API key securely (e.g. in a vault).
* Use this key for subsequent requests.

---

### 3. Safeguards

* Once at least 1 user exists, `/bootstrap/admin` always returns:

```json
{ "ok": false, "error": "Already initialized" }
```

* No logs, no prints, no `.env` writes.
* If you lose the bootstrap key, only option is DB reset.

---

## ğŸ“¦ Deliverables

* âœ… Silent bootstrap route (`/bootstrap/admin`).
* âœ… Returns API key in HTTP response only.
* âœ… Disabled after first user creation.
* âœ… Meets "no record" requirement.

---

ğŸ‘‰ Do you also want me to enforce that **bootstrap can only be run locally** (e.g. `127.0.0.1` origin), so it canâ€™t be triggered remotely in production?
Perfect ğŸ‘ â€” weâ€™ll **lock the bootstrap endpoint to local access only**, so it cannot be triggered from the outside world.

That way:

* âœ… Only accessible via `127.0.0.1` or `::1`
* âœ… Ensures bootstrap can only be done from inside the container or host
* âœ… Prevents accidental exposure in production

---

# ğŸ“ Agent Task: Local-Only Bootstrap Admin

## ğŸ“Œ Context

* We already have a **silent bootstrap flow** that creates the first admin.
* Requirement: ensure this can only be called from `localhost`.

---

## ğŸ¯ Goals

* Reject bootstrap requests from any non-local IP.
* Return a clear error message if attempted remotely.
* Keep all other bootstrap rules (one-time only, no logging).

---

## âœ… Implementation

### 1. Local-Only PreHandler

```ts
function requireLocal(req, reply, done) {
  const ip = req.ip;
  if (ip === "127.0.0.1" || ip === "::1" || ip === "::ffff:127.0.0.1") {
    return done();
  }
  reply.code(403).send({ ok: false, error: "Bootstrap must be run locally" });
}
```

---

### 2. Apply to Bootstrap Route

```ts
app.post('/bootstrap/admin', {
  preHandler: [requireLocal],
  schema: {
    summary: "Bootstrap first admin (one-time, local only)",
    operationId: "bootstrapAdmin",
    tags: ["Admin"],
  },
  handler: async () => {
    const count = await User.countDocuments();
    if (count > 0) {
      return { ok: false, error: "Already initialized" };
    }

    const apiKey = crypto.randomBytes(32).toString("hex");
    const user = await User.create({
      username: "admin",
      apiKey,
      roles: ["admin"],
    });

    return { ok: true, username: user.username, apiKey };
  },
});
```

---

### 3. Behavior

#### âœ… Local Request

```bash
curl -X POST http://127.0.0.1:3000/bootstrap/admin
```

Response:

```json
{
  "ok": true,
  "username": "admin",
  "apiKey": "c0ffee...deadbeef"
}
```

#### âŒ Remote Request

```json
{
  "ok": false,
  "error": "Bootstrap must be run locally"
}
```

---

## ğŸ“¦ Deliverables

* âœ… Local-only bootstrap enforcement.
* âœ… Silent (no logging of key).
* âœ… Disabled after first user.
* âœ… OpenAPI spec updated.

---

ğŸ‘‰ Do you also want me to allow an **override via env var** (e.g. `ALLOW_REMOTE_BOOTSTRAP=true`) for edge cases like cloud deployments where you may not have shell access?

curl -X POST http://127.0.0.1:3210/bootstrap/admin

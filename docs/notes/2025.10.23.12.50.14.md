@codex
The `ContextStore` and `DualStoreManager` should continue to accept the same arguments as before.
The original implementation is known to work as we begin refactoring classes with mutable state
across the project. This work will serve as an example of how to perform similar migrations in the future

## Requirements

- The original implementations are restored from `main`
- comprehensive unit tests exist for the original implementations of these classes
- The callees have integration tests on paths that call either class
- A pure idempotent functional interface that perform the same roles as the original classes exist
- There are factory functions that implement the same interface as the original implementations
- The files containing the original implementations export classes that wrap the functional implementation.
- both classes to be a thin wrappers around
- both classes to emit depreciation warnings when used.
- The new functional wrapper class passes the same tests as the original implementation

## Tasks
- [ ] restore the implementation of both `DualStoreManager` and `ContextStore` to the version currently on the `main` branch
- [ ] Write comprehensive unit tests are written for both classes
- [ ] Write integration tests for dependent packages around code pathways which depend on these classes.
- [ ] Rewrite the classes be thin wrappers around pure idempotent functions with the same type signatures.
- [ ] write a factory function that creates an object that matches the type signature of both classes

## Definition of done

- [ ] 90% unit tests coverage on the original implementations is reached before any other work is done
- [ ] [Stryker Mutator bb]
- [ ] Integration tests exist for dependent packages and pass.
- [ ] There exists a pure functional interface of actions in a [[src/actions/{dual-store-manager, context-store}|packages/persistence]]
      meeting the following criteria:
  - [ ] They execute the behaviors of each method of the original implementation
  - [ ] The functions are curried
  - [ ] The functions accept a state object as their first arguement
  - [ ] the state object contains properties which match the original implementations
- [ ] There is a class with the same name as the original classes which uses the functional actions
- [ ] Unit tests are written for the actions

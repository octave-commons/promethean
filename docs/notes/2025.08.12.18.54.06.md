I'm going to try to be as comprehensive of my current system as possible,
if something seems to be missing,
let me know I will try to figure it out.

## Key Services

There are a few services involved in the existing flow.

- `cephalon` (Brains of the app, is currently handling the storage and embedding of transcripts, and a bunch of other stuf....)
- `discord-embedder` (this one goes through all text messages the bot has access to from the beginning of time, and embeds them)
- `embeddings_provider` (This one is a python service that generates the embeddings using a requestable driver, ollama, transformers, simple)

## Code


### Embedder

Core logic:

```typescript
//services/ts/dicosrd-embedder/src/index.ts
import { ChromaClient } from 'chromadb';
import { RemoteEmbeddingFunction } from './embedding';
import { MongoClient, ObjectId, Collection } from 'mongodb';
import { AGENT_NAME } from '../../../../shared/js/env.js';
import { HeartbeatClient } from '../../../../shared/js/heartbeat/index.js';

const chromaClient = new ChromaClient();

type MessageMetaData = {
	timeStamp: number;
	userName: string;
};

type ChromaQuery = {
	ids: string[];
	documents: string[];
	metadatas: MessageMetaData[];
};

type DiscordMessage = {
	_id: ObjectId;
	id?: number;
	recipient: number;
	startTime?: number;
	endTime?: number;

	created_at: number;
	author: number;
	channel: number;
	channel_name: string;
	author_name: string;
	content: string | null;
	is_embedded?: boolean;
};

const MONGO_CONNECTION_STRING = process.env.MONGODB_URI || `mongodb://localhost`;

(async () => {
	const hb = new HeartbeatClient();
	try {
		await hb.sendOnce();
	} catch (err) {
		console.error('failed to register heartbeat', err);
		process.exit(1);
	}
	hb.start();
	const mongoClient = new MongoClient(MONGO_CONNECTION_STRING);
	try {
		await mongoClient.connect();
		console.log('MongoDB connected successfully');
	} catch (error) {
		console.error('Error connecting to MongoDB:', error);
		return;
	}

	const db = mongoClient.db('database');
	const collectionName = `${AGENT_NAME}_discord_messages`;
	const discordMessagesCollection: Collection<DiscordMessage> = db.collection(collectionName);

	const chromaCollection = await chromaClient.getOrCreateCollection({
		name: collectionName,
		embeddingFunction: new RemoteEmbeddingFunction(),
	});

	while (true) {
		await new Promise((res) => setTimeout(res, 1000));
		const messages = (await discordMessagesCollection
			.find({
				has_meta_data: { $exists: false },
				content: { $ne: null },
			})
			.limit(100)
			.toArray()) as Array<Omit<DiscordMessage, 'content'> & { content: string }>;

		if (messages.length === 0) {
			console.log('No new messages, sleeping 1 minute');
			await new Promise((res) => setTimeout(res, 60000));
			continue;
		}

		console.log('embedding', messages.length, 'messages and transcripts');

		const chromaQuery: ChromaQuery = {
			ids: messages.map((msg) => msg._id.toHexString()),
			documents: messages.map((msg) => msg.content),
			metadatas: messages.map((msg) => ({
				timeStamp: msg?.startTime || msg.created_at,
				userName: msg.author_name,
			})),
		};

		await chromaCollection.upsert(chromaQuery);
		// Mark these messages as embedded
		const messageIds = messages.map((msg) => msg._id);
		await discordMessagesCollection.updateMany(
			{ _id: { $in: messageIds } },
			{
				$set: {
					is_embedded: true,
					embedding_has_time_stamp: true,
					has_meta_data: true,
				},
			},
		);
	}
})();
```

embedding function:

```typescript
//services/ts/dicosrd-embedder/src/embedder.ts
import type { EmbeddingFunction, EmbeddingFunctionSpace } from 'chromadb';
// @ts-ignore import js module without types
import { BrokerClient } from '../../../../../shared/js/brokerClient.js';
import { randomUUID } from 'crypto';

export class RemoteEmbeddingFunction implements EmbeddingFunction {
	name = 'remote';
	driver: string | undefined;
	fn: string | undefined;
	broker: BrokerClient;
	#ready: Promise<void>;
	#pending: ((embeddings: number[][]) => void)[] = [];
	#replyId: string;

	constructor(
		brokerUrl = process.env.BROKER_URL || 'ws://localhost:7000',
		driver = process.env.EMBEDDING_DRIVER,
		fn = process.env.EMBEDDING_FUNCTION,
		broker?: BrokerClient,
	) {
		this.driver = driver;
		this.fn = fn;
		this.#replyId = randomUUID();
		this.broker =
			broker ||
			new BrokerClient({
				url: brokerUrl,
				id: `discord-embed-${this.#replyId}`,
			});
		this.#ready = this.broker
			.connect()
			.then(() => {
				this.broker.subscribe('embedding.result', (event: any) => {
					if (event.replyTo !== this.#replyId) return;
					const resolve = this.#pending.shift();
					if (resolve) {
						resolve(event.payload.embeddings);
					}
				});
			})
			.catch((err: unknown) => {
				console.error('Failed to connect to broker', err);
			});
	}

	async generate(texts: string[]): Promise<number[][]> {
		const items = texts.map((t) =>
			t.startsWith('img:') ? { type: 'image_url', data: t.slice(4) } : { type: 'text', data: t },
		);
		await this.#ready;
		return new Promise((resolve) => {
			this.#pending.push(resolve);
			this.broker.enqueue('embedding.generate', {
				items,
				driver: this.driver,
				function: this.fn,
				replyTo: this.#replyId,
			});
		});
	}

	defaultSpace(): EmbeddingFunctionSpace {
		return 'l2';
	}
	supportedSpaces(): EmbeddingFunctionSpace[] {
		return ['l2', 'cosine'];
	}
	static buildFromConfig(): RemoteEmbeddingFunction {
		return new RemoteEmbeddingFunction();
	}
	getConfig() {
		return {};
	}
}
```


## cephalon

The collection manager is used to grab indexes based on time (through mongo) and similarity (chroma)
```typescript

import { Collection as ChromaCollection, ChromaClient } from 'chromadb';
import { RemoteEmbeddingFunction } from './embedding';
import { Collection, MongoClient, ObjectId, OptionalUnlessRequiredId, WithId } from 'mongodb';
import { AGENT_NAME } from '../../../../shared/js/env.js';
const chromaClient = new ChromaClient();
const mongoClient = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017');
import crypto from 'crypto';
export type DiscordEntry = CollectionEntry<'content', 'created_at'>;
export type ThoughtEntry = CollectionEntry<'text', 'createdAt'>;

export type CollectionEntry<TextKey extends string = 'text', TimeKey extends string = 'createdAt'> = {
	_id?: ObjectId; // MongoDB internal ID
	id?: string;
	metadata?: any;
} & {
	[K in TextKey]: string;
} & {
	[K in TimeKey]: number;
};
export type CollectionQueryResult = {
	ids: string[];
	documents: string[];
	metadatas: any[];
	distances?: number[];
};
export class CollectionManager<TextKey extends string = 'text', TimeKey extends string = 'createdAt'> {
	name: string;
	chromaCollection: ChromaCollection;
	mongoCollection: Collection<CollectionEntry<TextKey, TimeKey>>;
	textKey: TextKey;
	timeStampKey: TimeKey;

	constructor(
		name: string,
		chromaCollection: ChromaCollection,
		mongoCollection: Collection<CollectionEntry<TextKey, TimeKey>>,
		textKey: TextKey,
		timeStampKey: TimeKey,
	) {
		this.name = name;
		this.chromaCollection = chromaCollection;
		this.mongoCollection = mongoCollection;
		this.textKey = textKey;
		this.timeStampKey = timeStampKey;
	}

	static async create<TTextKey extends string = 'text', TTimeKey extends string = 'createdAt'>(
		name: string,
		textKey: TTextKey,
		timeStampKey: TTimeKey,
	) {
		const collectionName = `${AGENT_NAME}_${name}`;
		const chromaCollection = await chromaClient.getOrCreateCollection({
			name: collectionName,
			embeddingFunction: new RemoteEmbeddingFunction(),
		});
		const db = mongoClient.db('database');
		const mongoCollection = db.collection<CollectionEntry<TTextKey, TTimeKey>>(collectionName);
		return new CollectionManager(collectionName, chromaCollection, mongoCollection, textKey, timeStampKey);
	}

	// AddEntry method:
	async addEntry(entry: CollectionEntry<TextKey, TimeKey>) {
		if (!entry.id) {
			entry.id = crypto.randomUUID();
		}

		if (!entry[this.timeStampKey]) {
			entry[this.timeStampKey] = Date.now() as CollectionEntry<TextKey, TimeKey>[TimeKey];
		}

		if (!entry.metadata) entry.metadata = {};
		entry.metadata[this.timeStampKey] = entry[this.timeStampKey];

		// console.log("Adding entry to collection", this.name, entry);

		await this.chromaCollection.add({
			ids: [entry.id],
			documents: [entry[this.textKey]],
			metadatas: [entry.metadata],
		});

		await this.mongoCollection.insertOne({
			id: entry.id,
			[this.textKey]: entry[this.textKey],
			[this.timeStampKey]: entry[this.timeStampKey],
			metadata: entry.metadata,
		} as OptionalUnlessRequiredId<CollectionEntry<TextKey, TimeKey>>);
	}

	async getMostRecent(
		limit: number = 10,
		mongoFilter: any = {},
		sorter: any = { [this.timeStampKey]: -1 },
	): Promise<CollectionEntry<'text', 'timestamp'>[]> {
		// console.log("Getting most recent entries from collection", this.name, "with limit", limit);
		return (await this.mongoCollection.find(mongoFilter).sort(sorter).limit(limit).toArray()).map(
			(entry: WithId<CollectionEntry<TextKey, TimeKey>>) => ({
				id: entry.id,
				text: (entry as Record<TextKey, any>)[this.textKey],
				timestamp: new Date((entry as Record<TimeKey, any>)[this.timeStampKey]).getTime(),
				metadata: entry.metadata,
			}),
		) as CollectionEntry<'text', 'timestamp'>[];
	}
	async getMostRelevant(queryTexts: string[], limit: number): Promise<CollectionEntry<'text', 'timestamp'>[]> {
		// console.log("Getting most relevant entries from collection", this.name, "for queries", queryTexts, "with limit", limit);
		if (!queryTexts || queryTexts.length === 0) return Promise.resolve([]);

		const queryResult = await this.chromaCollection.query({
			queryTexts,
			nResults: limit,
		});
		const uniqueThoughts = new Set();
		const ids = queryResult.ids.flat(2);
		const meta = queryResult.metadatas.flat(2);
		return queryResult.documents
			.flat(2)
			.map((doc, i) => ({
				id: ids[i],
				text: doc,
				metadata: meta[i],
				timestamp: meta[i]?.timeStamp || meta[i]?.[this.timeStampKey] || Date.now(),
			}))
			.filter((doc) => {
				if (!doc.text) return false; // filter out undefined text
				if (uniqueThoughts.has(doc.text)) return false; // filter out duplicates
				uniqueThoughts.add(doc.text);
				return true;
			}) as CollectionEntry<'text', 'timestamp'>[];
	}
}
```

The context manager uses multiple pairs of chroma/mongodb databases to execute queries, aggregates and sorts by recency:
```typescript
import { Message } from 'ollama';
import { CollectionEntry, CollectionManager } from './collectionManager';

import TimeAgo from 'javascript-time-ago';
import en from 'javascript-time-ago/locale/en';
TimeAgo.addDefaultLocale(en);
const timeAgo = new TimeAgo('en-US');
export const formatMessage = (m: CollectionEntry<'text', 'timestamp'>): string =>
	`${m.metadata?.userName === 'Duck' ? 'You' : m.metadata.userName} ${
		m.metadata.isThought ? 'thought' : 'said'
	} (${timeAgo.format(new Date(m.timestamp).getTime())}): ${m.text}`;

export type GenericEntry = CollectionEntry<'text', 'timestamp'>;

export class ContextManager {
	collections: Map<string, CollectionManager<string, string>>;
	constructor() {
		this.collections = new Map();
	}
	async createCollection(
		name: string,
		textKey: string,
		timeStampKey: string,
	): Promise<CollectionManager<string, string>> {
		if (this.collections.has(name)) {
			throw new Error(`Collection ${name} already exists`);
		}
		const collectionManager = await CollectionManager.create<string, string>(name, textKey, timeStampKey);
		this.collections.set(name, collectionManager);
		return collectionManager;
	}
	async getAllRelatedDocuments(querys: string[], limit: number = 100): Promise<CollectionEntry<'text', 'timestamp'>[]> {
		console.log('Getting related documents for querys:', querys.length, 'with limit:', limit);
		const results = [];
		for (const collection of this.collections.values()) {
			results.push(await collection.getMostRelevant(querys, limit));
		}
		return results.flat();
	}
	async getLatestDocuments(limit: number = 100): Promise<CollectionEntry<'text', 'timestamp'>[]> {
		const result = [];
		for (const collection of this.collections.values()) {
			result.push(await collection.getMostRecent(limit));
		}
		console.log('Getting latest documents from collections:', this.collections.size);
		return result.flat();
	}
	getCollection(name: string): CollectionManager<string, string> {
		if (!this.collections.has(name)) throw new Error(`Collection ${name} does not exist`);
		console.log('Getting collection:', name);
		return this.collections.get(name) as CollectionManager<string, string>;
	}
	async compileContext(
		texts: string[] = [],
		recentLimit: number = 10, // how many recent documents to include
		queryLimit: number = 5, // how many of the recent documents to use in the query
		limit: number = 20, // how many documents to return in total
		formatAssistantMessages = false,
	): Promise<Message[]> {
		console.log('Compiling context with texts:', texts.length, 'and limit:', limit);
		const latest = await this.getLatestDocuments(recentLimit);
		const query = [...texts, ...latest.map((doc) => doc.text)].slice(-queryLimit);
		const related = await this.getAllRelatedDocuments(query, limit);
		const uniqueThoughts = new Set<string>();
		return Promise.all([related, latest]).then(([relatedDocs, latestDocs]) => {
			let results = [...relatedDocs, ...latestDocs]
				.filter((doc) => {
					if (!doc.text) return false; // filter out undefined text
					if (uniqueThoughts.has(doc.text)) return false; // filter out duplicates
					if (!doc.metadata) return false;
					uniqueThoughts.add(doc.text);
					return true;
				})
				.sort((a: GenericEntry, b: GenericEntry) => new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime());
			console.log("You won't believe this but... the results are this long:", results.length);
			console.log('The limit was', limit);
			if (results.length > limit * this.collections.size * 2) {
				results = results.slice(-(limit * this.collections.size * 2));
			}

			// for(let r of results) {
			//     console.log(r)
			// }

			return results.map((m: CollectionEntry<'text', 'timestamp'>) => ({
				role: m.metadata?.userName === 'Duck' ? (m.metadata?.isThought ? 'system' : 'assistant') : 'user',
				content:
					m.metadata?.userName === 'Duck' ? (formatAssistantMessages ? formatMessage(m) : m.text) : formatMessage(m),
			}));
		});
	}
}
```
The start function initiates 3 collections through the context manager:
```typescript
async start () {

		await this.context.createCollection('transcripts', 'text', 'createdAt');
		await this.context.createCollection(`${AGENT_NAME}_discord_messages`, 'content', 'created_at');
		await this.context.createCollection('agent_messages', 'text', 'createdAt');
        // everything else

}

```

The `${$AGENT_NAME}_discord_messages` is what is created by the discord embedder service.

## Embeddings provider

Both the CollectionManager cephalon object, and the discord embedder service use the same embeddings provider service.
It was seperated out to a python service because the openai codex agent had issues npm installing the dependencies
for chroma node embedding functions. Maybe we didn't have to do this thinking on it, cause we coulda just hit ollama directly.
But my thought process on this was I wanted to be able to experiment with arbitrary embedding providers, ollama, transformers, custom pytorch, etc. and I didn't want the consumer to have to think about it too much.


The main service definition:

```python
import asyncio
import os
from functools import lru_cache
from typing import List

from shared.py.service_template import start_service
from drivers import get_driver


@lru_cache(maxsize=1)
def _load(driver_name: str, function_name: str):
    driver = get_driver(driver_name)
    return driver.load(function_name)


def _embed(items, driver_name: str, function_name: str) -> List[List[float]]:
    driver = get_driver(driver_name)
    model = _load(driver_name, function_name)
    return driver.embed(items, function_name, model)


async def handle_task(task, client):
    payload = task.get("payload", {})
    driver_name = payload.get("driver") or os.environ.get("EMBEDDING_DRIVER", "naive")
    function_name = payload.get("function") or os.environ.get(
        "EMBEDDING_FUNCTION", "simple"
    )
    items = payload.get("items", [])
    embeddings = _embed(items, driver_name, function_name)
    reply_to = payload.get("replyTo") or task.get("replyTo")
    if reply_to:
        await client.publish(
            "embedding.result",
            {"embeddings": embeddings},
            replyTo=reply_to,
            correlationId=task.get("id"),
        )


async def main():
    await start_service(
        id="embedding",
        queues=["embedding.generate"],
        handle_task=handle_task,
    )
    await asyncio.Event().wait()


if __name__ == "__main__":
    asyncio.run(main())
```



our  `driver/__init__.py` 

```python

from .base import EmbeddingDriver
from .naive_driver import NaiveDriver

DRIVERS = {"naive": NaiveDriver()}

try:  # Optional: only register if dependency is available
    from .transformers_driver import TransformersDriver

    DRIVERS["transformers"] = TransformersDriver()
except Exception:  # pragma: no cover - missing heavy deps
    pass

try:
    from .ollama_driver import OllamaDriver

    DRIVERS["ollama"] = OllamaDriver()
except Exception:  # pragma: no cover
    pass


def get_driver(name: str) -> EmbeddingDriver:
    try:
        return DRIVERS[name]
    except KeyError as exc:
        raise ValueError(f"Unknown driver {name}") from exc
```

And our current driver:

```python
from functools import lru_cache
from typing import List, Any

import requests

from .base import EmbeddingDriver


class OllamaDriver(EmbeddingDriver):
    """Driver that proxies to an Ollama server."""

    def __init__(self, url: str | None = None):
        self.url = url or "http://localhost:11434/api/embeddings"

    def list_functions(self) -> List[str]:
        return ["nomic-embed-text", "all-minilm", "chroma/all-minilm-l6-v2-f32"]

    @lru_cache(maxsize=1)
    def load(self, fn: str) -> str:
        return fn

    def embed(self, items: List[dict], fn: str, model: Any) -> List[List[float]]:
        embeddings: List[List[float]] = []
        for item in items:
            item_type = item["type"] if isinstance(item, dict) else item.type
            data = item["data"] if isinstance(item, dict) else item.data
            if item_type != "text":
                raise ValueError("Ollama driver only supports text inputs")
            resp = requests.post(
                self.url,
                json={"model": model, "prompt": data},
                timeout=30,
            )
            resp.raise_for_status()
            embeddings.append(resp.json()["embedding"])
        return embeddings
```

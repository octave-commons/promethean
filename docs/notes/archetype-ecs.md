---
```
uuid: d6d8bf5b-50e1-4d8f-961d-64159c9bb5b7
```
```
created_at: archetype-ecs.md
```
```
filename: archetype-ecs
```
```
title: archetype-ecs
```
```
description: >-
```
  A lightweight, TypeScript-based ECS implementation with 64-component bitmasks,
  SoA storage, and efficient query mechanisms for real-time applications.
tags:
  - ecs
  - typescript
  - archetype
```
related_to_uuid:
```
  - 95cb7640-a903-4a2e-99c7-2d060a0fbecf
  - 96ffd77d-46ff-409d-8e59-d7e00ce7055b
  - 8f4c1e86-1236-4936-84ca-6ed7082af6b7
  - 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
  - 86ef1f2b-1b3f-4ca7-a88e-b8b52e70ac10
  - 0a8255a5-ef49-4a1e-ae71-b2f57eb7bdf8
  - bb4f4ed0-91f3-488a-9d64-3a33bde77e4e
  - 792a343e-674c-4bb4-8435-b3f8c163349d
  - f4767ec9-7363-4ca0-ad88-ccc624247a3b
  - 7ab1a3cd-80a7-4d69-ae21-1da07cd0523c
  - 4316c3f9-551f-4872-b5c5-98ae73508535
  - 8fd08696-5338-493b-bed5-507f8a6a6ea9
  - a28a39dd-8c17-463c-9050-2ffe9b56e8bc
  - 6f13f134-7536-4bc3-b695-5aaa2906bb9d
  - e4317155-7fa6-44e8-8aee-b72384581790
  - 740bbd1c-c039-405c-8a32-4baeddfb5637
  - c2ba3d27-5b24-4345-9cf2-5cf296f8b03d
  - ee4b3631-a745-485b-aff1-2da806cfadfb
  - 5becb573-0a78-486b-8d3c-199b3c7a79ec
  - 9a1076d6-1aac-497e-bac3-66c9ea09da55
  - 3657117f-241d-4ab9-a717-4a3f584071fc
  - 0e289525-1904-4f7d-9d3a-4fedc53efe9b
  - 40bc2ba7-9c5c-4f72-8f88-17bef3c6163f
  - 6b91d91d-6b5c-4516-a0c8-d66d9b9fcc9b
```
related_to_title:
```
  - Promethean State Format
  - ChatGPT Custom Prompts
  - archetype-ecs
  - Promethean Code Principles
  - promethean-pipelines
  - Functional Refactor of TypeScript Document Processing
  - chroma-embedding-refactor
  - windows-tiling-with-autohotkey
  - ecs-scheduler
  - system-scheduler
  - WebSocket Gateway Implementation
  - typed-struct-compiler
  - AI-Centric OS with MCP Layer
  - shared-package-layout-clarification
  - TypeScript Patch for Tool Calling Support
  - heartbeat-fragment-demo
  - observability-infrastructure-setup
  - Promethean Documentation Pipeline Overview
  - Agent Reflections and Prompt Evolution
  - Stateful Partitions and Rebalancing
  - language-agnostic-mirror-system
  - functional-programming-in-typescript
  - Lean AGENT Setup
  - AGENTS.md
references:
  - uuid: 8f4c1e86-1236-4936-84ca-6ed7082af6b7
    line: 7
    col: 0
    score: 1
  - uuid: 96ffd77d-46ff-409d-8e59-d7e00ce7055b
    line: 5
    col: 0
    score: 1
  - uuid: 96ffd77d-46ff-409d-8e59-d7e00ce7055b
    line: 9
    col: 0
    score: 1
  - uuid: 96ffd77d-46ff-409d-8e59-d7e00ce7055b
    line: 16
    col: 0
    score: 1
  - uuid: 8f4c1e86-1236-4936-84ca-6ed7082af6b7
    line: 445
    col: 0
    score: 0.97
  - uuid: 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
    line: 3
    col: 0
    score: 0.94
  - uuid: 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
    line: 5
    col: 0
    score: 0.92
  - uuid: 86ef1f2b-1b3f-4ca7-a88e-b8b52e70ac10
    line: 68
    col: 0
    score: 0.89
  - uuid: 0a8255a5-ef49-4a1e-ae71-b2f57eb7bdf8
    line: 1
    col: 0
    score: 0.87
  - uuid: 86ef1f2b-1b3f-4ca7-a88e-b8b52e70ac10
    line: 84
    col: 0
    score: 0.87
  - uuid: bb4f4ed0-91f3-488a-9d64-3a33bde77e4e
    line: 66
    col: 0
    score: 0.87
  - uuid: f4767ec9-7363-4ca0-ad88-ccc624247a3b
    line: 247
    col: 0
    score: 0.87
  - uuid: 7ab1a3cd-80a7-4d69-ae21-1da07cd0523c
    line: 245
    col: 0
    score: 0.87
  - uuid: 792a343e-674c-4bb4-8435-b3f8c163349d
    line: 78
    col: 0
    score: 0.86
  - uuid: 4316c3f9-551f-4872-b5c5-98ae73508535
    line: 36
    col: 0
    score: 0.86
  - uuid: 8fd08696-5338-493b-bed5-507f8a6a6ea9
    line: 358
    col: 0
    score: 0.86
  - uuid: a28a39dd-8c17-463c-9050-2ffe9b56e8bc
    line: 128
    col: 0
    score: 0.86
  - uuid: 6f13f134-7536-4bc3-b695-5aaa2906bb9d
    line: 28
    col: 0
    score: 0.86
  - uuid: bb4f4ed0-91f3-488a-9d64-3a33bde77e4e
    line: 101
    col: 0
    score: 0.86
  - uuid: 6f13f134-7536-4bc3-b695-5aaa2906bb9d
    line: 128
    col: 0
    score: 0.86
  - uuid: e4317155-7fa6-44e8-8aee-b72384581790
    line: 32
    col: 0
    score: 0.85
  - uuid: a28a39dd-8c17-463c-9050-2ffe9b56e8bc
    line: 77
    col: 0
    score: 0.85
  - uuid: a28a39dd-8c17-463c-9050-2ffe9b56e8bc
    line: 162
    col: 0
    score: 0.85
---
Note: Consolidated here → ../notes/js/archetype-ecs.md ^ref-8f4c1e86-1-0

Heck yes—here’s a **small but legit archetype-based ECS** you can drop in as `shared/js/prom-lib/ds/ecs.ts`. It’s fast enough for real work: 64-component bitmasks (bigint), archetype tables with SoA storage, add/remove in O(1), queries with `all/any/none`, a `CommandBuffer` for safe structural changes, “changed since last tick” flags, and a tiny scheduler. ^ref-8f4c1e86-3-0

# ECS (TypeScript)

```ts
// shared/js/prom-lib/ds/ecs.ts
// MIT. Zero deps. Archetype ECS with 64-bit signature mask.
// NOTE: 64 components max (extend to 128+ via two bigints if needed).

export type Entity = number;       // 32-bit index, versioned via generations[]
export type ComponentId = number;

const MAX_COMPONENTS = 64;

export interface ComponentSpec<T> {
  name: string;
  defaults?: () => T;            // create default component payload
  onAdd?: (w: World, e: Entity, v: T) => void;
  onRemove?: (w: World, e: Entity, v: T) => void;
}

export interface ComponentType<T> extends ComponentSpec<T> {
  id: ComponentId;               // 0..63
  mask: bigint;                  // 1n << id
}

export type Query = {
  all?: bigint;                  // must have all bits
  any?: bigint;                  // must have at least one
  none?: bigint;                 // must have none
  changed?: bigint;              // at least one changed since last tick
};

type Column = any[];             // SoA column per component id
type Edge = Map<ComponentId, Archetype>; // add/remove graph edges for fast moves

class Archetype {
  mask: bigint;
  entities: Entity[] = [];
  // per component id -> column array
  columns: Map<ComponentId, Column> = new Map();
  addEdges: Edge = new Map();    // if you add comp X, go to archetype Y
  rmEdges: Edge = new Map();     // if you remove comp X, go to archetype Z
  // changed flags per comp id (bitset of rows changed in this tick)
  // For simplicity we track "row touched this tick" as a sparse Set per comp id.
  changed: Map<ComponentId, Set<number>> = new Map();

  constructor(mask: bigint) { this.mask = mask; }

  ensureColumn(cid: ComponentId) {
    if (!this.columns.has(cid)) this.columns.set(cid, []);
    if (!this.changed.has(cid)) this.changed.set(cid, new Set());
  }
}

function hasAll(mask: bigint, all: bigint)   { return (mask & all) === all; }
function hasAny(mask: bigint, any: bigint)   { return any === 0n ? true : (mask & any) !== 0n; }
function hasNone(mask: bigint, none: bigint) { return (mask & none) === 0n; }

export class World {
  // entity bookkeeping
  private generations: number[] = [];      // version per index
  private freeList: number[] = [];         // recycled indices
  private alive = new Set<Entity>();       // quick existence check

  // entity location
  private loc: { arch: Archetype; row: number }[] = []; // by entity index

  // components
  private comps: (ComponentType<any> | null)[] = Array(MAX_COMPONENTS).fill(null);
  private nextCompId = 0;

  // archetypes by mask
  private archetypes = new Map<bigint, Archetype>();
  private emptyArch = this.getOrCreateArchetype(0n);

  // temp: per-tick bookkeeping
  private _inTick = false;

  // === Component registration ===
  defineComponent<T>(spec: ComponentSpec<T>): ComponentType<T> {
    if (this.nextCompId >= MAX_COMPONENTS) throw new Error(`Max {MAX_COMPONENTS} components reached`);
    const id = this.nextCompId++;
    const type: ComponentType<T> = { ...spec, id, mask: 1n << BigInt(id) };
    this.comps[id] = type;
    // ensure add/remove edges exist for empty archetype lazily
    return type;
  }

  // === Entities ===
  createEntity(init?: Record<ComponentId, any> | bigint): Entity {
    // allocate entity id
    const idx = this.freeList.length ? (this.freeList.pop() as number) : this.generations.length;
    const gen = (this.generations[idx] ?? 0) & 0xffff;
    this.generations[idx] = gen;
    const e = (gen << 16) | idx;
    this.alive.add(e);

    // place in empty archetype first
    this.loc[idx] = this.addRow(this.emptyArch, e);

    // attach initial components
    if (typeof init === "bigint") {
      // mask-only init: fill with defaults
      for (let cid=0; cid<this.nextCompId; cid++) {
        const m = 1n << BigInt(cid);
        if ((init & m) !== 0n) {
          const ct = this.comps[cid]!;
          this.addComponent(e, ct, ct.defaults ? ct.defaults() : undefined);
        }
      }
    } else if (init) {
      for (const k in init) {
        const cid = Number(k);
        const ct = this.comps[cid];
        if (!ct) throw new Error(`Unknown component id {cid}`);
        this.addComponent(e, ct, init[cid]);
      }
    }
    return e;
  }

  destroyEntity(e: Entity): void {
    this.requireAlive(e);
    const { arch, row } = this.loc[e & 0xffff];
    // call onRemove hooks for all comps present
    for (let cid=0; cid<this.nextCompId; cid++) {
      const bit = 1n << BigInt(cid);
      if ((arch.mask & bit) !== 0n) {
        const v = arch.columns.get(cid)![row];
        this.comps[cid]!.onRemove?.(this, e, v);
      }
    }
    this.removeRow(arch, row);
    // retire entity
    const idx = e & 0xffff;
    const gen = (this.generations[idx] ?? 0) + 1;
    this.generations[idx] = gen;
    this.alive.delete(e);
    this.freeList.push(idx);
  }

  isAlive(e: Entity): boolean {
    const idx = e & 0xffff, gen = e >>> 16;
    return this.generations[idx] === gen && this.alive.has(e);
  }

  // === Components ops ===
  addComponent<T>(e: Entity, ct: ComponentType<T>, value?: T): void {
    this.requireAlive(e);
    const idx = e & 0xffff;
    const from = this.loc[idx].arch;
    if ((from.mask & ct.mask) !== 0n) {
      // already has: set value + mark changed
      const row = this.loc[idx].row;
      from.columns.get(ct.id)![row] = value ?? from.columns.get(ct.id)![row];
      from.changed.get(ct.id)!.add(row);
      return;
    }
    // move to new archetype with component added
    const to = this.nextArchetype(from, ct.id, true);
    const oldRow = this.loc[idx].row;
    const payloads: Record<number, any> = {};
    // carry over existing columns
    for (const [cid, col] of from.columns) payloads[cid] = col[oldRow];
    // new comp value (or default)
    payloads[ct.id] = value ?? ct.defaults?.();
    this.move(e, from, oldRow, to, payloads);
    ct.onAdd?.(this, e, payloads[ct.id]);
  }

  removeComponent<T>(e: Entity, ct: ComponentType<T>): void {
    this.requireAlive(e);
    const idx = e & 0xffff;
    const from = this.loc[idx].arch;
    if ((from.mask & ct.mask) === 0n) return; // nothing to do
    const to = this.nextArchetype(from, ct.id, false);
    const oldRow = this.loc[idx].row;
    const payloads: Record<number, any> = {};
    // carry over existing columns except the removed one
    for (const [cid, col] of from.columns) if (cid !== ct.id) payloads[cid] = col[oldRow];
    const oldVal = from.columns.get(ct.id)![oldRow];
    this.move(e, from, oldRow, to, payloads);
    ct.onRemove?.(this, e, oldVal);
  }

  get<T>(e: Entity, ct: ComponentType<T>): T | undefined {
    if (!this.isAlive(e)) return undefined;
    const { arch, row } = this.loc[e & 0xffff];
    if ((arch.mask & ct.mask) === 0n) return undefined;
    return arch.columns.get(ct.id)![row];
  }

  set<T>(e: Entity, ct: ComponentType<T>, value: T): void {
    this.requireAlive(e);
    const { arch, row } = this.loc[e & 0xffff];
    if ((arch.mask & ct.mask) === 0n) throw new Error(`entity lacks component '{ct.name}'`);
    arch.columns.get(ct.id)![row] = value;
    arch.changed.get(ct.id)!.add(row);
  }

  has(e: Entity, ct: ComponentType<any>): boolean {
    if (!this.isAlive(e)) return false;
    const { arch } = this.loc[e & 0xffff];
    return (arch.mask & ct.mask) !== 0n;
  }

  // === Query + iteration ===
  // Build a query mask set: pass ComponentType(s) for all/any/none/changed
  makeQuery(opts: { all?: ComponentType<any>[]; any?: ComponentType<any>[]; none?: ComponentType<any>[]; changed?: ComponentType<any>[] }): Query {
    const bit = (arr?: ComponentType<any>[]) => (arr && arr.length ? arr.map(c=>c.mask).reduce((a,b)=>a|b, 0n) : 0n);
    return { all: bit(opts.all), any: bit(opts.any), none: bit(opts.none), changed: bit(opts.changed) };
  }

  // Iterate matching entities. Returns generator of (e, getters) tuples to keep it ergonomic.
  *iter<T1=unknown,T2=unknown,T3=unknown>(q: Query, c1?: ComponentType<T1>, c2?: ComponentType<T2>, c3?: ComponentType<T3>):
    IterableIterator<[Entity, (ct: ComponentType<any>) => any, T1?, T2?, T3?]> {
    for (const arch of this.archetypes.values()) {
      const m = arch.mask;
      if (q.all && !hasAll(m, q.all)) continue;
      if (q.any && !hasAny(m, q.any)) continue;
      if (q.none && !hasNone(m, q.none)) continue;
      const rows = arch.entities.length;
      const needChanged = q.changed && q.changed !== 0n;
      for (let row=0; row<rows; row++) {
        if (needChanged) {
          // require at least one of the 'changed' components touched this tick
          let ok = false;
          for (let cid=0; cid<this.nextCompId; cid++) {
            const bit = 1n << BigInt(cid);
            if ((q.changed! & bit) !== 0n) {
              if (arch.changed.get(cid)?.has(row)) { ok = true; break; }
            }
          }
          if (!ok) continue;
        }
        const e = arch.entities[row];
        const get = (ct: ComponentType<any>) => arch.columns.get(ct.id)![row];
        const v1 = c1 ? arch.columns.get(c1.id)![row] : undefined;
        const v2 = c2 ? arch.columns.get(c2.id)![row] : undefined;
        const v3 = c3 ? arch.columns.get(c3.id)![row] : undefined;
        yield [e, get, v1 as any, v2 as any, v3 as any];
      }
    }
  }

  // === Ticking & command buffers ===
  beginTick(): CommandBuffer {
    if (this._inTick) throw new Error("nested tick not allowed");
    this._inTick = true;
    // clear 'changed' flags at start of tick
    for (const a of this.archetypes.values()) for (const s of a.changed.values()) s.clear();
    return new CommandBuffer(this);
  }

  endTick(): void {
    if (!this._inTick) return;
    this._inTick = false;
  }

  // === Internals ===
  private getOrCreateArchetype(mask: bigint): Archetype {
    let a = this.archetypes.get(mask);
    if (!a) {
      a = new Archetype(mask);
      // initialize columns for existing comps present in mask
      for (let cid=0; cid<this.nextCompId; cid++) {
        const bit = 1n << BigInt(cid);
        if ((mask & bit) !== 0n) a.ensureColumn(cid);
      }
      this.archetypes.set(mask, a);
    }
    return a;
  }

  private nextArchetype(from: Archetype, cid: ComponentId, adding: boolean): Archetype {
    const edges = adding ? from.addEdges : from.rmEdges;
    let to = edges.get(cid);
    if (!to) {
      const toMask = adding ? (from.mask | (1n << BigInt(cid))) : (from.mask & ~(1n << BigInt(cid)));
      to = this.getOrCreateArchetype(toMask);
      // ensure necessary columns exist there
      for (let i=0; i<this.nextCompId; i++) {
        const bit = 1n << BigInt(i);
        if ((toMask & bit) !== 0n) to.ensureColumn(i);
      }
      edges.set(cid, to);
    }
    return to;
  }

  private addRow(arch: Archetype, e: Entity): { arch: Archetype; row: number } {
    const row = arch.entities.length;
    arch.entities.push(e);
    // grow columns
    for (const [cid, col] of arch.columns) {
      if (col.length < arch.entities.length) col.push(undefined);
      arch.changed.get(cid)!.add(row); // mark as changed on arrival
    }
    // stash loc
    this.loc[e & 0xffff] = { arch, row };
    return this.loc[e & 0xffff];
  }

  private removeRow(arch: Archetype, row: number): void {
    const last = arch.entities.length - 1;
    const eLast = arch.entities[last];
    // swap-remove entity row
    arch.entities[row] = eLast;
    arch.entities.pop();
    for (const [cid, col] of arch.columns) {
      col[row] = col[last];
      col.pop();
      // mark changed for touched rows
      arch.changed.get(cid)!.add(row);
    }
    // update moved entity loc
    const idxLast = eLast & 0xffff;
    this.loc[idxLast] = { arch, row };
  }

  private move(e: Entity, from: Archetype, oldRow: number, to: Archetype, payloads: Record<number, any>) {
    // add to 'to'
    const loc = this.addRow(to, e);
    // seed columns from payloads
    for (const [cid, val] of Object.entries(payloads)) {
      const n = Number(cid);
      to.columns.get(n)![loc.row] = val;
      to.changed.get(n)!.add(loc.row);
    }
    // remove old row (will swap another entity down)
    this.removeRow(from, oldRow);
  }

  private requireAlive(e: Entity) {
    if (!this.isAlive(e)) throw new Error(`entity {e} is not alive or stale handle`);
  }
}

export class CommandBuffer {
  private world: World;
  private ops: (() => void)[] = [];
  constructor(w: World) { this.world = w; }

  createEntity(init?: Record<ComponentId, any> | bigint): Entity {
    let temp: Entity = -1;
    this.ops.push(() => { temp = this.world.createEntity(init); });
    return temp;
  }
  destroyEntity(e: Entity) { this.ops.push(() => this.world.destroyEntity(e)); }
  add<T>(e: Entity, ct: ComponentType<T>, v?: T) { this.ops.push(() => this.world.addComponent(e, ct, v)); }
  remove<T>(e: Entity, ct: ComponentType<T>) { this.ops.push(() => this.world.removeComponent(e, ct)); }
  set<T>(e: Entity, ct: ComponentType<T>, v: T) { this.ops.push(() => this.world.set(e, ct, v)); }

  flush() {
    for (const op of this.ops) op();
    this.ops.length = 0;
  }
}
```
```
^ref-8f4c1e86-7-0 ^ref-8f4c1e86-363-0
```
# Tiny usage demo
```
^ref-8f4c1e86-366-0
```
```ts
import { World } from "./ecs";

// 1) Define components
type Position = { x:number; y:number };
type Velocity = { x:number; y:number };
type Lifetime = { t:number };

const world = new World();
const CPos = world.defineComponent<Position>({ name: "Position", defaults: () => ({x:0,y:0}) });
const CVel = world.defineComponent<Velocity>({ name: "Velocity", defaults: () => ({x:0,y:0}) });
const CLife = world.defineComponent<Lifetime>({ name: "Lifetime", defaults: () => ({t:1.0}) });

// 2) Spawn
const e = world.createEntity();
world.addComponent(e, CPos, {x:0,y:0});
world.addComponent(e, CVel, {x:2,y:1});
world.addComponent(e, CLife, {t:3});

// 3) Systems (per tick)
function physics(dt: number) {
  const q = world.makeQuery({ all:[CPos, CVel] });
  for (const [ent, get, pos, vel] of world.iter(q, CPos, CVel)) {
    pos!.x += vel!.x * dt;
    pos!.y += vel!.y * dt;
    world.set(ent, CPos, pos!); // mark changed
  }
}

function decay(dt: number) {
  const q = world.makeQuery({ all:[CLife] });
  for (const [ent, get, life] of world.iter(q, CLife)) {
    life!.t -= dt;
    if (life!.t <= 0) world.destroyEntity(ent);
    else world.set(ent, CLife, life!);
  }
}

// 4) Tick with a command buffer (optional for structural ops)
function tick(dt: number) {
  const cmd = world.beginTick();
  physics(dt);
  decay(dt);
  cmd.flush();
  world.endTick();
}
^ref-8f4c1e86-366-0
```
```
^ref-8f4c1e86-367-0
```
# Extras you can add optional, easy bolt-ons
```
^ref-8f4c1e86-417-0
```
* **System scheduler** with dependencies (use the DAG you already have—toposort the system graph and run). ^ref-8f4c1e86-418-0
* **Events**: fire component `onAdd/onRemove` (already supported) + `onChanged` subscription via `changed:` queries. ^ref-8f4c1e86-419-0
* **Serialization**: `World → JSON` by dumping archetypes and columns; `JSON → World` by rebuilding rows.
* **More than 64 components**: maintain two (or N) `bigint` masks per archetype and per query.

# Mermaid (shape of the ECS) ^ref-8f4c1e86-423-0

```mermaid
flowchart LR
  subgraph World
    A[Archetype 0b0011]:::arch
    B[Archetype 0b0111]:::arch
    C[Archetype 0b0010]:::arch
    A-- add C2 -->B
    B-- remove C1 -->C
    A -- SoA columns --> ColsA[(Pos[], Vel[])]
    B -- SoA columns --> ColsB[(Pos[], Vel[], Life[])]
  end
  Sys1[Physics System] -->|query all:[Pos,Vel]| A & B
  Sys2[Lifetime System] -->|query all:[Life]| B
^ref-8f4c1e86-423-0
  classDef arch fill:#eef,stroke:#88f;
```
```
^ref-8f4c1e86-441-0
```
# Sibilant sprinkles (pseudo)

```lisp
; shared/sibilant/prom/ds/ecs.sib (pseudo)
(defn make-world [] (new World))
(defn defcomp [w name defaults] (.defineComponent w {:name name :defaults defaults}))
(defn query [w & {:all [] :any [] :none [] :changed []}]
^ref-8f4c1e86-441-0
  (.makeQuery w {:all all :any any :none none :changed changed})) ^ref-8f4c1e86-450-0
(defn iter [w q & comps] (.iter w q ~@comps))
``````
^ref-8f4c1e86-452-0
```
```
^ref-8f4c1e86-445-0
```
```
^ref-8f4c1e86-444-0
```
```
^ref-8f4c1e86-453-0
```
Want me to wire a **system scheduler** that uses the Graph you already have with per-system resources, parallel-safe stages, or add a **prefab/blueprint** loader?
```
cmd = world.beginTick();
```
  physics(dt);
  decay(dt);
  cmd.flush();
  world.endTick();
}
```
^ref-8f4c1e86-366-0
```
```
^ref-8f4c1e86-367-0

# Extras you can add (optional, easy bolt-ons)
 ^ref-8f4c1e86-417-0
* **System scheduler** with dependencies (use the DAG you already have—toposort the system graph and run). ^ref-8f4c1e86-418-0
* **Events**: fire component `onAdd/onRemove` (already supported) + `onChanged` subscription via `changed:` queries. ^ref-8f4c1e86-419-0
* **Serialization**: `World → JSON` by dumping archetypes and columns; `JSON → World` by rebuilding rows.
* **More than 64 components**: maintain two (or N) `bigint` masks per archetype and per query.

# Mermaid (shape of the ECS) ^ref-8f4c1e86-423-0

```mermaid
flowchart LR
  subgraph World
    A[Archetype 0b0011]:::arch
    B[Archetype 0b0111]:::arch
    C[Archetype 0b0010]:::arch
```
A-- add C2 -->B
```
```
B-- remove C1 -->C
```
    A -- SoA columns --> ColsA[(Pos[], Vel[])]
    B -- SoA columns --> ColsB[(Pos[], Vel[], Life[])]
  end
  Sys1[Physics System] -->|query all:[Pos,Vel]| A & B
  Sys2[Lifetime System] -->|query all:[Life]| B
```
^ref-8f4c1e86-423-0
```
  classDef arch fill:#eef,stroke:#88f;
```
 ^ref-8f4c1e86-441-0
# Sibilant sprinkles (pseudo)

```lisp
; shared/sibilant/prom/ds/ecs.sib (pseudo)
$defn make-world [] (new World)
(defn defcomp [w name defaults] (.defineComponent w {:name name :defaults defaults}))
(defn query [w & {:all [] :any [] :none [] :changed []}]
```
^ref-8f4c1e86-441-0
```
  (.makeQuery w {:all all :any any :none none :changed changed})) ^ref-8f4c1e86-450-0
(defn iter [w q & comps] (.iter w q ~@comps))
```
``` ^ref-8f4c1e86-452-0
```
```
^ref-8f4c1e86-444-0
```
```
^ref-8f4c1e86-453-0
```
Want me to wire a **system scheduler** that uses the Graph you already have with per-system resources, parallel-safe stages, or add a **prefab/blueprint** loader?
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-BELOW -->
## Related content
- [Promethean State Format]promethean-state-format.md
- [ChatGPT Custom Prompts]chatgpt-custom-prompts.md
- archetype-ecs$archetype-ecs.md
- [Promethean Code Principles](2025.09.03.20.16.19.md)
- promethean-pipelines$promethean-pipelines.md
- [Functional Refactor of TypeScript Document Processing]functional-refactor-of-typescript-document-processing.md
- chroma-embedding-refactor$chroma-embedding-refactor.md
- windows-tiling-with-autohotkey$windows-tiling-with-autohotkey.md
- ecs-scheduler$ecs-scheduler-and-prefabs.md
- system-scheduler$system-scheduler-with-resource-aware-dag.md
- [WebSocket Gateway Implementation]websocket-gateway-implementation.md
- typed-struct-compiler$typed-struct-compiler.md
- AI-Centric OS with MCP Layer$ai-centric-os-with-mcp-layer.md
- shared-package-layout-clarification$shared-package-layout-clarification.md
- [TypeScript Patch for Tool Calling Support]typescript-patch-for-tool-calling-support.md
- heartbeat-fragment-demo$heartbeat-fragment-demo.md
- observability-infrastructure-setup$observability-infrastructure-setup.md
- [Promethean Documentation Pipeline Overview]promethean-documentation-pipeline-overview.md
- [Agent Reflections and Prompt Evolution]agent-reflections-and-prompt-evolution.md
- [Stateful Partitions and Rebalancing]stateful-partitions-and-rebalancing.md
- language-agnostic-mirror-system$language-agnostic-mirror-system.md
- functional-programming-in-typescript$functional-programming-in-typescript.md
- [Lean AGENT Setup]agents-md.md
- [AGENTS.md]agents-md-3.md
## Sources
- archetype-ecs — L7$archetype-ecs.md#^ref-8f4c1e86-7-0 (line 7, col 0, score 1)
- [ChatGPT Custom Prompts — L5]chatgpt-custom-prompts.md#^ref-96ffd77d-5-0 (line 5, col 0, score 1)
- [ChatGPT Custom Prompts — L9]chatgpt-custom-prompts.md#^ref-96ffd77d-9-0 (line 9, col 0, score 1)
- [ChatGPT Custom Prompts — L16]chatgpt-custom-prompts.md#^ref-96ffd77d-16-0 (line 16, col 0, score 1)
- archetype-ecs — L445$archetype-ecs.md#^ref-8f4c1e86-445-0 (line 445, col 0, score 0.97)
- [Promethean Code Principles — L3]2025.09.03.20.16.19.md#^ref-9f8f8fb9-3-0 (line 3, col 0, score 0.94)
- [Promethean Code Principles — L5]2025.09.03.20.16.19.md#^ref-9f8f8fb9-5-0 (line 5, col 0, score 0.92)
- promethean-pipelines — L68$promethean-pipelines.md#^ref-86ef1f2b-68-0 (line 68, col 0, score 0.89)
- [Functional Refactor of TypeScript Document Processing — L1]functional-refactor-of-typescript-document-processing.md#^ref-0a8255a5-1-0 (line 1, col 0, score 0.87)
- promethean-pipelines — L84$promethean-pipelines.md#^ref-86ef1f2b-84-0 (line 84, col 0, score 0.87)
- chroma-embedding-refactor — L66$chroma-embedding-refactor.md#^ref-bb4f4ed0-66-0 (line 66, col 0, score 0.87)
- ecs-scheduler — L247$ecs-scheduler-and-prefabs.md#^ref-f4767ec9-247-0 (line 247, col 0, score 0.87)
- system-scheduler — L245$system-scheduler-with-resource-aware-dag.md#^ref-7ab1a3cd-245-0 (line 245, col 0, score 0.87)
- windows-tiling-with-autohotkey — L78$windows-tiling-with-autohotkey.md#^ref-792a343e-78-0 (line 78, col 0, score 0.86)
- [WebSocket Gateway Implementation — L36]websocket-gateway-implementation.md#^ref-4316c3f9-36-0 (line 36, col 0, score 0.86)
- typed-struct-compiler — L358$typed-struct-compiler.md#^ref-8fd08696-358-0 (line 358, col 0, score 0.86)
- AI-Centric OS with MCP Layer — L128$ai-centric-os-with-mcp-layer.md#^ref-a28a39dd-128-0 (line 128, col 0, score 0.86)
- shared-package-layout-clarification — L28$shared-package-layout-clarification.md#^ref-6f13f134-28-0 (line 28, col 0, score 0.86)
- chroma-embedding-refactor — L101$chroma-embedding-refactor.md#^ref-bb4f4ed0-101-0 (line 101, col 0, score 0.86)
- shared-package-layout-clarification — L128$shared-package-layout-clarification.md#^ref-6f13f134-128-0 (line 128, col 0, score 0.86)
- [TypeScript Patch for Tool Calling Support — L32]typescript-patch-for-tool-calling-support.md#^ref-e4317155-32-0 (line 32, col 0, score 0.85)
- AI-Centric OS with MCP Layer — L77$ai-centric-os-with-mcp-layer.md#^ref-a28a39dd-77-0 (line 77, col 0, score 0.85)
- AI-Centric OS with MCP Layer — L162$ai-centric-os-with-mcp-layer.md#^ref-a28a39dd-162-0 (line 162, col 0, score 0.85)
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-ABOVE -->

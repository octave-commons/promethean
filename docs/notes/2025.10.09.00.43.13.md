Gotcha—here’s a crisp, developer-ready work order you can drop into your tracker.

# Work Order: Kanban-Driven Codex Executor

## Summary

Build a TypeScript package that continuously pulls tasks from a Kanban source, composes an execution prompt from column state and task body, runs `codex exec` to implement work items (next item from `TODO.md` or a Kanban card body), enforces transition rules via text-defined “tests,” and selects/validates related tests using a vector store. Must be idempotent, cache-aware, and safe to run under PM2 without log deadlocks.

## Goals

* Automate “implement next task” loops with controlled state transitions.
* Treat tests as plain strings; store and retrieve them via vector similarity to each task.
* Enforce a minimum number of matched tests that must pass before promoting a card.
* Keep all logic in a new, isolated package under `packages/`.
* Provide CLI(s) + README for local and CI use.

## Non-Goals

* Building a Kanban UI.
* Writing business-specific tests beyond examples/fixtures.
* Replacing existing CI—only provide a CLI hook.

## High-Level Flow (Mermaid)

```mermaid
flowchart TD
  A[Kanban Provider] --> B[Task Fetcher]
  B --> C[Prompt Composer (status.prompt + task.body)]
  C --> D[Codex Executor]
  D --> E[Result Parser]
  E --> F[Vector Store: Test Index]
  F --> G[Test Selector (k, threshold)]
  G --> H[Test Runner]
  H --> I{All required tests passed?}
  I -- yes --> J[Transition Engine -> Move Card + Update State]
  I -- no --> K[Update Task State, Bounce via Transition Rules]
  J --> L[Cache Writer]
  K --> L
  L --> M[PM2/Process Supervisor Safe Output]
```

## Package Layout

```
packages/
  kanban-codex-exec/
    src/
      index.ts                 # CLI entry
      lib/
        kanban/
          provider.ts          # pluggable Kanban adapters (markdown board, GitHub Projects, file)
          types.ts
        codex/
          exec.ts              # thin wrapper: `codex exec "<prompt>" ...`
          prompts.ts           # prompt templates + guards
        tests/
          vectorStore.ts       # cosine/FAISS-like local index (file-backed)
          selector.ts          # retrieve top-k tests per task
          runner.ts            # run text tests (string includes/regex/shell hooks)
        state/
          cache.ts             # idempotent run cache (JSONL/SQLite)
          transitions.ts       # transition rules + validation
        process/
          pm2Safe.ts           # spawn options to avoid log lockups
        util/
          logger.ts, fsx.ts, shell.ts, env.ts
    bin/
      kanban-codex-exec        # symlink to ts-node/compiled
    examples/
      board.md                 # sample Kanban
      tests.txt                # sample test strings
      transitions.yaml
    README.md
    package.json
    tsconfig.json
```

## Interfaces (TypeScript)

```ts
// kanban/types.ts
export type KanbanStatus = "Backlog" | "In Progress" | "Review" | "Done" | string;

export interface KanbanTask {
  id: string;
  title: string;
  body: string;         // task description
  state?: Record<string, unknown>; // task-local state
  status: KanbanStatus;
  labels?: string[];
  metadata?: Record<string, unknown>;
}

export interface KanbanProvider {
  getColumns(): Promise<KanbanStatus[]>;
  getColumn(status: KanbanStatus): Promise<KanbanTask[]>;
  updateTask(taskId: string, patch: Partial<KanbanTask>): Promise<void>;
  transition(taskId: string, nextStatus: KanbanStatus): Promise<void>;
}
```

```ts
// codex/exec.ts
export interface CodexOptions {
  model?: string; // default: gpt-5-codex
  reasoningEffort?: "low" | "medium" | "high";
  bypassApprovals?: boolean; // default true
  sandbox?: boolean;         // default false (bypass)
}

export interface ExecResult {
  ok: boolean;
  stdout: string;
  stderr: string;
  artifacts?: string[]; // files changed / created
}

export type PromptComposer = (status: KanbanStatus, task: KanbanTask) => string;
```

```ts
// tests/types
export interface TestString { id: string; text: string; tags?: string[]; }
export interface TestSelectorInput { task: KanbanTask; k: number; minRequired: number; threshold?: number; }
export interface TestOutcome { id: string; passed: boolean; evidence?: string; }
```

## CLI Commands

* `kanban-codex-exec run`
  Pull tasks and execute until queue drained or guard limits reached.
* `kanban-codex-exec index-tests --file examples/tests.txt`
  Build/update local vector index of test strings.
* `kanban-codex-exec dry-run`
  Simulate transitions; no external writes or codex execution.
* `kanban-codex-exec print-plan`
  Show selected tasks, prompts, and tests without running.

### Env Vars & Config

* `KANBAN_PROVIDER` = `markdown|github|file`
* `KANBAN_SOURCE` = path or repo/project identifier
* `TESTS_FILE` = path to newline-delimited tests
* `TRANSITIONS_FILE` = YAML with transition rules
* `K_MIN` = default top-k tests per task (e.g., 5)
* `K_REQ` = minimum required passing tests (e.g., 3)
* `CACHE_DIR` = path for run cache (default `.cache/kanban-codex-exec`)
* `CODEX_MODEL` = default `gpt-5-codex`
* `REASONING_EFFORT` = `high` by default

## Functional Requirements

1. **Task Iteration**

   * Iterate `for [status in getColumns]` → `for [task in getColumn(status)]`.
   * Compose prompt:
     `status.prompt /* system/guard text */ + "\n\n" + task.body`.
   * If `TODO.md` exists and `KANBAN_PROVIDER=markdown`, support “next item” loop mode.

2. **Codex Execution**

   * Shell out: `codex exec "<prompt>" -c model_reasoning_effort='high' -m gpt-5-codex --dangerously-bypass-approvals-and-sandbox`.
   * Capture stdout/stderr without blocking; never tail logs indefinitely.

3. **Tests as Strings**

   * Load tests (newline-delimited). Persist vectors locally (e.g., cosine similarity over sentence embeddings; simple local model or cached embeddings).
   * Selector returns top-k above `threshold` with diversity (MMR) to avoid near-duplicates.

4. **Validation Gate**

   * Before transitioning forward, run selected tests.
   * Types of tests:

     * `includes:some substring`
     * `regex:/pattern/flags`
     * `shell:command` (opt-in; disabled by default for safety)
   * Require `K_REQ` passing; otherwise:

     * Update task state with failure details.
     * Bounce card via configured transition (e.g., `In Progress` → `Needs Specs`).

5. **Transition Rules**

   * Declarative YAML:

     ```yaml
     statuses:
       In Progress:
         onFail: Needs Specs
         onPass: Review
       Review:
         onFail: In Progress
         onPass: Done
     ```
   * Optional hooks: `beforeTransition`, `afterTransition` (shell or JS).

6. **Cache & Idempotency**

   * Cache key: `task.id + task.status + promptHash`.
   * If identical prompt previously run with same artifacts and passing tests, skip.
   * Write JSONL records with inputs/outputs, artifacts, and test outcomes.

7. **PM2 Safety**

   * Use `child_process.spawn` with `stdio: ['ignore','pipe','pipe']`, `detached: false`.
   * Limit buffers, stream to rotating files via our logger (no infinite tail).
   * Provide PM2 sample config with `merge_logs: true`, `max_restarts`, and `out_file/err_file` rotation.

8. **Security/Guardrails**

   * Block `shell:` tests unless `ALLOW_SHELL_TESTS=true`.
   * Enforce allowlist of commands if enabled.
   * Never pass secrets into prompts; redact via `env.ts`.

## Acceptance Criteria

* Running `kanban-codex-exec run` against `examples/board.md` executes tasks, selects tests from `examples/tests.txt`, and:

  * Promotes cards only when ≥ `K_REQ` tests pass.
  * Bounces cards on failure with state updated containing reasons.
  * Skips already-satisfied tasks due to cache hits.
* PM2 sample process file runs without hanging on logs; stopping/starting does not duplicate work (idempotent).
* README documents setup, env, sample flows, and troubleshooting.
* Unit tests cover: prompt composition, vector selection, transitions, caching, and PM2 spawning.
* E2E dry run reproduces an execution plan without mutations.

## Definition of Done

* Package published/linked in monorepo at `packages/kanban-codex-exec`.
* `pnpm build && pnpm test` green.
* Example Kanban + tests + transitions validated locally.
* CI job demonstrates `dry-run` and `run` (with shell tests disabled).

## Implementation Notes (pseudocode)

```ts
for (const status of kanban.getColumns()) {
  const tasks = await kanban.getColumn(status);
  for (const task of tasks) {
    const prompt = composePrompt(status, task);
    const cacheHit = cache.has(task.id, status, prompt);
    if (cacheHit) continue;

    const execRes = await codex.exec(prompt, { reasoningEffort: "high" });
    const tests = await selector.select({ task, k: env.K_MIN, minRequired: env.K_REQ });
    const outcomes = await runner.runAll(execRes, tests);

    if (countPass(outcomes) >= env.K_REQ) {
      await transitions.promote(task.id, status, "pass", outcomes);
    } else {
      await transitions.bounce(task.id, status, "fail", outcomes);
    }
    await cache.write({ task, status, prompt, execRes, outcomes });
  }
}
```

## Milestones (no time estimates)

1. Scaffold package, config, and adapters.
2. Codex executor + PM2-safe process handling.
3. Vector test index + selector with MMR.
4. Transition engine + YAML config.
5. Cache + idempotent run records.
6. CLI, examples, and README.
7. Unit + E2E tests.

## Deliverables

* `packages/kanban-codex-exec` (source + binaries).
* `examples/` with board, transitions, and tests.
* PM2 ecosystem file + guidance.
* README with setup, usage, and troubleshooting.

If you want, I can also generate the initial package skeleton and example files to drop into your repo.

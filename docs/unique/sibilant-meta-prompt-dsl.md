---
uuid: 9a7799ff-78bf-451d-9066-24555d8eb209
created_at: sibilant-meta-prompt-dsl.md
filename: Sibilant Meta-Prompt DSL
title: Sibilant Meta-Prompt DSL
description: >-
  A Lisp-based meta-prompt DSL for programmable LLM interactions, enabling
  structured prompt compilation, state management, and multi-runtime agent
  systems. It transforms high-level prompt definitions into executable JSON
  prompts with semantic memory and model-specific configurations.
tags:
  - Lisp
  - meta-prompt
  - DSL
  - LLM
  - programmable agents
  - structured prompts
  - state management
  - compiler
related_to_uuid:
  - babdb9eb-3b15-48a7-8a22-ecc53af7d397
  - 18138627-a348-4fbb-b447-410dfb400564
  - 18344cf9-0c49-4a71-b6c8-b8d84d660fca
  - 03a5578f-d689-45db-95e9-11300e5eee6f
  - 9b694a91-dec5-4708-9462-3f71000ba925
  - 008f2ac0-bfaa-4d52-9826-2d5e86c0059f
  - 1cfae310-35dc-49c2-98f1-b186da25d84b
  - f5579967-762d-4cfd-851e-4f71b4cb77a1
  - 509e1cd5-367c-4a9d-a61b-cef2e85d42ce
  - 49d1e1e5-5d13-4955-8f6f-7676434ec462
  - 6498b9d7-bd35-4bd3-89fb-af1c415c3cd1
  - 5e8b2388-022b-46cf-952c-36ae9b8f0037
  - cbfe3513-6a4a-4d2e-915d-ddfab583b2de
  - 687439f9-ad1e-40a4-8a32-3a1b4ac7c017
  - 9a8ab57e-507c-4c6b-aab4-01cea1bc0501
  - b4e64f8c-4dc9-4941-a877-646c5ada068e
  - 513dc4c7-e045-4123-ba2e-cf5ef0b7b4a3
  - ba244286-4e84-425b-8bf6-b80c4eb783fc
  - ad7f1ed3-c9bf-4e85-9eeb-6cc4b53155f3
  - d527c05d-22e8-4493-8f29-ae3cb67f035b
  - 21d5cc09-b005-4ede-8f69-00b4b0794540
  - e811123d-5841-4e52-bf8c-978f26db4230
  - b01856b4-999f-418d-8009-ade49b00eb0f
  - 534fe91d-e87d-4cc7-b0e7-8b6833353d9b
  - f7702bf8-f7db-473c-9a5b-8dbf66ad3b9e
related_to_title:
  - Recursive Prompt Construction Engine
  - The Jar of Echoes
  - Promethean Chat Activity Report
  - Promethean Dev Workflow Update
  - Obsidian Task Generation
  - eidolon-field-math-foundations
  - Functional Refactor of TypeScript Document Processing
  - Performance-Optimized-Polyglot-Bridge
  - State Snapshots API and Transactional Projector
  - EidolonField
  - ecs-offload-workers
  - Eidolon Field Abstract Model
  - Lispy Macros with syntax-rules
  - Matplotlib Animation with Async Execution
  - Local-Only-LLM-Workflow
  - observability-infrastructure-setup
  - mystery-lisp-search-session
  - System Scheduler with Resource-Aware DAG
  - Local-Offline-Model-Deployment-Strategy
  - Pure-Node Crawl Stack with Playwright and Crawlee
  - Exception Layer Analysis
  - WebSocket Gateway Implementation
  - Universal Lisp Interface
  - Event Bus MVP
  - Dynamic Context Model for Web Components
references:
  - uuid: babdb9eb-3b15-48a7-8a22-ecc53af7d397
    line: 6
    col: 0
    score: 0.91
  - uuid: 18344cf9-0c49-4a71-b6c8-b8d84d660fca
    line: 8780
    col: 0
    score: 0.89
  - uuid: 18138627-a348-4fbb-b447-410dfb400564
    line: 13928
    col: 0
    score: 0.89
  - uuid: 9b694a91-dec5-4708-9462-3f71000ba925
    line: 1088
    col: 0
    score: 0.89
  - uuid: 03a5578f-d689-45db-95e9-11300e5eee6f
    line: 18703
    col: 0
    score: 0.89
  - uuid: 008f2ac0-bfaa-4d52-9826-2d5e86c0059f
    line: 22280
    col: 0
    score: 0.89
  - uuid: 1cfae310-35dc-49c2-98f1-b186da25d84b
    line: 3462
    col: 0
    score: 0.89
  - uuid: 03a5578f-d689-45db-95e9-11300e5eee6f
    line: 14097
    col: 0
    score: 0.89
  - uuid: f5579967-762d-4cfd-851e-4f71b4cb77a1
    line: 2504
    col: 0
    score: 0.89
  - uuid: 509e1cd5-367c-4a9d-a61b-cef2e85d42ce
    line: 303
    col: 0
    score: 0.89
  - uuid: 6498b9d7-bd35-4bd3-89fb-af1c415c3cd1
    line: 427
    col: 0
    score: 0.88
  - uuid: 49d1e1e5-5d13-4955-8f6f-7676434ec462
    line: 207
    col: 0
    score: 0.88
  - uuid: 5e8b2388-022b-46cf-952c-36ae9b8f0037
    line: 144
    col: 0
    score: 0.87
  - uuid: 687439f9-ad1e-40a4-8a32-3a1b4ac7c017
    line: 16
    col: 0
    score: 0.87
  - uuid: cbfe3513-6a4a-4d2e-915d-ddfab583b2de
    line: 376
    col: 0
    score: 0.87
  - uuid: 5e8b2388-022b-46cf-952c-36ae9b8f0037
    line: 159
    col: 0
    score: 0.86
  - uuid: b4e64f8c-4dc9-4941-a877-646c5ada068e
    line: 348
    col: 0
    score: 0.86
  - uuid: ba244286-4e84-425b-8bf6-b80c4eb783fc
    line: 358
    col: 0
    score: 0.86
  - uuid: 513dc4c7-e045-4123-ba2e-cf5ef0b7b4a3
    line: 106
    col: 0
    score: 0.86
  - uuid: 9a8ab57e-507c-4c6b-aab4-01cea1bc0501
    line: 129
    col: 0
    score: 0.86
  - uuid: 5e8b2388-022b-46cf-952c-36ae9b8f0037
    line: 176
    col: 0
    score: 0.85
  - uuid: ad7f1ed3-c9bf-4e85-9eeb-6cc4b53155f3
    line: 232
    col: 0
    score: 0.85
---
**Good.** ^ref-af5d2824-1-0
Because that‚Äôs the *right* thing to be building right now ‚Äî especially for someone working with Sibilant at this level. Most "prompt engineering" out there is low-effort hackery. You're in a position to build a **real system** ‚Äî a **Lisp-based meta-prompt DSL** that treats LLMs like **programmable agents** inside a multi-runtime meta-environment.

You're not prompt-engineering. You're **prompt-compiling**. ^ref-af5d2824-4-0

---

## üß† What You‚Äôre Really After

You're building a: ^ref-af5d2824-10-0

> **Composable, programmable meta-language that emits structured prompts, interprets structured responses, and maintains persistent semantic state between calls.** ^ref-af5d2824-12-0

With Sibilant macros and namespaces, that DSL can: ^ref-af5d2824-14-0

* Describe instructions, constraints, examples ^ref-af5d2824-16-0
* Include function calls and runtime context ^ref-af5d2824-17-0
* Manage memory + metadata ^ref-af5d2824-18-0
* Generate prompts for **different LLMs** ^ref-af5d2824-19-0
* Support streaming, tool use, and *reflective* prompting

---

## üî∞ High-Level DSL Example (Sketch)

```sibilant
(prompt
  :role "system"
  :persona "assistant"
  :context "User is building a Lisp-based multi-runtime agent system"
  :goals [
    "Suggest improvements to DSL syntax"
    "Generate code blocks in Sibilant"
  ]
  :examples [
    (q "How do I create a cross-language interface?")
    (a "(definterface ...)")
  ]
  :input
    "Design a macro system for emitting structured JSON from prompts"
)
```
^ref-af5d2824-26-0
 ^ref-af5d2824-44-0
This compiles to a full prompt string with structure + context + memory injection.

---

## üß∞ Core Concepts
 ^ref-af5d2824-50-0
| Feature           | Sibilant Construct        |
| ----------------- | ------------------------- |
| Prompt definition | `(prompt ...)` macro      |
| Message role      | `:role` or `(system ...)` |
| User inputs       | `(input "...")`           |
| Examples          | `(example q a)` pairs     |
| Output type hint  | `:expects "json"`         |
| Target model      | `(model "gpt-4o")`        |
| Runtime modifiers | `(tool "python")`         |
| Streaming control | `(stream true)`           |

---

## üß¨ Possible DSL Macros

### Define a prompt block:
 ^ref-af5d2824-67-0
```sibilant
(macro prompt (...entries)
  (compile-prompt entries))
^ref-af5d2824-67-0
```

### Role messages: ^ref-af5d2824-74-0

```sibilant
(macro system (text) `(:role "system" :content ,text))
(macro user (text)   `(:role "user"   :content ,text))
^ref-af5d2824-74-0
(macro assistant (text) `(:role "assistant" :content ,text))
```
 ^ref-af5d2824-82-0
### Examples:

```sibilant
^ref-af5d2824-82-0
(macro example (q a)
  `(:example (:q ,q) (:a ,a)))
```

--- ^ref-af5d2824-91-0

## üß± Compiler Output Example ^ref-af5d2824-93-0

From:

```sibilant
(prompt
^ref-af5d2824-93-0
  (system "You are a smart prompt compiler.") ^ref-af5d2824-100-0
  (user "Turn this into JSON: foo = 1")
  :expects "json")
```
^ref-af5d2824-102-0

To:

```json
^ref-af5d2824-102-0
[ ^ref-af5d2824-109-0
  { "role": "system", "content": "You are a smart prompt compiler." },
  { "role": "user",   "content": "Turn this into JSON: foo = 1" }
]
^ref-af5d2824-109-0
```
^ref-af5d2824-109-0 ^ref-af5d2824-116-0

And meta fields:

```json
{
  "model": "gpt-4o",
  "temperature": 0.2,
  "expects": "json"
^ref-af5d2824-123-0
} ^ref-af5d2824-125-0
^ref-af5d2824-125-0
``` ^ref-af5d2824-123-0
^ref-af5d2824-120-0
^ref-af5d2824-125-0
^ref-af5d2824-123-0
^ref-af5d2824-120-0 ^ref-af5d2824-131-0

--- ^ref-af5d2824-133-0
 ^ref-af5d2824-131-0
## üîÑ Bi-directional: Prompt + Response Interpretation
 ^ref-af5d2824-131-0 ^ref-af5d2824-133-0
You can define a schema for responses:
^ref-af5d2824-125-0
 ^ref-af5d2824-131-0
```sibilant
(response-schema
  (field :command string)
^ref-af5d2824-137-0
  (field :args list)) ^ref-af5d2824-139-0
^ref-af5d2824-140-0
^ref-af5d2824-139-0
^ref-af5d2824-146-0 ^ref-af5d2824-147-0
^ref-af5d2824-140-0 ^ref-af5d2824-148-0
^ref-af5d2824-139-0 ^ref-af5d2824-149-0
^ref-af5d2824-137-0 ^ref-af5d2824-150-0
^ref-af5d2824-133-0 ^ref-af5d2824-140-0
``` ^ref-af5d2824-137-0

^ref-af5d2824-147-0 ^ref-af5d2824-148-0
^ref-af5d2824-146-0 ^ref-af5d2824-149-0
Then call: ^ref-af5d2824-139-0 ^ref-af5d2824-150-0 ^ref-af5d2824-156-0
 ^ref-af5d2824-140-0 ^ref-af5d2824-157-0
```sibilant ^ref-af5d2824-158-0
(parse-response result :with schema) ^ref-af5d2824-146-0 ^ref-af5d2824-159-0
``` ^ref-af5d2824-147-0
 ^ref-af5d2824-148-0 ^ref-af5d2824-161-0
Eventually, you can compile: ^ref-af5d2824-149-0 ^ref-af5d2824-156-0
 ^ref-af5d2824-146-0 ^ref-af5d2824-150-0 ^ref-af5d2824-157-0
* **Sibilant** ‚Üí **Prompt** ^ref-af5d2824-147-0 ^ref-af5d2824-158-0
* **LLM Output** ‚Üí **MetaObject** or runtime calls ^ref-af5d2824-148-0 ^ref-af5d2824-159-0
 ^ref-af5d2824-149-0
--- ^ref-af5d2824-150-0 ^ref-af5d2824-161-0

## üöÄ You Can Build: ^ref-af5d2824-156-0 ^ref-af5d2824-169-0
 ^ref-af5d2824-157-0
* A prompt compiler (`prompt ‚Üí string`) ^ref-af5d2824-158-0
* A prompt interpreter (`response ‚Üí data`) ^ref-af5d2824-159-0
* A prompt tracer/logger (for auditing / training) ^ref-af5d2824-156-0 ^ref-af5d2824-173-0
* A language-model agent orchestrator (multi-call, looping, reflection) ^ref-af5d2824-157-0 ^ref-af5d2824-161-0
* A template ‚Üí macro expander (for slot-filling templates) ^ref-af5d2824-158-0 ^ref-af5d2824-169-0
 ^ref-af5d2824-159-0 ^ref-af5d2824-176-0
---

## üèÅ Suggested Next Steps ^ref-af5d2824-173-0

^ref-af5d2824-161-0
* Define `(prompt ...)` as a macro that collects prompt blocks + metadata ^ref-af5d2824-169-0
^ref-af5d2824-176-0
* Define a `compile-prompt` function to emit structured messages
* Add `(model ...)`, `(expects ...)`, `(example ...)` helpers
* Pipe it into your REPL runtime like:
 ^ref-af5d2824-169-0 ^ref-af5d2824-173-0
  ```sibilant
  (llm:call (prompt ...))
  ``` ^ref-af5d2824-176-0
 ^ref-af5d2824-173-0
---

## üè∑Ô∏è Tags ^ref-af5d2824-176-0 ^ref-af5d2824-194-0

\#sibilant #dsl #llm #meta-prompting #promptcompiler #agentarchitecture #macros #llmintrospection #reflection #promethean

---

Let me know: ^ref-af5d2824-194-0
Want to sketch `compile-prompt` and a basic `(prompt ...)` macro now? Or start with defining the role/message primitives and build up?

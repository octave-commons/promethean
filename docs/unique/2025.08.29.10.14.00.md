Got it — you don’t want to hand-maintain 3 (soon 4) different configs. One EDN → Codex TOML, Codex JSON, VS Code JSON, **and** Elisp.

We can extend the generator so your same `codex_mcp.edn` produces an `mcp-servers.el` you can `(load)` into Emacs. It will just translate each entry into a `setq` entry in `mcp-server-programs`.

---

### EDN stays the same

```edn
{:mcp-servers
 {:duckduckgo  {:command "/home/err/devel/promethean/scripts/mcp/bin/duck.sh"}
  :file-system {:command "/home/err/devel/promethean/scripts/mcp/bin/filesystem.sh"}
  :github      {:command "/home/err/devel/promethean/scripts/mcp/bin/github.sh"}
  :github-chat {:command "/home/err/devel/promethean/scripts/mcp/bin/github_chat.sh"}
  :obsidian    {:command "/home/err/devel/promethean/scripts/mcp/bin/obsidian.sh"}
  :sonarqube   {:command "/home/err/devel/promethean/scripts/mcp/bin/sonarqube.sh"}}}
```

---

### Extend `mcp-compile.clj`

Add a fourth output for Elisp:

```clojure
(defn render-elisp-entry [[k spec]]
  (let [name-str (ensure-str k "server name")
        cmd      (ensure-str (:command spec) ":command")
        args     (vec (map #(ensure-str % ":args") (:args spec)))]
    (format "  (\"%s\" . (\"%s\"%s))"
            name-str cmd
            (if (seq args)
              (str " " (pr-str args))
              ""))))

(defn render-elisp [servers]
  (str ";;; mcp-servers.el --- generated, do not edit\n"
       "(setq mcp-server-programs\n"
       "      '(\n"
       (str/join "\n" (map render-elisp-entry servers))
       "\n      ))\n"))
```

Then in `-main`, after writing TOML/JSON:

```clojure
;; 4) Elisp (mcp.el expects `mcp-server-programs`)
(spit elisp-out (render-elisp servers))
(println "  " elisp-out)
```

Adjust the `-main` arg list:

```clojure
(defn -main [& [in codex-toml codex-json vscode-json elisp-out]]
  (when (or (nil? in) (nil? codex-toml) (nil? codex-json) (nil? vscode-json) (nil? elisp-out))
    (binding [*out* *err*]
      (println "usage: bb ./mk/mcp-compile.clj <input.edn> <codex.toml> <codex.json> <vscode.json> <elisp.el>")
      (System/exit 2)))
  ;; … as before …
)
```

---

### Example Elisp output

`mcp-servers.el` will look like:

```elisp
;;; mcp-servers.el --- generated, do not edit
(setq mcp-server-programs
      '(
  ("duckduckgo" . ("/home/err/devel/promethean/scripts/mcp/bin/duck.sh"))
  ("file-system" . ("/home/err/devel/promethean/scripts/mcp/bin/filesystem.sh"))
  ("github" . ("/home/err/devel/promethean/scripts/mcp/bin/github.sh"))
  ("github-chat" . ("/home/err/devel/promethean/scripts/mcp/bin/github_chat.sh"))
  ("obsidian" . ("/home/err/devel/promethean/scripts/mcp/bin/obsidian.sh"))
  ("sonarqube" . ("/home/err/devel/promethean/scripts/mcp/bin/sonarqube.sh"))
      ))
```

---

### Emacs usage

Drop into init:

```elisp
(load "/home/err/devel/promethean/mcp-servers.el")
(require 'mcp)
(setq mcp-auto-start t)
```

Now your Emacs, Codex, VS Code, and universal JSON all come from **one EDN file**.

---

Want me to show you how to fold this into a `bb.edn` so you can just run `bb generate-mcp` and get all 4 files (TOML, Codex JSON, VS Code JSON, Elisp) in one go?

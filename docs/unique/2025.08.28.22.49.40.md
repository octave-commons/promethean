Got it — let’s make the *one true* task frontmatter so robots (and you) can dump files into `docs/agile/tasks/` and everything “just works.”

I’ll give you:

1. a **strict YAML frontmatter schema** (fields + constraints)
2. a **minimal required template** for LLMs/agents
3. a **full template** with all the useful fields, including hashtags
4. a tiny **TS validator** (JSON Schema + CLI) so you can hard-fail bad tasks

---

# 1) Frontmatter schema (YAML)

* **All tasks live at**: `docs/agile/tasks/<task-id>.md`
* **Frontmatter must appear at top**, wrapped in `---` fences.
* **State enum** is your board’s canonical states.

```yaml
# REQUIRED (robots must fill all of these)
task-id: "TASK-YYYYMMDD-hhmmss-xxxx"    # unique, stable; you can accept any string matching /^TASK-/ if you want
title: "Human-friendly, action-oriented"
state: "New"                             # One of:
                                         # IceBox | New | Accepted | Breakdown | PromptRefine | AgentThinking |
                                         # Blocked | Ready | Todo | InProgress | InReview | Document | Done | Rejected
txn: "2025-08-28T22:51:04Z-7f3a"         # ISO8601 + random suffix (producer-generated)

# STRONGLY RECOMMENDED
owner: "err"                             # who is on point now
priority: "p3"                           # p0 | p1 | p2 | p3 | p4
size: "s"                                 # xs | s | m | l | xl (t-shirt sizing)
epic: "EPC-000"                          # optional grouping
depends_on: []                            # list of task ids or PRs/links

# OPTIONAL but useful
labels: []                                # freeform tags (machine-friendly)
due: null                                 # ISO date or null
links: []                                 # URLs relevant to the task (issues, PRs, docs)
artifacts: []                             # file paths created by agents (design, diffs, reports)
rationale: ""                             # short “why this exists” (1–4 sentences)
proposed_transitions: []                  # e.g., ["New->Accepted","Accepted->Breakdown"]

# The board repair mechanism relies on these hashtags being duplicated below the frontmatter.
hashtags:
  - "task/TASK-YYYYMMDD-hhmmss-xxxx"
  - "board/kanban"
  - "state/New"
  - "owner/err"
  - "priority/p3"
  - "epic/EPC-000"
```

> Skeptical note: if agents can’t keep `hashtags` in sync, your reconciler should regenerate them from the other fields. Still, make them write them — redundancy is intentional.

---

# 2) Minimal **robot** template (copy/paste into your LLM system prompt)

```yaml
---
task-id: TASK-{{YYYYMMDD-hhmmss}}-{{rand4}}
title: "<imperative title: verb + object>"
state: New
txn: "{{ISO8601}}-{{rand4}}"
owner: err
priority: p3
size: m
epic: EPC-000
depends_on: []
labels: []
due:
links: []
artifacts: []
rationale: "<2–4 sentences explaining the why. Avoid fluff.>"
proposed_transitions: ["New->Accepted","Accepted->Breakdown"]
hashtags:
  - task/TASK-{{YYYYMMDD-hhmmss}}-{{rand4}}
  - board/kanban
  - state/New
  - owner/err
  - priority/p3
  - epic/EPC-000
---
```

Then body:

```
## Context
<short background; bullets OK>

## Definition of Done
- [ ] measurable outcome 1
- [ ] measurable outcome 2

## Plan (draft)
1) step
2) step
```

---

# 3) **Full** task note template (for humans or smarter agents)

```
---
task-id: TASK-{{YYYYMMDD-hhmmss}}-{{rand4}}
title: "<verb> <thing> <qualifier>"
state: New
prev:
txn: "{{ISO8601}}-{{rand4}}"
owner: err
priority: p3
size: m
epic: EPC-000
depends_on: []
labels: ["board:auto", "lang:ts"]
due:
links: []
artifacts: []
rationale: "<why this matters in 1–4 sentences>"
proposed_transitions: ["New->Accepted","Accepted->Breakdown"]
hashtags:
  - task/TASK-{{YYYYMMDD-hhmmss}}-{{rand4}}
  - board/kanban
  - state/New
  - owner/err
  - priority/p3
  - epic/EPC-000
---

## Context
- What changed?
- Where?
- Why now?

## Inputs / Artifacts
- (link or path)

## Definition of Done
- [ ] test X passes
- [ ] doc Y updated
- [ ] PR merged: <link>

## Plan
1. …
2. …

## Notes
- …
```

* `prev:` is filled by your **move** tool; robots can omit it on creation.
* Your move tool should always update `state`, `prev`, `txn`, and refresh `hashtags` accordingly.

---

# 4) JSON Schema + tiny validator (TypeScript)

Drop these in `@shared/ts/dist/tasks/` (adjust to your import path rules).

```ts
// @shared/ts/dist/tasks/schema.ts
export const TaskFrontmatterSchema = {
  type: "object",
  required: ["task-id","title","state","txn","owner","priority","size","hashtags"],
  additionalProperties: true,
  properties: {
    "task-id": { type: "string", pattern: "^TASK-" },
    "title": { type: "string", minLength: 3 },
    "state": { type: "string", enum: [
      "IceBox","New","Accepted","Breakdown","PromptRefine","AgentThinking",
      "Blocked","Ready","Todo","InProgress","InReview","Document","Done","Rejected"
    ]},
    "prev": { type: ["string","null"] },
    "txn": { type: "string", minLength: 8 },
    "owner": { type: "string", minLength: 1 },
    "priority": { type: "string", enum: ["p0","p1","p2","p3","p4"] },
    "size": { type: "string", enum: ["xs","s","m","l","xl"] },
    "epic": { type: ["string","null"] },
    "depends_on": { type: "array", items: { type: "string" } },
    "labels": { type: "array", items: { type: "string" } },
    "due": { type: ["string","null"] },
    "links": { type: "array", items: { type: "string" } },
    "artifacts": { type: "array", items: { type: "string" } },
    "rationale": { type: "string" },
    "proposed_transitions": { type: "array", items: { type: "string", pattern: "^[A-Za-z]+->[A-Za-z]+$" } },
    "hashtags": { type: "array", minItems: 3, items: { type: "string" } }
  }
} as const;
```

```ts
// services/ts/cli/validate-task.ts
import fs from "fs";
import matter from "gray-matter";
import Ajv from "ajv";
import { TaskFrontmatterSchema } from "@shared/ts/dist/tasks/schema";

const ajv = new Ajv({ allErrors: true, allowUnionTypes: true });

function fail(msg: string) { console.error(msg); process.exit(1); }

const path = process.argv[2];
if (!path) fail("Usage: validate-task <path-to-task.md>");

const raw = fs.readFileSync(path, "utf8");
const fm = matter(raw).data;

const validate = ajv.compile(TaskFrontmatterSchema);
if (!validate(fm)) {
  console.error("Frontmatter invalid:");
  for (const err of validate.errors ?? []) {
    console.error(`- ${err.instancePath} ${err.message}`);
  }
  process.exit(2);
}

// Optional: cross-check hashtags mirror state/owner/priority
const tags = new Set<string>(fm.hashtags || []);
const expect = [
  `task/${fm["task-id"]}`,
  "board/kanban",
  `state/${fm.state}`,
  `owner/${fm.owner}`,
  `priority/${fm.priority}`
];
const missing = expect.filter(t => !tags.has(t));
if (missing.length) {
  console.warn("Hashtag desync; will auto-fix on next move:", missing);
}

console.log("OK:", fm["task-id"]);
```

* Use this in CI and in your **sweeper** that picks up new tasks.
* If you want hard guarantees, make the sweeper *refuse* to ingest tasks that fail validation.

---

# Practical defaults for robots

* **States on creation**: `New` (or `Accepted` if it’s a breakdown proposal with solid rationale + artifacts).
* **Priority default**: `p3`
* **Size default**: `m`
* **Owner default**: `err`
* **Hashtags** must include (at minimum):
  `task/<id>`, `board/kanban`, `state/<state>`

If an agent can’t produce `txn`, you generate it at ingest: `UTC_ISO + "-" + short-rand`.

---

# Sanity checks your sweeper should enforce

* Filenames must equal `<task-id>.md`; if not, rename.
* Frontmatter present? If missing, **reject** and create a “Fix malformed task” issue.
* Unknown state? Force `New` and add label `needs:state-confirm`.
* If `state == Done`, require at least one `links` or `artifacts` entry. Otherwise downgrade to `InReview`.

No coddling. Bad inputs get bounced.

---

If you want, I can generate a *seed* set of 3 example tasks (New, Breakdown→Ready, Blocked) using this frontmatter so your agents have concrete exemplars to learn from.

\#hashtags
\#promethean #kanban #frontmatter #obsidian #markdown #board-automation #schema #llm-agent #validator #ruthless-standards

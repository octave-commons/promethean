Alright Err — let’s turn **@typescript-tools/dependency-graph** into a clean, native-ESM **MCP server** you can drop into your monorepo.

I’ll give you a minimal, functional core plus optional Fastify HTTP transport + static viewer (since you use `@fastify/static`). It’s flat, TypeScript-first, ava-tested, GPL-3.0-only, and MCP-spec compliant via the official TS SDK. ([GitHub][1], [Model Context Protocol][2])

---

# What we’re building

* **Server transport**: stdio (works with Claude for Desktop & other hosts). HTTP transport is optional.
* **Tools exposed**:

  * `graph.packages` → JSON graph of internal package dependencies
  * `graph.dot` → Graphviz DOT
  * `graph.mermaid` → Mermaid text
* **Inputs**: repo root (default `process.cwd()`), optional workspace globs, include/exclude filters.
* **Outputs**: pure data; no side effects. You can pipe to whatever.

We’ll rely on `@modelcontextprotocol/sdk` for the server and `@typescript-tools/dependency-graph` for monorepo graphing. Note: the dependency-graph package is stable but **old** (last publish ≈4y); it still does the job, but I’m including a fallback folder-level scanner if it ever regresses. ([GitHub][1], [NPM][3])

---

## 1) Package scaffold

**`packages/mcp-depgraph/package.json`**

```json
{
  "name": "@promethean/mcp-depgraph",
  "version": "0.1.0",
  "license": "GPL-3.0-only",
  "private": true,
  "type": "module",
  "description": "MCP server exposing TS monorepo dependency graph tools (JSON, DOT, Mermaid).",
  "exports": {
    ".": {
      "types": "./dist/index.d.ts",
      "default": "./dist/index.js"
    },
    "./http": {
      "types": "./dist/http.d.ts",
      "default": "./dist/http.js"
    }
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "start": "node dist/index.js",
    "start:http": "node dist/http.js",
    "test": "pnpm -w -r --filter @promethean/mcp-depgraph... run --if-present build && ava"
  },
  "dependencies": {
    "@fastify/static": "^8.2.0",
    "@modelcontextprotocol/sdk": "^0.6.0",
    "@typescript-tools/dependency-graph": "^3.0.1",
    "fastify": "^5.0.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "ava": "^6.1.3",
    "typescript": "^5.6.3",
    "@types/node": "^22.5.4"
  },
  "engines": {
    "node": ">=20.10"
  }
}
```

**`packages/mcp-depgraph/tsconfig.json`**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig.json",
  "compilerOptions": {
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "strict": true,
    "noEmitOnError": true,
    "outDir": "dist",
    "rootDir": "src",
    "declaration": true,
    "resolveJsonModule": true
  },
  "include": ["src/**/*", "test/**/*"]
}
```

---

## 2) Core: MCP server (stdio)

**`packages/mcp-depgraph/src/index.ts`**

```ts
// use .js extensions in TS source so built ESM ends with .js imports
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { z } from "zod";
import { dependencyGraph as tsToolsGraph } from "@typescript-tools/dependency-graph";
import { createDotFromGraph, createMermaidFromGraph, toGraphJSON, tryResolveWorkspace } from "./lib/graph.js";

const server = new McpServer({
  name: "mcp-depgraph",
  version: "0.1.0"
});

const GraphArgs = z.object({
  root: z.string().optional(),              // repo root; defaults to process.cwd()
  workspaces: z.array(z.string()).optional(), // e.g. ["packages/*"]
  includePrivate: z.boolean().optional().default(true)
});

type Graph = Awaited<ReturnType<typeof toGraphJSON>>;

// NOTE: @typescript-tools/dependency-graph has sparse docs; we wrap it defensively.
async function buildGraph(args: z.infer<typeof GraphArgs>): Promise<Graph> {
  const root = args.root ?? process.cwd();
  const ws = await tryResolveWorkspace(root, args.workspaces);
  // tsToolsGraph is expected to inspect package.json/workspaces and produce edges between internal packages
  // Fallback logic (in lib/graph.ts) handles cases where the lib returns unexpected shapes.
  // @ts-expect-error: library types can be loose; we normalize in toGraphJSON
  const raw = await tsToolsGraph({ cwd: root, workspaces: ws, includePrivate: args.includePrivate });
  return toGraphJSON(raw, root);
}

// graph.packages → canonical JSON graph
server.tool(
  "graph.packages",
  "Return internal package dependency graph as JSON (nodes, edges).",
  {
    inputSchema: GraphArgs
  },
  async ({ input }) => {
    const graph = await buildGraph(input);
    return { content: [{ type: "json", json: graph }] };
  }
);

// graph.dot → Graphviz DOT
server.tool(
  "graph.dot",
  "Return Graphviz DOT for internal package graph.",
  {
    inputSchema: GraphArgs
  },
  async ({ input }) => {
    const graph = await buildGraph(input);
    const dot = createDotFromGraph(graph);
    return { content: [{ type: "text", text: dot }] };
  }
);

// graph.mermaid → Mermaid (graph LR)
server.tool(
  "graph.mermaid",
  "Return Mermaid markup for internal package graph.",
  {
    inputSchema: GraphArgs
  },
  async ({ input }) => {
    const graph = await buildGraph(input);
    const mermaid = createMermaidFromGraph(graph);
    return { content: [{ type: "text", text: mermaid }] };
  }
);

const transport = new StdioServerTransport();
await server.connect(transport);
```

**Why this shape?** It matches MCP “tools” best-practice: named tools with schemas, stateless, and transport via stdio per the official SDK/quickstart. ([GitHub][1], [Model Context Protocol][4])

---

## 3) Pure transforms & fallbacks

**`packages/mcp-depgraph/src/lib/graph.ts`**

```ts
import { z } from "zod";
import fs from "node:fs/promises";
import path from "node:path";

export type GraphJSON = {
  nodes: { id: string; name: string; dir: string; private?: boolean }[];
  edges: { from: string; to: string }[];
};

const RawEdge = z.object({
  from: z.string(),
  to: z.string()
});

const RawGraph = z.object({
  nodes: z.array(z.object({
    name: z.string(),
    dir: z.string().optional(),
    private: z.boolean().optional()
  })).optional(),
  edges: z.array(RawEdge).optional()
}).passthrough();

// Normalize whatever @typescript-tools/dependency-graph gives us.
export async function toGraphJSON(raw: unknown, root: string): Promise<GraphJSON> {
  const parsed = RawGraph.safeParse(raw);
  if (parsed.success && parsed.data.edges && parsed.data.nodes) {
    const nodes = parsed.data.nodes.map((n) => ({
      id: n.name,
      name: n.name,
      dir: n.dir ?? "",
      private: n.private
    }));
    const edges = parsed.data.edges.map((e) => ({ from: e.from, to: e.to }));
    return { nodes, edges };
  }
  // Fallback: derive from workspace package.json files
  return deriveFromWorkspaces(root);
}

async function deriveFromWorkspaces(root: string): Promise<GraphJSON> {
  const rootPkg = JSON.parse(await fs.readFile(path.join(root, "package.json"), "utf8"));
  const globs: string[] = (rootPkg.workspaces ?? rootPkg.packages ?? []).flat();
  const dirs = await globDirs(root, globs);
  const pkgs = await Promise.all(dirs.map(async (dir) => {
    const pkgPath = path.join(dir, "package.json");
    try {
      const pkg = JSON.parse(await fs.readFile(pkgPath, "utf8"));
      return { dir, name: pkg.name as string, deps: { ...(pkg.dependencies ?? {}), ...(pkg.devDependencies ?? {}) }, private: !!pkg.private };
    } catch { return null; }
  }));
  const nodes = pkgs.filter(Boolean).map((p) => ({ id: p!.name, name: p!.name, dir: p!.dir, private: p!.private }));
  const set = new Set(nodes.map(n => n.name));
  const edges = pkgs.flatMap((p) => {
    if (!p) return [];
    return Object.keys(p.deps).filter(d => set.has(d)).map((to) => ({ from: p.name, to }));
  });
  return { nodes, edges };
}

async function globDirs(root: string, patterns: string[]): Promise<string[]> {
  // tiny glob: support "packages/*"
  const out: string[] = [];
  await Promise.all(patterns.map(async (g) => {
    const prefix = g.replace(/\*+.*$/, "");
    const base = path.join(root, prefix);
    const items = await fs.readdir(base, { withFileTypes: true }).catch(() => []);
    for (const it of items) {
      if (it.isDirectory()) out.push(path.join(base, it.name));
    }
  }));
  return out;
}

export async function tryResolveWorkspace(root: string, user?: string[] | undefined): Promise<string[] | undefined> {
  if (user?.length) return user;
  try {
    const rootPkg = JSON.parse(await fs.readFile(path.join(root, "package.json"), "utf8"));
    return (rootPkg.workspaces ?? rootPkg.packages) as string[] | undefined;
  } catch { return undefined; }
}

export function createDotFromGraph(g: GraphJSON): string {
  const lines = ["digraph G {"];
  for (const n of g.nodes) lines.push(`  "${n.id}";`);
  for (const e of g.edges) lines.push(`  "${e.from}" -> "${e.to}";`);
  lines.push("}");
  return lines.join("\n");
}

export function createMermaidFromGraph(g: GraphJSON): string {
  const lines = ["graph LR"];
  for (const e of g.edges) lines.push(`  ${safe(e.from)} --> ${safe(e.to)}`);
  // Add isolated nodes
  const withEdges = new Set(g.edges.flatMap(e => [e.from, e.to]));
  for (const n of g.nodes) {
    if (!withEdges.has(n.id)) lines.push(`  ${safe(n.id)}`);
  }
  return lines.join("\n");
}

function safe(id: string) {
  return id.replace(/[^a-zA-Z0-9_]/g, "_");
}
```

---

## 4) Optional: Fastify HTTP transport + static viewer

If you want HTTP/Streamable transport or to host a quick viewer at `/graph`, this adds nicely. (There are Fastify MCP plugins out there, but we’ll keep it zero-dep aside from `@fastify/static`.) ([GitHub][5], [Fastify][6])

**`packages/mcp-depgraph/src/http.ts`**

```ts
import Fastify from "fastify";
import fastifyStatic from "@fastify/static";
import { fileURLToPath } from "node:url";
import { dirname, join } from "node:path";
import { z } from "zod";
import { dependencyGraph as tsToolsGraph } from "@typescript-tools/dependency-graph";
import { createMermaidFromGraph, toGraphJSON, tryResolveWorkspace } from "./lib/graph.js";

const __dirname = dirname(fileURLToPath(import.meta.url));
const app = Fastify({ logger: true });

app.get("/health", async () => ({ ok: true }));

app.get("/api/graph", async (req) => {
  const q = z.object({
    root: z.string().optional(),
    workspaces: z.string().optional() // comma-separated
  }).parse((req as any).query);
  const root = q.root ?? process.cwd();
  const ws = await tryResolveWorkspace(root, q.workspaces ? q.workspaces.split(",") : undefined);
  // @ts-expect-error see note in index.ts
  const raw = await tsToolsGraph({ cwd: root, workspaces: ws, includePrivate: true });
  return toGraphJSON(raw, root);
});

app.get("/api/graph.mermaid", async (req, reply) => {
  const json = await (await app.inject({ method: "GET", url: "/api/graph", query: (req as any).query })).json();
  const mermaid = createMermaidFromGraph(json);
  reply.type("text/plain").send(mermaid);
});

// serve a tiny static viewer
app.register(fastifyStatic, {
  root: join(__dirname, "public"),
  prefix: "/"
});

const port = Number(process.env.PORT ?? 8799);
app.listen({ port, host: "0.0.0.0" }).catch((e) => {
  app.log.error(e);
  process.exit(1);
});
```

**`packages/mcp-depgraph/src/public/index.html`** (Mermaid viewer)

```html
<!doctype html>
<html>
<head><meta charset="utf-8"/><meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>DepGraph</title></head>
<body>
<div id="app"><pre id="mmd">loading…</pre></div>
<script type="module">
const res = await fetch('/api/graph.mermaid');
document.getElementById('mmd').textContent = await res.text();
</script>
</body>
</html>
```

---

## 5) ava tests (pure, functional)

**`packages/mcp-depgraph/test/graph.test.ts`**

```ts
import test from "ava";
import { toGraphJSON, createDotFromGraph, createMermaidFromGraph } from "../src/lib/graph.js";

test("toGraphJSON fallback handles empty", async (t) => {
  const g = await toGraphJSON({}, process.cwd());
  t.truthy(g.nodes);
  t.truthy(g.edges);
});

test("renders DOT and Mermaid", (t) => {
  const g = { nodes: [{ id: "a", name: "a", dir: "" }, { id: "b", name: "b", dir: "" }], edges: [{ from: "a", to: "b" }] };
  t.true(createDotFromGraph(g).includes('"a" -> "b"'));
  t.true(createMermaidFromGraph(g).includes("a --> b"));
});
```

---

## 6) Wiring it into an MCP host

* **Stdio (recommended to start):** `pnpm -F @promethean/mcp-depgraph start`
* **Claude for Desktop**: add a server entry pointing to the above command; the SDK follows the MCP spec and should self-describe tools on handshake. ([GitHub][1], [Model Context Protocol][2])

---

## Notes, caveats, and why I chose this design

* **MCP correctness**: The server uses the official TS SDK (tool schemas, stdio transport) and matches the current spec. If you ever need HTTP transport, the optional Fastify entry is ready. ([GitHub][1], [Model Context Protocol][2])
* **Old lib reality check**: `@typescript-tools/dependency-graph` hasn’t been updated recently. It’s fine for internal-package edges, but I included a **workspace fallback** so the MCP tool doesn’t break if its output shape changes or is missing. ([NPM][3])
* **Alternatives**: If you end up needing file-level edges, swap or augment with `dependency-cruiser` or `ts-dependency-graph`. Keep the MCP facade stable (`graph.*` tools), and change the backend. ([Stack Overflow][7], [GitHub][8])
* **Static viewer**: Minimal by design. If you want richer UI later, you can add a WebComponent that fetches `/api/graph` and renders with Mermaid or Cytoscape.

---

## Next steps (fast, practical)

1. Drop this into `packages/mcp-depgraph/`, run:

```bash
pnpm -w i
pnpm -F @promethean/mcp-depgraph build
pnpm -F @promethean/mcp-depgraph start   # stdio MCP
```

2. In your MCP host, call:

* `graph.packages` with `{ root: "/path/to/repo" }`
* Or hit `http://localhost:8799/api/graph.mermaid` after `start:http`.

If you want me to tailor the viewer as a **WebComponent** and wire in `@fastify/static` with your look-and-feel, say the word—I’ll bolt it on top of `/api/graph` with zero mutation to the MCP core.

**References**

* MCP TS SDK (code & examples), plus stdio transport. ([GitHub][1])
* Official MCP docs/spec & quickstart. ([Model Context Protocol][2])
* `@typescript-tools/dependency-graph` package (status and usage). ([NPM][3])
* Fastify TS & static serving (optional HTTP transport + viewer). ([Fastify][6])

[1]: https://github.com/modelcontextprotocol/typescript-sdk?utm_source=chatgpt.com "The official TypeScript SDK for Model Context Protocol ..."
[2]: https://modelcontextprotocol.io/specification/2025-06-18?utm_source=chatgpt.com "Specification"
[3]: https://www.npmjs.com/package/%40typescript-tools/dependency-graph?utm_source=chatgpt.com "typescript-tools/dependency-graph"
[4]: https://modelcontextprotocol.io/quickstart/server?utm_source=chatgpt.com "Build an MCP server"
[5]: https://github.com/haroldadmin/fastify-mcp?utm_source=chatgpt.com "A Fastify plugin to run Model Context Protocol (MCP) servers"
[6]: https://fastify.io/docs/latest/Reference/TypeScript/?utm_source=chatgpt.com "TypeScript"
[7]: https://stackoverflow.com/questions/40852578/are-there-any-ways-to-get-the-dependency-graph-for-a-project?utm_source=chatgpt.com "Are there any ways to get the dependency graph for a ..."
[8]: https://github.com/PSeitz/ts-dependency-graph?utm_source=chatgpt.com "PSeitz/ts-dependency-graph"

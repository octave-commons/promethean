makes sense — keep the “Custom Instructions” tiny and push the details into repo files. Here’s a **compact bootstrap** you can paste into Custom Instructions, plus two short agent files (Cloud vs CLI) you can drop in the repo today.

---

# Paste this into Custom Instructions (short bootstrap)

```markdown
# Codex Bootstrap

Read repo guidance from `docs/agents/<agent>.md` (default: `codex-cloud.md`).

Artifacts:
- Treat `docs/reports/codex_cloud/latest/` as BASELINE_DIR.
- Use `{INDEX.md, summary.tsv, eslint.json}` for status.
- Only run `run/codex_maintenance.sh` if `latest/` is missing/stale or to create a post-change CURRENT_DIR; time-box it with `TIMEOUT_SECS=90 STRICT=0`. **Never** run `run/setup_codex_dev_env.sh`.

Working rules:
- Prefer TypeScript; new modules in `packages/<name>`. Idempotent + cache-aware.
- Use `gh` to find/create an issue and reference it in your PR.

Deltas (after edits, if you produced CURRENT_DIR):
- NEW/FIXED ESLint = set-diff of `file:line:col:ruleId` between CURRENT and BASELINE.
- Build/Test must not regress; touched packages must pass `pnpm --filter @promethean/<pkg> build`.
- `pnpm install` must succeed at end.
```

That’s \~8–10 lines and stays within most limits.

---

# Add these two files to the repo

## `docs/agents/codex-cloud.md` (focused, time-boxed, artifact-aware)

````markdown
# Codex Cloud Agent

## Baseline
- Read `docs/reports/codex_cloud/latest/{INDEX.md,summary.tsv,eslint.json}` as BASELINE.
- If `latest/` missing or older than ~8h, you MAY run:
  ```bash
  TIMEOUT_SECS=${TIMEOUT_SECS:-90} STRICT=0 bash run/codex_maintenance.sh
````

(never run `run/setup_codex_dev_env.sh`)

## While working

* Prefer TypeScript. New modules in `packages/<name>`. Keep scripts idempotent & cached.
* Use `gh` to find/create an issue; reference it in the PR.
* Lint touched files frequently:

  ```bash
  git diff --name-only --diff-filter=ACMRTUXB origin/main...HEAD \
    | grep -E '\.(ts|tsx)$' \
    | xargs -r pnpm exec eslint --cache --max-warnings=0
  ```

## Create CURRENT artifacts (optional, time-boxed)

* To compare your changes:

  ```bash
  TIMEOUT_SECS=${TIMEOUT_SECS:-90} STRICT=0 bash run/codex_maintenance.sh
  ```

  This writes a timestamped run and updates `docs/reports/codex_cloud/latest/`.

## Compare vs baseline

* NEW/FIXED ESLint by set-diff on `file:line:col:ruleId` from `eslint.json`.
* Build/Test RCs from `summary.tsv` rows:

  * build: `nx-affected-build|pnpm-build`
  * test:  `nx-affected-test`
* Gates before completion:

  * No **new** ESLint errors.
  * Touched packages pass `pnpm --filter @promethean/<pkg> build`.
  * No **new** test failures.
  * `pnpm install` succeeds.

## PR

* Reference the issue and link `docs/reports/codex_cloud/latest/INDEX.md`.

````

---

## `docs/agents/codex-cli.md` (leaner, assumes local dev; no environment management)

```markdown
# Codex CLI Agent

## Baseline (if present)
- If `docs/reports/codex_cloud/latest/` exists, use its `{INDEX.md,summary.tsv,eslint.json}` as BASELINE.
- Do **not** run setup. You may run maintenance **only** if you need CURRENT artifacts and it’s fast:
  ```bash
  TIMEOUT_SECS=${TIMEOUT_SECS:-60} STRICT=0 bash run/codex_maintenance.sh
````

## While working

* TypeScript-first; new code under `packages/<name>`. Keep builds idempotent/cached.
* Quick lint on touched files (fast loop):

  ```bash
  git diff --name-only --diff-filter=ACMRTUXB origin/main...HEAD \
    | grep -E '\.(ts|tsx)$' \
    | xargs -r pnpm exec eslint --cache --max-warnings=0
  ```
* For builds, target only touched packages:

  ```bash
  pnpm --filter @promethean/<pkg> build
  ```

## Optional CURRENT artifacts

* If you need a delta versus baseline:

  ```bash
  TIMEOUT_SECS=${TIMEOUT_SECS:-60} STRICT=0 bash run/codex_maintenance.sh
  ```

  Then diff `eslint.json` sets and check `summary.tsv` RCs.

## Completion gates

* No **new** ESLint errors; touched packages build; no **new** test failures; `pnpm install` passes.
* Open PR referencing an issue; link `docs/reports/codex_cloud/latest/INDEX.md` if you ran maintenance.

```

---

# Tiny loader (optional) to pick Cloud vs CLI

If you want a single knob, set `CODEX_AGENT=cloud|cli`. Here’s a minimal TS helper you can re-use anywhere:

```

packages/codex-instructions/src/index.ts

````

```ts
import { readFileSync } from "node:fs";
import { join } from "node:path";

export function loadAgentInstructions(agent = process.env.CODEX_AGENT ?? "cloud") {
  const file = agent === "cli" ? "codex-cli.md" : "codex-cloud.md";
  const p = join(process.cwd(), "docs", "agents", file);
  return readFileSync(p, "utf8");
}
````

Use it however your host loads instructions (or skip this and just set the file path in your tool).

---

# Why this helps right now

* **Custom Instructions stay short** (bootstrap only).
* **Cloud vs CLI** differences live in separate files; easy to tweak later.
* **No generation step** required; you can add the generator later if you want.
* Respects your **time limits** and uses the fast **maintenance** path only when needed.

Want me to trim either agent file even further for an even stricter CI budget?

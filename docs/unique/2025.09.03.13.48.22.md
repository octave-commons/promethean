---
uuid: a3f90105-1b27-4511-8ce1-ffe17886be52
created_at: 2025.09.03.13.48.22.md
filename: YAML's Hidden Dangers and Practical Fixes
description: >-
  This document explains why YAML is often a source of errors despite its
  popularity, highlighting key pitfalls like invisible semantics, implicit
  typing, and tooling inconsistencies. It provides actionable steps to minimize
  risks, including using strict parsing, schema validation, and preferring
  simpler alternatives like JSON or TOML when possible.
tags:
  - YAML
  - configuration
  - error prevention
  - JSON
  - TOML
  - schema validation
  - type safety
  - configuration management
---
Short answer: three humans—Clark Evans, Ingy döt Net, and Oren Ben-Kiki—around 2001. It stuck because humans hate braces, ops folks loved whitespacey INI-on-steroids, and then Kubernetes, Ansible, and half the CI world made it non-optional.

Blunt truth: YAML’s a foot-gun factory.

* Invisible semantics: spaces matter, tabs explode, trailing commas forbidden.
* Implicit typing (esp. 1.1): `on`, `yes`, `no`, `2020-01-01` silently become booleans/dates.
* Too many features: anchors/aliases/merge keys/blocks—parsers disagree, security holes happen.
* Tooling drift: many libs still behave like 1.1 even if you think you’re on 1.2.

Your earlier error (“All collection items must start at the same column”) is the core sin: indentation is the parser.

What to do (practical, minimal pain):

1. Keep YAML dumb: only for flat key→value or short lists. Anything complex? Don’t.
2. Force 1.2 semantics where you can; quote anything that looks like bool/date.
3. Lint + format:

   * `yamllint` (structure) + Prettier (format). Fail CI if either complains.
4. Validate schemas, not vibes:

   * Parse YAML → JSON → validate with JSON Schema (AJV) or Zod. Treat YAML as a string transport, not a type system.
5. Avoid anchors/aliases/merge unless you absolutely need them. Duplication beats cleverness here.
6. Prefer alternatives for real config:

   * **JSON** (boring, good), **TOML** (readable, sane), **TS/ESM** config w/ Zod (typed, composable), or **CUE/Dhall** if you want declarative + validation.

Tiny TS helper (ESM, functional, no mutation) to make YAML less dangerous:

```ts
// packages/config-utils/src/readYaml.ts (type:module; NodeNext)
import { readFile } from 'node:fs/promises';
import { parseDocument } from 'yaml';
import { z } from 'zod';

export const readYaml = async <T>(
  filePath: string,
  schema: z.ZodType<T>
): Promise<T> => {
  const text = await readFile(filePath, 'utf8');
  const doc = parseDocument(text, { version: '1.2', prettyErrors: true });
  if (doc.errors.length) {
    const msg = doc.errors.map(e => e.message).join('\n');
    throw new Error(`YAML parse error in ${filePath}:\n${msg}`);
  }
  const data = doc.toJSON(); // lose YAML weirdness here
  return schema.parse(data);
};
```

Use it like:

```ts
import { z } from 'zod';
import { readYaml } from '@promethean/config-utils/readYaml.js';

const Pipelines = z.object({
  pipelines: z.array(z.object({
    name: z.string(),
    steps: z.array(z.object({
      id: z.string(),
      shell: z.string(),
      inputs: z.array(z.string()).optional(),
      outputs: z.array(z.string()).optional(),
      deps: z.array(z.string()).optional(),
      cwd: z.string().optional(),
      env: z.record(z.string()).optional(),
    })),
  })),
});

const cfg = await readYaml('pipelines.yml', Pipelines);
```

Bottom line: YAML “won” by inertia and ergonomics, not because it’s good. Use it where it’s harmless; validate ruthlessly; jump to TS/TOML/JSON when it isn’t.

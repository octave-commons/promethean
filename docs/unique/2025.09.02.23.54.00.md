---
uuid: 7c3ee67a-f458-464f-9b5e-92f1c0ea8366
created_at: '2025-09-02T23:54:00Z'
filename: Promethean Monorepo Law
title: Promethean Monorepo Law
description: >-
  A set of strict rules for managing a monorepo with flat package structure, no
  fake aliases, native ESM, and specific licensing and static serving
  requirements.
tags:
  - monorepo
  - flat packages
  - ESM
  - native modules
  - GPL-3.0
  - static serving
  - alias rewrite
related_to_uuid:
  - 71a4afd6-e483-4a6e-a284-ff726e733399
  - 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
  - f9e200b4-742d-4786-ae2c-017996d53caf
  - 6f13f134-7536-4bc3-b695-5aaa2906bb9d
  - a09a2867-7f5a-4864-8150-6eee881a616b
  - 854fd616-8f36-4cf4-b06e-e0a597808404
  - 3e74aac4-d652-4ba2-be14-524d5dfb98f1
  - e9aece2c-221c-44fc-9bc3-83c591c8e74d
  - d975dfe2-e98e-40b1-9df0-fcd13161e951
  - bdca8ded-0e64-417b-a258-4528829c4704
related_to_title:
  - Monorepo Constitution Guard
  - Promethean Code Principles
  - level-cache
  - shared-package-layout-clarification
  - pr-688-nitpack-extract
  - Promethean Constitution CLI
  - Promethean CI/CD Pipeline
  - promethean-qdrant-demo
  - minimal-typescript-qdrant-demo
  - Pure TypeScript Search Microservice
references:
  - uuid: 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
    line: 13
    col: 0
    score: 1
  - uuid: 71a4afd6-e483-4a6e-a284-ff726e733399
    line: 175
    col: 0
    score: 0.98
  - uuid: a09a2867-7f5a-4864-8150-6eee881a616b
    line: 118
    col: 0
    score: 0.91
  - uuid: f9e200b4-742d-4786-ae2c-017996d53caf
    line: 40
    col: 0
    score: 0.91
  - uuid: 6f13f134-7536-4bc3-b695-5aaa2906bb9d
    line: 88
    col: 0
    score: 0.91
  - uuid: 9f8f8fb9-9bc4-49a4-b565-ee31a0d2503c
    line: 15
    col: 0
    score: 0.9
---
# Promethean Monorepo Law (final)

1. **Flat packages**
   `packages/` is **flat**. Every subfolder is a real package/service. No nesting like `packages/tools/...`. Period.

2. **No TS “paths”, no fake aliases**
   If it isn’t a real workspace package or a Node/HTML import map, you don’t import it. Ever.

3. **Native ESM everywhere**

* **Node** packages: `"type":"module"`, `module: "NodeNext"`, `moduleResolution: "NodeNext"`, `moduleDetection: "force"`.
* **Browser** packages (no bundler): `module: "ESNext"`, `moduleResolution: "Bundler"`, `verbatimModuleSyntax: true`.
* All **relative imports end with `.js`** after build (use `.js` in TS source).

4. **Licensing**
   All packages `"license": "GPL-3.0-only"`.

5. **Static serving**
   Use `@fastify/static`. Never embed HTML into backend files; keep templates in files under package `/public` (copied to `dist/` at build).

---

## A. Flat codemod package to fix aliases + add `.js` (drop-in)

**Path:** `packages/alias-rewrite/`

**packages/alias-rewrite/package.json**

```json
{
  "name": "@promethean/alias-rewrite",
  "version": "0.1.0",
  "type": "module",
  "license": "GPL-3.0-only",
  "bin": { "alias-rewrite": "dist/cli.js" },
  "scripts": { "build": "tsc -p tsconfig.json", "test": "ava" },
  "dependencies": { "fast-glob": "^3.3.2", "ts-morph": "^22.0.0" },
  "devDependencies": { "typescript": "^5.5.0", "ava": "^6.1.0" }
}
```

**packages/alias-rewrite/tsconfig.json**

```json
{
  "extends": "../../config/tsconfig.node.json",
  "compilerOptions": { "outDir": "dist", "rootDir": "src" },
  "include": ["src", "test"]
}
```

**packages/alias-rewrite/src/lib.ts**

```ts
import { existsSync } from "node:fs";
import { dirname, join } from "node:path";

type Rewrite = (from: string) => string | null;

export const mkAliasRewriter =
  (fromPrefix = "@shared/prom-lib", toPrefix = "@promethean-"): Rewrite =>
  (spec) => {
    if (!spec.startsWith(fromPrefix)) return null;
    const rest = spec.slice(fromPrefix.length).replace(/^\/+/, "");
    if (rest.length === 0) return "__ALIAS_REWRITE_ERROR__ROOT_IMPORT__";
    const [folder, ...tail] = rest.split("/");
    if (!folder) return "__ALIAS_REWRITE_ERROR__BAD_SEGMENT__";
    const newLeft = `${toPrefix}${folder}`;
    return [newLeft, ...tail].join("/");
  };

export const isRelative = (s: string): boolean =>
  s.startsWith("./") || s.startsWith("../");

const hasExt = (s: string): boolean => /\.[a-z]+$/i.test(s);
const toJs = (s: string): string =>
  /\.[mc]?tsx?$/.test(s) ? s.replace(/\.[mc]?tsx?$/i, ".js") : `${s}.js`;

const tryIndex = (absNoExt: string): string | null => {
  const idx = join(absNoExt, "index");
  const exts = [".ts", ".tsx", ".mts", ".cts", ".js", ".mjs", ".cjs"];
  const hit = exts.find((e) => existsSync(idx + e));
  return hit ? toJs(idx) : null;
};

export const mkRelativeToJs =
  (fromFile: string) =>
  (spec: string): string => {
    if (!isRelative(spec) || hasExt(spec)) return spec;
    const baseDir = dirname(fromFile);
    const absNoExt = join(baseDir, spec);
    const exts = [".ts", ".tsx", ".mts", ".cts", ".js", ".mjs", ".cjs"];
    const fileHit = exts.find((e) => existsSync(absNoExt + e));
    if (fileHit) return toJs(spec);
    const idx = tryIndex(absNoExt);
    if (idx) return `${spec.replace(/\/+$/, "")}/index.js`;
    return `${spec}.js`;
  };
```

**packages/alias-rewrite/src/cli.ts**

```ts
#!/usr/bin/env node
import fg from "fast-glob";
import { Project, SyntaxKind } from "ts-morph";
import { mkAliasRewriter, mkRelativeToJs } from "./lib.js";

type Args = { fromPrefix: string; toPrefix: string; globs: string[] };

const parseArgs = (argv: string[]): Args => {
  const fromIdx = argv.indexOf("--from");
  const toIdx = argv.indexOf("--to");
  const fromPrefix = fromIdx >= 0 ? argv[fromIdx + 1] : "@shared/prom-lib";
  const toPrefix = toIdx >= 0 ? argv[toIdx + 1] : "@promethean-";
  const globs = argv.filter((x) => !x.startsWith("--"));
  return { fromPrefix, toPrefix, globs };
};

const rewriteSpec = (
  spec: string,
  alias: ReturnType<typeof mkAliasRewriter>,
  relToJs: (s: string) => string,
  filePath: string
): string => {
  const aliasOut = alias(spec);
  if (aliasOut === "__ALIAS_REWRITE_ERROR__ROOT_IMPORT__") {
    throw new Error(`Root alias not allowed: "${spec}" in ${filePath}`);
  }
  if (aliasOut === "__ALIAS_REWRITE_ERROR__BAD_SEGMENT__") {
    throw new Error(`Bad alias segment in "${spec}" at ${filePath}`);
  }
  if (aliasOut) return aliasOut;
  if (spec.startsWith("./") || spec.startsWith("../")) return relToJs(spec);
  return spec;
};

const main = async () => {
  const { fromPrefix, toPrefix, globs } = parseArgs(process.argv.slice(2));
  const patterns = globs.length ? globs : ["packages/**/src/**/*.{ts,tsx,mts,cts}"];
  const ignore = ["**/node_modules/**", "**/dist/**", "**/.turbo/**", "**/.next/**"];

  const files = await fg(patterns, { ignore });
  const project = new Project({ skipAddingFilesFromTsConfig: true });
  files.forEach((f) => project.addSourceFileAtPath(f));

  const alias = mkAliasRewriter(fromPrefix, toPrefix);
  let changed = 0;

  for (const sf of project.getSourceFiles()) {
    const relToJs = mkRelativeToJs(sf.getFilePath());
    let touched = false;

    sf.getImportDeclarations().forEach((imp) => {
      const old = imp.getModuleSpecifierValue();
      const next = rewriteSpec(old, alias, relToJs, sf.getFilePath());
      if (next !== old) { imp.setModuleSpecifier(next); touched = true; }
    });

    sf.getExportDeclarations().forEach((exp) => {
      const ms = exp.getModuleSpecifierValue();
      if (!ms) return;
      const next = rewriteSpec(ms, alias, relToJs, sf.getFilePath());
      if (next !== ms) { exp.setModuleSpecifier(next); touched = true; }
    });

    sf.forEachDescendant((node) => {
      if (node.getKind() !== SyntaxKind.ImportCall) return;
      // @ts-ignore ts-morph dynamic
      const arg = node.getExpression().getArguments?.()[0];
      if (!arg || arg.getKind() !== SyntaxKind.StringLiteral) return;
      // @ts-ignore
      const lit = arg;
      const old = lit.getLiteralText();
      const next = rewriteSpec(old, alias, relToJs, sf.getFilePath());
      if (next !== old) { lit.setLiteralValue(next); touched = true; }
    });

    if (touched) { sf.saveSync(); changed++; }
  }

  console.log(JSON.stringify({ files: files.length, changed, fromPrefix, toPrefix }, null, 2));
};

main().catch((e) => { console.error(e.stack || e); process.exit(1); });
```

**packages/alias-rewrite/test/lib.test.ts**

```ts
import test from "ava";
import { mkAliasRewriter, mkRelativeToJs } from "../src/lib.js";
import { writeFileSync, mkdtempSync } from "node:fs";
import { tmpdir } from "node:os";
import { join } from "node:path";
import { mkdirSync } from "node:fs";

test("alias rewrite", (t) => {
  const r = mkAliasRewriter("@shared/prom-lib", "@promethean-");
  t.is(r("@shared/prom-lib/logger"), "@promethean-logger");
  t.is(r("@shared/prom-lib/utils/path/to/x"), "@promethean-utils/path/to/x");
  t.is(r("lodash"), null);
});

test("relative -> .js", (t) => {
  const dir = mkdtempSync(join(tmpdir(), "alias-"));
  const from = join(dir, "src/a.ts");
  mkdirSync(join(dir, "src"), { recursive: true });
  writeFileSync(from, "");
  writeFileSync(join(dir, "src/b.ts"), "");
  const f = mkRelativeToJs(from);
  t.is(f("./b"), "./b.js");
});

test("folder -> index.js if present", (t) => {
  const dir = mkdtempSync(join(tmpdir(), "alias-"));
  const from = join(dir, "src/a.ts");
  mkdirSync(join(dir, "src/foo"), { recursive: true });
  writeFileSync(from, "");
  writeFileSync(join(dir, "src/foo/index.ts"), "");
  const f = mkRelativeToJs(from);
  t.is(f("./foo"), "./foo/index.js");
});
```

**Root scripts (add to package.json)**

```json
{
  "scripts": {
    "codemod:aliases": "pnpm -w --filter @promethean/alias-rewrite... build && alias-rewrite --from @shared/prom-lib --to @promethean-",
    "check:flat": "node scripts/check-flat.js",
    "enforce:esm-ext": "eslint \"packages/**/src/**/*.{ts,tsx}\" --rule 'import/extensions: [2, \"always\", { ignorePackages: true }]'"
  }
}
```

**scripts/check-flat.js** (enforce “flat packages”)

```js
import { readdirSync, statSync } from "node:fs";
import { join } from "node:path";

const ROOT = "packages";
const ALLOWED = new Set(["src", "dist", "node_modules", ".turbo", "coverage"]);
let bad = [];

for (const pkg of readdirSync(ROOT)) {
  const full = join(ROOT, pkg);
  if (!statSync(full).isDirectory()) continue;
  for (const child of readdirSync(full)) {
    const p = join(full, child);
    if (statSync(p).isDirectory() && !ALLOWED.has(child)) {
      bad.push(p);
    }
  }
}

if (bad.length) {
  console.error("❌ Non-flat content inside package folders (only src/dist/... allowed):");
  for (const b of bad) console.error(" -", b);
  process.exit(1);
} else {
  console.log("✅ packages/ is flat.");
}
```

**ESLint guard** (add once at root, packages inherit/add)

```json
{
  "plugins": ["import"],
  "rules": {
    "import/extensions": ["error", "always", { "ignorePackages": true }],
    "import/no-unresolved": ["error", { "caseSensitive": true }]
  }
}
```

---

## B. One-pass fix order (do this, then build)

1. **Rewrite aliases & add `.js`**

```bash
pnpm codemod:aliases
```

2. **Kill any remaining `@shared/prom-lib`** (root-only imports)

```bash
rg -n "@shared/prom-lib['\"]?$"
```

Fix those manually to the correct `@promethean-<folder>`.

3. **Enforce flat & extensions**

```bash
pnpm run check:flat
pnpm run enforce:esm-ext
```

4. **Build all**

```bash
pnpm -r build
```

Now you’re looking at the *real* stragglers:

* **TS1308**: add `export {};` at top of the file with top-level await.
* **TS2339 `getParameters`**: narrow to function-like or call expression before calling methods.
* **TS2300 duplicates (mcp/stdio.ts)**: remove duplicate imports (pick one style).
* **TS2370 rest param**: `(...args: Type[])`.
* **TS2347 generic on untyped fn**: give the callee a proper generic signature.
* **TS2307 file-not-found**: usually a missed `.js` or wrong file actually not emitted.

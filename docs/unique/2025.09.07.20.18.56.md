Fair. CodeRabbit hates global monkey-patching and shared mutable state — and you’re doing both (by necessity) to capture `stdout/stderr` and tweak `process.env`. Let’s give the bot less ammo without throwing away the working design:

## Plan

* Keep **in-process** `runJSFunction` (ALS + serialization) — fastest path, needed for re-entrancy.
* Add **optional worker-isolation** for **JS modules** so there’s **no global mutation** in the main thread when you want console capture. Keep current in-proc module path as default for speed.
* Switch per step with `js.isolate: "worker"` (non-breaking; ignored unless set).

That way:

* CodeRabbit sees an isolated path that doesn’t touch globals.
* You still have the simple in-proc path when you want raw speed.

---

## 1) Add a worker implementation

Create `src/js-worker.ts`:

```ts
// src/js-worker.ts
import { parentPort, workerData } from "node:worker_threads";

type WorkerPayload = {
  modUrl: string;
  exportName?: string;
  args: any;
  env: Record<string, string>;
};

const { modUrl, exportName, args, env } = workerData as WorkerPayload;

let cleaned = false;
const origStdout = process.stdout.write.bind(process.stdout);
const origStderr = process.stderr.write.bind(process.stderr);
const origEnv: Record<string, string | undefined> = {};

function cleanup() {
  if (cleaned) return;
  cleaned = true;
  (process.stdout.write as any) = origStdout;
  (process.stderr.write as any) = origStderr;
  for (const [k, v] of Object.entries(origEnv)) {
    if (v === undefined) delete process.env[k];
    else process.env[k] = v;
  }
}

(process.stdout.write as any) = (chunk: any) => {
  parentPort?.postMessage({ type: "stdout", data: String(chunk) });
  return true;
};
(process.stderr.write as any) = (chunk: any) => {
  parentPort?.postMessage({ type: "stderr", data: String(chunk) });
  return true;
};

for (const [k, v] of Object.entries(env)) {
  origEnv[k] = process.env[k];
  process.env[k] = v;
}

(async () => {
  try {
    const mod: any = await import(modUrl);
    const fn =
      (exportName && mod && mod[exportName]) ||
      (mod && mod.default) ||
      mod;
    const res = await fn(args);
    if (typeof res === "string") {
      parentPort?.postMessage({ type: "stdout", data: res });
    }
    parentPort?.postMessage({ type: "done", code: 0 });
  } catch (err: any) {
    parentPort?.postMessage({
      type: "done",
      code: 1,
      error: err?.stack ?? String(err),
    });
  } finally {
    cleanup();
  }
})();
```

Build will output `js-worker.js`. (ESM-safe; no relative imports.)

---

## 2) Wire worker mode behind a flag

Patch your runner to support both modes. Keep your **existing** in-proc `runJSModule` as default. Add a worker variant and dispatch on `step.js.isolate`.

```ts
// at top
import { Worker } from "node:worker_threads";
import { pathToFileURL } from "url";

// ...

async function runJSModuleWorker(
  modPath: string,
  exportName: string | undefined,
  args: any,
  env: Record<string, string>,
  timeoutMs?: number,
) {
  const modUrl = pathToFileURL(modPath).href;
  return new Promise<{ code: number | null; stdout: string; stderr: string }>(
    (resolve) => {
      const worker = new Worker(new URL("./js-worker.js", import.meta.url), {
        workerData: { modUrl, exportName, args, env },
      });

      let stdout = "";
      let stderr = "";
      let timer: NodeJS.Timeout | undefined;
      let settled = false;

      const finish = (res: { code: number | null; stdout: string; stderr: string }) => {
        if (settled) return;
        settled = true;
        if (timer) clearTimeout(timer);
        resolve(res);
      };

      if (timeoutMs && timeoutMs > 0) {
        timer = setTimeout(() => {
          worker.terminate().finally(() =>
            finish({ code: 124, stdout, stderr: `${stderr}timeout` }),
          );
        }, timeoutMs);
      }

      worker.on("message", (m: any) => {
        if (m?.type === "stdout") stdout += String(m.data ?? "");
        else if (m?.type === "stderr") stderr += String(m.data ?? "");
        else if (m?.type === "done") {
          finish({
            code: typeof m.code === "number" ? m.code : 0,
            stdout,
            stderr: m.error ? stderr + m.error : stderr,
          });
        }
      });

      worker.on("error", (err) =>
        finish({ code: 1, stdout, stderr: stderr + (err?.stack ?? String(err)) }),
      );
      worker.on("exit", (code) => finish({ code, stdout, stderr }));
    },
  );
}
```

Now adapt your exported `runJSModule`:

```ts
export async function runJSModule(
  step: PiperStep,
  cwd: string,
  env: Record<string, string>,
  timeoutMs?: number,
) {
  const modPath = path.isAbsolute(step.js!.module)
    ? step.js!.module
    : path.resolve(cwd, step.js!.module);

  // opt-in isolation: (step.js as any).isolate === "worker"
  if ((step.js as any)?.isolate === "worker") {
    // No envMutex needed; worker has its own process.env
    return runJSModuleWorker(
      modPath,
      step.js!.export,
      step.js!.args ?? {},
      env,
      timeoutMs,
    );
  }

  // default: existing in-proc path (fast path)
  const url = pathToFileURL(modPath).href;
  await envMutex.acquire();
  const prevEnv: Record<string, string | undefined> = {};
  for (const [k, v] of Object.entries(env)) {
    prevEnv[k] = process.env[k];
    process.env[k] = v;
  }
  let timer: NodeJS.Timeout | undefined;
  try {
    const mod: any = await import(url);
    const fn = (step.js!.export && mod[step.js!.export]) || mod.default || mod;
    const call = fn(step.js!.args ?? {});
    const res = timeoutMs
      ? await Promise.race([
          call,
          new Promise((_, reject) =>
            (timer = setTimeout(() => reject(new Error("timeout")), timeoutMs)),
          ),
        ])
      : await call;
    const out = typeof res === "string" ? res : "";
    return { code: 0, stdout: out, stderr: "" };
  } catch (err: any) {
    return { code: 1, stdout: "", stderr: String(err?.stack ?? err) };
  } finally {
    if (timer) clearTimeout(timer);
    for (const [k, v] of Object.entries(prevEnv)) {
      if (v === undefined) delete process.env[k];
      else process.env[k] = v;
    }
    envMutex.release();
  }
}
```

No API break; adding `js.isolate: "worker"` in a step opts in.

---

## 3) One focused AVA test for worker mode

Add to your tests:

```ts
test.serial("runJSModule (worker isolate) captures console without leaking", async (t) => {
  await withTmp(async (dir) => {
    const modSrc = `
      export default async function({ msg }) {
        console.log("log:", msg);
        return "ret:" + msg;
      }
    `;
    const modPath = path.join(dir, "m.js");
    await fs.writeFile(modPath, modSrc, "utf8");

    const cfg = {
      pipelines: [{
        name: "w",
        steps: [{
          id: "w1",
          cwd: dir,
          deps: [],
          inputs: [],
          outputs: [],
          cache: "content",
          env: { WENV: "X" },
          js: { module: "./m.js", isolate: "worker", args: { msg: "ok" } },
        }],
      }],
    };
    const pipelinesPath = path.join(dir, "pipelines.yaml");
    await fs.writeFile(pipelinesPath, YAML.stringify(cfg), "utf8");
    const res = await runPipeline(pipelinesPath, "w", { concurrency: 2 });

    const step = res[0]!;
    t.is(step.exitCode, 0);
    t.true(step.stdout?.includes("log: ok"));
    t.true(step.stdout?.includes("ret:ok"));
    t.is(process.env.WENV, undefined); // no leak to parent
  });
});
```

---

## Why this calms CodeRabbit

* The **worker path** isolates `process.env` and stream overrides to the worker, not the parent process.
* The **in-proc path** remains for performance. It’s explicit that global patching happens only there, and you’ve already got serialization + cleanup to make it safe.
* Clear step-level switch (`js.isolate: "worker"`) makes intent obvious to reviewers and tools.

If you want, we can later auto-select worker mode when `timeoutMs` exceeds N ms or when `captureConsole: true` is requested — but keeping it explicit is simpler and review-friendly.

This code base is a mess right now. Leftover bits from... legacy? It was only a week ago.
And even that wasn't that far old either.


How should we refactor this?

```typescript
 export async function startDialog (bot: Bot, interaction: Interaction){
	if (bot.currentVoiceSession) {
		bot.desktop.start();
		await interaction.deferReply({ ephemeral: true });

		const discordAudioRef = bot.currentVoiceSession.getEcsAudioRef();
		bot.agentWorld = createAgentWorld(discordAudioRef);
		const { w, agent, C, addSystem } = bot.agentWorld;

		addSystem(
			OrchestratorSystem(
				w,
				bot.bus!,
				C,
				(text) => {
					return bot.context
						.compileContext([text])
						.then((msgs) => msgs.map((m) => ({ role: m.role as 'user' | 'assistant' | 'system', content: m.content })));
				},
				() => defaultPrompt,
			),
		);

		bot.agentWorld?.start(50);

		bot.currentVoiceSession.transcriber.on('transcriptEnd', (tr: FinalTranscript) => {
			const turnId = w.get(agent, C.Turn)?.id ?? 0;
			// const tf0 = w.get(agent, C.TranscriptFinal) ?? { text: "", ts: 0 };
			const tf = { text: tr.transcript, ts: Date.now() };
			w.set(agent, C.TranscriptFinal, tf);

			bot.bus?.publish({
				topic: 'agent.transcript.final',
				corrId: randomUUID(),
				turnId,
				ts: Date.now(),
				text: tr.transcript,
				channelId: bot.currentVoiceSession!.voiceChannelId,
				userId: tr.user?.id,
			});
		});

		const speaking = bot.currentVoiceSession.connection?.receiver.speaking;
		let lastLevel = -1;
		const onLevel = (level: number) => {
			if (level === lastLevel) return;
			lastLevel = level;
			const rv0 = w.get(agent, C.RawVAD) ?? { level: 0, ts: 0 };
			const rv = { ...rv0, level, ts: Date.now() };
			w.set(agent, C.RawVAD, rv);
		};
		speaking?.on('start', () => onLevel(1));
		speaking?.on('end', () => onLevel(0));
		bot.currentVoiceSession.transcriber.on('transcriptStart', () => onLevel(1)).on('transcriptEnd', () => onLevel(0));

		const qUtter = w.makeQuery({ all: [C.Utterance] });
		bot.currentVoiceSession.getPlayer().on(AudioPlayerStatus.Idle, () => {
			for (const [e, get] of w.iter(qUtter)) {
				const u = get(C.Utterance);
				if (u.status === 'playing') {
					w.set(e, C.Utterance, { ...u, status: 'done' });
				}
			}
		});
		// services/ts/cephalon/src/voiceCommands.ts  (inside startDialog, after you create player/world/etc.)

		// 1) Start transcribing everyone currently in the channel
		const voiceChan = await interaction.guild.channels.fetch(bot.currentVoiceSession.voiceChannelId);
		if (voiceChan?.isVoiceBased()) {
			for (const [, member] of voiceChan.members) {
				if (member.user.bot) continue;
				await bot.currentVoiceSession.addSpeaker(member.user);
				await bot.currentVoiceSession.startSpeakerTranscribe(member.user);
			}
		}

		// 2) Track joins/leaves dynamically while dialog is active
		if (bot.voiceStateHandler) bot.client.off(discord.Events.VoiceStateUpdate, bot.voiceStateHandler);
		bot.voiceStateHandler = (oldState, newState) => {
			const id = bot.currentVoiceSession?.voiceChannelId;
			const user = newState.member?.user || oldState.member?.user;
			if (!id || !user || user.bot) return;
			// joined target channel
			if (oldState.channelId !== id && newState.channelId === id) {
				bot.currentVoiceSession?.addSpeaker(user);
				bot.currentVoiceSession?.startSpeakerTranscribe(user);
			}
			// left target channel
			else if (oldState.channelId === id && newState.channelId !== id) {
				bot.currentVoiceSession?.stopSpeakerTranscribe(user);
				bot.currentVoiceSession?.removeSpeaker(user);
			}
		};
		bot.client.on(discord.Events.VoiceStateUpdate, bot.voiceStateHandler);
		bot.currentVoiceSession.transcriber.on('transcriptStart', () => onLevel(1)).on('transcriptEnd', () => onLevel(0));

		await interaction.deleteReply().catch(() => {});
	}
}
```

---
uuid: 06ef038a-e195-49c1-898f-a50cc117c59a
created_at: 2d-sandbox-field.md
filename: 2d-sandbox-field
title: 2d-sandbox-field
description: >-
  A 2D scalar vector field for testing node interactions, particle dynamics, and
  emergent behaviors without semantic layers. The field decays over time, nodes
  inject energy, and particles respond to field forces.
tags:
  - 2d
  - vector-field
  - simulation
  - particle-dynamics
  - field-decay
  - node-influence
  - emergent-behavior
related_to_uuid:
  - c7b8a045-45f2-42c4-9617-b0cda73ca3cf
  - fc21f824-4244-4030-a48e-c4170160ea1d
  - 13951643-1741-46bb-89dc-1beebb122633
  - 7cfc230d-8ec2-4cdb-b931-8aec26de2a00
  - 37b5d236-2b3e-4a95-a4e8-31655c3023ef
  - d28090ac-f746-4958-aab5-ed1315382c04
  - af5d2824-faad-476c-a389-e912d9bc672c
  - 64a9f9f9-58ee-4996-bdaf-9373845c6b29
  - 7bed0b9a-8b22-4b1f-be81-054a179453cb
  - e018dd7a-1fb7-4732-9e67-cd8b2f0831cf
  - 61d4086b-4adf-4e94-95e4-95a249cd1b53
  - ab54cdd8-13ce-4dcb-a9cd-da2d86e0305f
  - 687439f9-ad1e-40a4-8a32-3a1b4ac7c017
  - d2b3628c-6cad-4664-8551-94ef8280851d
  - 36c8882a-badc-4e18-838d-2c54d7038141
  - 5f210ca2-54e9-445b-afe4-fb340d4992c5
  - 01b21543-7e03-4129-8fe4-b6306be69dee
  - c34c36a6-80c9-4b44-a200-6448543b1b33
  - 49d1e1e5-5d13-4955-8f6f-7676434ec462
  - c5c5ff1c-d1bc-45c7-8a84-55a4a847dfc5
  - 63a1cc28-b85c-4ce2-b754-01c2bc0c0bc3
  - b362e12e-2802-4e41-9a21-6e0c7ad419a2
  - bc5172ca-7a09-42ad-b418-8e42bb14d089
  - 51932e7b-4237-4756-bcae-8be6d535d0d1
  - babdb9eb-3b15-48a7-8a22-ecc53af7d397
related_to_title:
  - i3-bluetooth-setup
  - Fnord Tracer Protocol
  - Duck's Attractor States
  - field-dynamics-math-blocks
  - homeostasis-decay-formulas
  - i3-config-validation-methods
  - Sibilant Meta-Prompt DSL
  - Layer1SurvivabilityEnvelope
  - polymorphic-meta-programming-engine
  - ParticleSimulationWithCanvasAndFFmpeg
  - sibilant-metacompiler-overview
  - markdown-to-org-transpiler
  - Matplotlib Animation with Async Execution
  - Language-Agnostic Mirror System
  - shared-package-layout-clarification
  - Cross-Target Macro System in Sibilant
  - compiler-kit-foundations
  - Cross-Language Runtime Polymorphism
  - EidolonField
  - lisp-dsl-for-window-management
  - 'Polyglot S-expr Bridge: Python-JS-Lisp Interop'
  - Ollama-LLM-Provider-for-Pseudo-Code-Transpiler
  - prom ui bootstrap
  - pm2-orchestration-patterns
  - Recursive Prompt Construction Engine
references:
  - uuid: c7b8a045-45f2-42c4-9617-b0cda73ca3cf
    line: 1
    col: 0
    score: 1
  - uuid: fc21f824-4244-4030-a48e-c4170160ea1d
    line: 471
    col: 0
    score: 0.92
  - uuid: 13951643-1741-46bb-89dc-1beebb122633
    line: 278
    col: 0
    score: 0.92
  - uuid: 7cfc230d-8ec2-4cdb-b931-8aec26de2a00
    line: 410
    col: 0
    score: 0.92
  - uuid: 37b5d236-2b3e-4a95-a4e8-31655c3023ef
    line: 460
    col: 0
    score: 0.92
  - uuid: d28090ac-f746-4958-aab5-ed1315382c04
    line: 28
    col: 0
    score: 0.91
  - uuid: af5d2824-faad-476c-a389-e912d9bc672c
    line: 120
    col: 0
    score: 0.9
  - uuid: 7bed0b9a-8b22-4b1f-be81-054a179453cb
    line: 190
    col: 0
    score: 0.9
  - uuid: 61d4086b-4adf-4e94-95e4-95a249cd1b53
    line: 52
    col: 0
    score: 0.9
  - uuid: fc21f824-4244-4030-a48e-c4170160ea1d
    line: 689
    col: 0
    score: 0.9
  - uuid: 64a9f9f9-58ee-4996-bdaf-9373845c6b29
    line: 341
    col: 0
    score: 0.9
  - uuid: e018dd7a-1fb7-4732-9e67-cd8b2f0831cf
    line: 414
    col: 0
    score: 0.9
  - uuid: 64a9f9f9-58ee-4996-bdaf-9373845c6b29
    line: 378
    col: 0
    score: 0.9
  - uuid: ab54cdd8-13ce-4dcb-a9cd-da2d86e0305f
    line: 272
    col: 0
    score: 0.89
  - uuid: 687439f9-ad1e-40a4-8a32-3a1b4ac7c017
    line: 44
    col: 0
    score: 0.89
  - uuid: d2b3628c-6cad-4664-8551-94ef8280851d
    line: 504
    col: 0
    score: 0.89
  - uuid: 5f210ca2-54e9-445b-afe4-fb340d4992c5
    line: 148
    col: 0
    score: 0.87
  - uuid: 36c8882a-badc-4e18-838d-2c54d7038141
    line: 161
    col: 0
    score: 0.87
  - uuid: 01b21543-7e03-4129-8fe4-b6306be69dee
    line: 588
    col: 0
    score: 0.87
  - uuid: c34c36a6-80c9-4b44-a200-6448543b1b33
    line: 211
    col: 0
    score: 0.87
  - uuid: 49d1e1e5-5d13-4955-8f6f-7676434ec462
    line: 205
    col: 0
    score: 0.86
  - uuid: c5c5ff1c-d1bc-45c7-8a84-55a4a847dfc5
    line: 185
    col: 0
    score: 0.86
  - uuid: 63a1cc28-b85c-4ce2-b754-01c2bc0c0bc3
    line: 490
    col: 0
    score: 0.86
  - uuid: b362e12e-2802-4e41-9a21-6e0c7ad419a2
    line: 151
    col: 0
    score: 0.86
  - uuid: bc5172ca-7a09-42ad-b418-8e42bb14d089
    line: 440
    col: 0
    score: 0.86
---
Awesome. This will be our **sandbox**‚Äîa 2D Eidolon field to test nodes, particles, and flows. No semantics, no layers‚Äîjust energy moving in space. ^ref-c710dc93-1-0

---

## üéØ Design Goals for the 2D Test Field

We want to observe: ^ref-c710dc93-7-0

1. **Field decay**: values fade out over time ^ref-c710dc93-9-0
    
2. **Field node influence**: nodes inject energy (like heat or gravity) ^ref-c710dc93-11-0
    
3. **Particle movement**: particles are attracted, repelled, or dragged by the field ^ref-c710dc93-13-0
    
4. **Emergent dynamics**: simple rules lead to complex behavior ^ref-c710dc93-15-0
    

Let‚Äôs start from the basics. ^ref-c710dc93-18-0

---

## üßä Field Structure

We'll define a 2D scalar vector field: ^ref-c710dc93-24-0

- Each cell has a 2D vector: `(vx, vy)` ^ref-c710dc93-26-0
    
- Optionally: a scalar "magnitude" field derived from the vector ^ref-c710dc93-28-0
    

```js
class Vector2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  add(other) { return new Vector2(this.x + other.x, this.y + other.y); }
  scale(f) { return new Vector2(this.x * f, this.y * f); }
  magnitude() { return Math.sqrt(this.x ** 2 + this.y ** 2); }
  normalize() { const m = this.magnitude(); return m === 0 ? new Vector2(0, 0) : this.scale(1 / m); }
}
```
^ref-c710dc93-31-0
 ^ref-c710dc93-44-0
```js
class Field2D {
  constructor(width, height) {
    this.width = width;
    this.height = height;
    this.grid = [...Array(height)].map(() =>
      [...Array(width)].map(() => new Vector2(0, 0))
    );
  }

  get(x, y) {
    return this.grid[y][x];
  }

  applyDecay(rate = 0.95) {
    for (let y = 0; y < this.height; y++) {
      for (let x = 0; x < this.width; x++) {
        this.grid[y][x] = this.grid[y][x].scale(rate);
      }
    }
  }

  inject(x, y, vector) {
    this.grid[y][x] = this.grid[y][x].add(vector);
  }
}
^ref-c710dc93-44-0
```

---

## üîπ Field Node ^ref-c710dc93-76-0

```js
class FieldNode {
  constructor(x, y, strength = 1.0, radius = 3) {
    this.x = x;
    this.y = y;
    this.strength = strength;
    this.radius = radius;
  }

  apply(field) {
    for (let dy = -this.radius; dy <= this.radius; dy++) {
      for (let dx = -this.radius; dx <= this.radius; dx++) {
        const tx = this.x + dx;
        const ty = this.y + dy;
        if (tx >= 0 && ty >= 0 && tx < field.width && ty < field.height) {
          const dir = new Vector2(dx, dy).normalize().scale(this.strength);
          field.inject(tx, ty, dir);
        }
      }
    }
  }
^ref-c710dc93-76-0
}
```
^ref-c710dc93-78-0

---
 ^ref-c710dc93-104-0
## ‚ö™ Particle

```js
class Particle {
  constructor(x, y, mass = 1.0, drag = 0.9) {
    this.position = new Vector2(x, y);
    this.velocity = new Vector2(0, 0);
    this.mass = mass;
    this.drag = drag;
  }

  update(field) {
    const fx = Math.floor(this.position.x);
    const fy = Math.floor(this.position.y);
    if (fx >= 0 && fy >= 0 && fx < field.width && fy < field.height) {
      const force = field.get(fx, fy).scale(1 / this.mass);
      this.velocity = this.velocity.add(force).scale(this.drag);
      this.position = this.position.add(this.velocity);
    }
^ref-c710dc93-104-0
  }
}
```
 ^ref-c710dc93-129-0
--- ^ref-c710dc93-129-0

## üîÅ Simulation Loop

```js
const field = new Field2D(40, 20);
const node = new FieldNode(20, 10, 0.5);
const particles = [new Particle(5, 5), new Particle(35, 15)];

function tick() {
  field.applyDecay(0.98);
^ref-c710dc93-129-0
  node.apply(field);
  particles.forEach(p => p.update(field));
}
^ref-c710dc93-133-0
```
 ^ref-c710dc93-145-0
---

## üñºÔ∏è Optional: Visualize It in ASCII ^ref-c710dc93-150-0

```js
function render(field, particles) {
  let buffer = "";
  for (let y = 0; y < field.height; y++) {
    for (let x = 0; x < field.width; x++) {
      const p = particles.find(p =>
        Math.floor(p.position.x) === x && Math.floor(p.position.y) === y
      );
      if (p) buffer += "‚óè";
      else {
        const mag = field.get(x, y).magnitude();
        buffer += mag > 0.3 ? "+" : mag > 0.1 ? "." : " ";
      }
    }
^ref-c710dc93-145-0
    buffer += "\n";
  }
  console.log(buffer);
^ref-c710dc93-150-0
}
``` ^ref-c710dc93-169-0
^ref-c710dc93-150-0
 ^ref-c710dc93-171-0
--- ^ref-c710dc93-171-0
 ^ref-c710dc93-173-0
## üß™ What This Lets Us Do ^ref-c710dc93-173-0
 ^ref-c710dc93-175-0
- Add multiple nodes (e.g., attractor + repulsor) ^ref-c710dc93-175-0
    
- Inject pulses over time (like an emotion spike)
    
- Observe particle clustering, spirals, escapes
 ^ref-c710dc93-180-0
- Build toward composite fields with multiple dimensions
 ^ref-c710dc93-182-0
 ^ref-c710dc93-184-0
--- ^ref-c710dc93-184-0
 ^ref-c710dc93-186-0
Would you like to: ^ref-c710dc93-186-0

- Port this to Sibilant as a first module for Promethean?
 ^ref-c710dc93-189-0
- Add a real-time canvas/WebGL or terminal UI to see it animate?
 ^ref-c710dc93-191-0 ^ref-c710dc93-192-0
- Begin testing types of particles (task, memory, emotion)? ^ref-c710dc93-192-0
 ^ref-c710dc93-193-0
 ^ref-c710dc93-194-0 ^ref-c710dc93-195-0
I recommend starting with a single `gravity-style attractor` node and a few drifting particles to make sure field decay and pull are working. Want to do that?

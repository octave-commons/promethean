I think you need to see the way I did it before. You've made a lot of improvements I like with this architecture, but I want to interface with it similarly to how I did before.

I had 3 ways which I could loop through components which avoided relooping, at the cost of a bit of extra memory to store some references.

This version did not work on a double buffer, but I wanted it to.

Entities were a wrapper around an ID, and as a convienience, they also held a list of references to the components which were assigned to them.

Components were (going to be) wrappers around a buffer view, and a set of getters to access properties on components for which the system depended on.
Systems were responsible for creating, updating, and
Entity groups systems of structurally similar entities
Units/Unit Groups were extendable "classes" to make it easy to create commonly used entity types, and actions you might take on that entity.
Unit groups encapsulated an entity group, I was intending the distinction between an entity group, and a unit group, to be that
There might be more than one entity group composed of the same type of unit "Think like a group of similar units belonging to a faction"
Like every member of a unit group were Identical, it represented the set of all entities which were created using that unit template
Every member of a group had to be similar, have a predetermined set of the same components.

The base System type was an abstract class which expected a Component interface object, an update function, and optionally
a `prepare` and a `cleanup` function

I didn't make it impossible to remove components from entities... but most of the time it just worked out that you just assigned an entity every
component it was going to need to function, and you just didn't do anything with it unless it was needed.

The unit/group abstraction was useful from inside of the systems to take actions/make decisions based on an entities structure, with out having to check it's structure, and member ship of the group.

If an entity needed a variable amount of something to do something, I would usually do it by just making that something into an entity type.

When I was doing this stuf... I'd always have one part of the other of the full vision, but tieing them all together, never happened.
Something always lived outside of the ECS in each game I made, this was difficult.

The way I got around stuff that was ephemeral, like one off vectors needed as an intermediary step, was to use object pools, or rather I created a "Spawnable" sub-type that basicly everything inherited from, and instead of calling "(new ClassName)" you created an object with "(.spawn ClassName)" and when you were done with it you called `(.despawn ClassName)`
As long as you remembered to despawn everything when you are done with it, I completely avoided GC churn between that for ephemeral variables, and the ECS for persistant data.

I started trying to figure out the double buffer approach for my agent systems, I made a 2d simulation of gravity with elastic collision, and I offloaded all the work to worker threads, and used KD trees to cluster them. That system, almost everything was double buffered, but I never got around to trying to rewrite the other simulations I made doing that. It was going to be  hard, but not impossilbe.

We'll get there. I at least have all of that code, and since it *is* more concise than say python, js, or ts, it fits in your context easier.
so... this isn't all of it, but it is a lot of it.

```lisp
(import Saveable "../saveable.js")

(define Spawnable Saveable
  (def build ()
    (.call Saveable.init this)
    (assign this.pool []))
  (def aquire ()
    (if (> this.pool.length 0)
        (.pop this.pool)
        (Object.create this))
    )
  (def spawn ((dots args))
    (.init (.aquire this) (dots args))
    )

  (def clear () (throw (new Error "No clear function defined for spawnable datatype")))

  (def despawn ()
    (.clear this)
    (.push this.pool this)))

(export Spawnable)

(macro accumulate (name ...body) `(assign @name (pipe @name ...@body)))

(require! R "ramda")

(import Ordered-map "../data-structures/maps/ordered.js")
(import Dynamic-pool "../pooling/dynamic-pool.js")
(import Group "../data-structures/group.js")
(import Interface "/shared/kit/interface/index.js")

(import Saveable "/shared/saveable.js")


(def spawn-component  (entity systems) (#-> systems.get (.spawn  entity)))

(def component-list  (entity) (R.map (spawn-component entity)))

(def remove (entity) (#-> (get 'system) (.clear entity)))

(var clear (#->  .clear))
(define Entity Saveable

  (doc "used as a key to retrieve related components from different systems.")

  (init (system id aspects (components (map aspects (aspect i)
                                            (pipe system.process.systems
                                                  (.get aspect)
                                                  (.spawn this))))))
  (gett entity this)

  (def-generic despawn (entity components )
    (.each entity.components (remove entity))
    (assign entity.id null))

  (def spawn (  aspects system) (.spawn system aspects )))

(def-generic Entity.despawn (entity components )
  (.release this.system.pool this  ))

(def-generic Entity.clear ()
  (each this.components (c)
        (.release c.system c)
        (assign c.entity null)
        )
  (assign this.components.length 0)
  (assign this.id null))

(export Entity)


(macro accumulate (name ...body) `(assign @name (pipe @name ...@body)))

(require! R "ramda")

(import Ordered-map "../data-structures/maps/ordered.js")
(import Dynamic-pool "../pooling/dynamic-pool.js")
(import Group "../data-structures/group.js")
(import Interface "/shared/kit/interface/index.js")

(import Saveable "/shared/saveable.js")

(def spawn-component  (entity systems) (#-> systems.get (.spawn  entity)))

(def component-list  (entity) (R.map (spawn-component entity)))

(def remove (entity) (#-> (get 'system) (.clear entity)))

(var clear (#->  .clear))
(define Entity-group Saveable

  (init (name aspects system (group ((create Group)))))
  (gett size this.group.size)

  (def-generic spawn ( aspects system group)
    (const self this)
    (collect e (.spawn system aspects )
             (assign e.group self)
             (.add group e)))

  (def-generic clear (group)
    (each group (entity) (.despawn entity))
    (.clear group))

  (def-generic has (entity group) (group.has entity))


  (def-generic despawn (entity group)
    (.remove group entity)
    (.despawn entity )))



(export Entity-group)

(macro accumulate (name ...body) `(assign @name (pipe @name ...@body)))

(require! R "ramda")

(import Saveable "/shared/saveable.js")
(import Ordered-map "../data-structures/maps/ordered.js")
(import Dynamic-pool "../pooling/dynamic-pool.js")
(import Group "../data-structures/group.js")
(import Interface "/shared/kit/interface/index.js")
(import Renderable "/shared/systems/rendering/renderable.js")


(def spawn-component  (entity systems) (#-> systems.get (.spawn  entity)))

(def component-list  (entity) (R.map (spawn-component entity)))

(def remove (entity) (#-> (get 'system) (.clear entity)))

(var clear (#->  .clear))
(def capitalize (string) (+ (.to-upper-case (.char-at string 0)) (.slice string 1)))
(def decapitalize (string) (+ (.to-lower-case (.char-at string 0)) (.slice string 1)))

(define Component Saveable
  (def register ()
    (doc-string "shared.ecs.Component.register"
                "no arguements"
                "An abstract function for subclassed components to optionally perform an action on creation."))

  (init (entity system)
        (set entity (decapitalize this.name) this)
        (.register this)))


(def-generic Component.clear (system)

  (if (not this.*clear)
      (throw (new Error "Clear function must be defined to relase from object pool.")))
  (this.*clear)
  (set this.entity (.to-lower-case this.name) null)
  (set this.entity this.name null)
  (set this.entity (decapitalize this.name) null))

(export Component)



(macro accumulate (name ...body) `(assign @name (pipe @name ...@body)))

(require! R "ramda")

(import Ordered-map "../data-structures/maps/ordered.js")
(import Dynamic-pool "../pooling/dynamic-pool.js")
(import Group "../data-structures/group.js")
(import Component "./component.js")
(import Interface "../kit/interface/index.js")

(import Saveable "/shared/saveable.js")


(def spawn-component  (entity systems) (#-> systems.get (.spawn  entity)))

(def component-list  (entity) (R.map (spawn-component entity)))

(def remove (entity) (#-> (get 'system) (.clear entity)))

(var clear (#->  .clear))
(define System Saveable
  (doc-string "Shared.ecs.ComponentSystem"
              "(process Component
                 (components ((create Ordered-map)))
                 (pool ((create Dynamic-pool)  Component))
                 (thread (Promise.resolve)))"
              "An Abstract interface for defining game systems."
              "By default updates its components every tick."
              "This behavior can be overriden."
              "Requires an" (pre *update-component) "implementation"
              "Optionally accepts" (pre *prepare) "and" (pre *cleanup) "methods"
              )
  (def register ()
    (doc-string "Shared.ecs.ComponentSystem.register"
                "no args"
                "Called by" (pre Component-system) "sub classes by initializer function."
                "## Example Usage"
                (example
                 (define New-component Component
                   (def I-need-somthing-from-my-system (x)
                     (assign this.dependent-property
                             (+ x this.system.needed-thing))
                     )
                   )
                 (define New-system Component-system
                   (def register ()

                     (assign this.needed-thing [])
                     (do-times 10 (.push this.needed-thing (Math.random))))))))


  (Component Component)
  (init (process Component
                 (components ((create Ordered-map)))
                 (pool ((create Dynamic-pool)  Component))
                 (thread (Promise.resolve)))
        (.register this))

  (gett system this)
  (template true)

  (gett game this.process)

  (def build ()
    (unless (or this.template )
      (.init this)))

  (def-generic clear (pool components entity )
    (.delete components entity)
    (.clear pool))

  (def-generic get (entity components)
    (.get components entity))
  (def release (c)
    (.delete this.components c.entity)
    (.release this.pool c))

  (def-generic spawn (entity pool components)
    (collect c (.spawn pool entity  this)
             (.set components entity c)))


  (def *update-component (component t)
    (throw (new Error "need to override *update-component on sub classes of component system")))

  (def *prepare () )
  (def *cleanup () )
  (def prepare () (.*prepare this))
  (def cleanup () (.*cleanup this))

  (def-generic *update-all (t components )
    (this.prepare)
    (.each components (fpipe (this.*update-component t)))
    (.cleanup this))

  (def update (t) (accumulate this.thread (then-do (.*update-all this t)))))



(def System.build ()
  (unless (or this.template )
    (.init this)))

(def-generic System.clear (pool components  )
  (.clear components)
  (.clear pool))

(def-generic System.get (entity components)
  (.get components entity))


(def System.update (t) (accumulate this.thread (then-do (.*update-all this t))))

(export System)

(import Spawnable "./data-structures/spawnable.js")
(import Entity-group "./ecs.js")
(import Position "./systems/position.js")
(import Physics "./systems/physics.js")
(import Interface "/shared/kit/interface/index.js")
(import Saveable "/shared/saveable.js")

(define Unit-instance Spawnable
  (init (entity group))
  (gett game this.group.game)
  (gett pos this.entity.position-interface)
  (gett physics this.entity.physical-properties)
  (gett scale this.physics.scale)
  (gett mass this.physics.mass)
  (def register ())
  (def clear ()
    (assign this.unit null
            this.group null)))
(export Unit-instance)

(define Unit-group Saveable
  (doc-string "Shared.Units.Unit-group"
              "

Name: Name of the unit group
types: A list of lists of components
Game: A game instance.
groups (optional): A list of entity groups associated with units in this group.
Allows for easy cross entity interactions.
Components: A list of components
"
              "
A physical thing in the world which interacts with other units.

There can be several types of units in a game, the most basic we will be considering for now are dynamic and static.

The only difference is one can move and the other cannot.

Possibilities for other distinctions later are:
Destructable
Neutral

"
              "
We've chosen to implement this layer of abstraction as an encapsulation of entity groups rather than an extension as we use the entity group and language around it on previous projects, and we don't want to break other projects just to implement this right here and now.

This may change as these are to be used instead of entity groups for the most part instead of along side. Though we may decide differntly.
"
              )
  (init (group-name component-types))

  (base-components [Position Physics])
  (instance-interface Unit-instance)
  (template true)

  (cached components (.flat [this.component-types this.base-components]))
  (cached group ((create Entity-group)
          (+ this.group-name "Unit")
          this.components
          this.game.ent))

  (def build ()
    (if (not this.template)
        (do (.init this)
            )
        )
    )
  (def spawn (...args)
    (const entity (.spawn this.group))
    (const unit (.spawn this.instance-interface entity this))
    (assign entity.unit unit)
    (for-of! c entity.components
             (assign c.unit unit))
    (.register unit ...args)
    (return unit))

  (def despawn (unit)
    (for-of! c unit.entity.components
             (assign c.unit null))
    (.despawn this.group unit.entity)
    (.despawn unit)))

(export Unit-group)

(import Physics "/shared/systems/physics.js")
(import Player-sprites "./systems/sprites/player.js")
(import Props-sprites "./systems/sprites/basic-props.js")
(import rendering "./rendering.js")
(import Velocity "/shared/systems/velocity.js")
(import Sight "./systems/sight.js")
(import Ground-types "./systems/floor-type.js")
(import Tile-visibility "./systems/visibility.js")
(import Path-finding "./systems/path-finding.js")
(import Metabolisim "./systems/metabolisim.js")
(import Containers "./systems/containers.js")
(import Mental-state "./systems/mental-state.js")
(import Item "./systems/item.js")
(import config "./config.js")
(import Floor-sprites "./systems/sprites/floor.js")
(import Cliff-sprites "./systems/sprites/cliff.js")
(import Unit-instance Unit-group "/shared/units.js")

(define Item-unit Unit-instance
  (gett data this.entity.item-interface)
  (gett container this.data.container)
  (def consume (entity)
    (.consume this.data entity)))
(export Item-unit)

(define Item-group Unit-group
  (instance-interface Item-unit)
  (template false)
  (group-name 'item)
  (component-types [Props-sprites Item ]))
(export Item-group)

(define Player-unit Unit-instance
  (gett sprite this.entity.player-sprite)
  (gett pathing this.entity-current-path)
  (gett mind-state this.entity.mind-state)
  (gett needs this.entity.needs)
  (gett los this.entity.field-of-view)
  (gett velocity this.entity.velocity-interface)
  (def eat (item)
    (.eat this.needs item)))
(export Player-unit)

(define Player Unit-group

  (template false)
  (instance-interface Player-unit)
  (group-name 'player)
  (component-types [Player-sprites Velocity Sight Path-finding Metabolisim Mental-state]))
(export Player)


(define Sprite-interface Component

  (def-generic register (dim system)
    (assign this.verts ((create Matrix-map) dim
                        (array-of (product-of dim)
                                  (.spawn system.verts )))))
  (frame-id 0),

  (delay 1) ;; number of ticks between frames

  (gett pos (.get Position this.entity))

  (gett dim this.data.dim),
  (gett image (.resolve Promise this.data.image)),
  (gett frame-count this.data.frame-count),
  (gett scale this.data.scale)
  (gett orientation this.data.orientation )

  (gett height (second this.dim))
  (gett width (first this.dim))

  (gett x this.pos.x)
  (gett y this.pos.y)

  (def-generic get-frame-pixel (i j bit-map width frame-id frame-count image)
    (.get  bit-map [(+ i (* width (mod   frame-id frame-count))) j]))

  (def-generic move-vertex (i j scale v pos height width orientation)
    (set v.point
         'x (mod (+ (- pos.x (/ (* width scale (first orientation)) 2))
                    (* i scale (first orientation)))
                 (first this.game.rendering.dimensions))

         'y (mod (+ (- pos.y (/ (* height scale (second orientation)) 2))
                    (* j scale (second orientation)))
                 (second this.game.rendering.dimensions))

         'z 0))

  (def set-color (v pixel)
    (set v.color
         'r pixel.r
         'g pixel.g
         'b pixel.b
         'a pixel.a))

  (def step () (assign this.frame-id (mod (+ this.frame-id 1) this.frame-count)))

  (def-generic draw (t verts image scale frame-id frame-count pos height width)
    (then image bit-map
          ( .each verts (=> (v [i j])
                            (var pixel (.get-frame-pixel this i j bit-map))

                            (.move-vertex this i j scale v)
                            (set v 'size scale)
                            (.set-color this v pixel))))))

(export Sprite-interface)

(define Sprite Component-system
  (def register ()
       (assign this.verts (.spawn this.game.rendering 1000000 Vertex
                                  [ uniforms.res uniforms.scale]
                                  [(vert-shader) fragment-shader-string])))
  (interface Sprite-interface)

  (def *update-component (sprite t) (.draw sprite t)))

(export Sprite)

(import System Component "/shared/ecs.js")
(import List "/shared/data-structures/list.js")
(import Vector "/shared/vectors.js")
(import config "../config.js")

(import Red-black-tree "/shared/data-structures/trees/red-black-tree.js")
(import simplex3 "/shared/noise.js")

(def-generic get-move-noise (x y t (force 16) (v (.spawn Vector 1 1)))
  (.set-angle v
              (* (simplex3 (/ x config.angle-zoom 5)
                                 (/ y config.angle-zoom 5)
                                 (* t (/ config.noise-z 10000)))
                 Math.PI 2))
  (const length (simplex3 (+ (/ x 50)
                                   40000)
                                (+ (/ x 50)
                                   40000)
                                (* t (/ config.noise-z 10000))))
  (.set-length v (* length force))
  v)
(define Mind-state Component
  (gett needs this.entity.needs)
  (gett hunger this.needs.hunger-efficiency-modifier)
  (gett is-hungry? this.needs.is-hungry?)
  (gett is-tired? this.needs.is-tired?)

  (gett tiredness this.needs.sleep-efficiency-modifier)
  (gett threat 0) ;; no enemies implemented yet.
  (gett tile (.get-closest-from-world-pos this.entity.current-path.system.tiles
                                  this.pos.x
                                  this.pos.y))
  (gett pos this.entity.position-interface)
  (gett explorative (/ 1
                       (+ this.hunger this.tiredness) ;; desire to explore is inversly proportionate the sum of needs.
                       ))
  (sett target t
        (assign this.entity.current-path.start this.tile)
        (assign this.entity.current-path.end t))
  (gett target this.entity.current-path.end)
  (gett visible-tiles this.entity.field-of-view.visible-tiles)
  (food (new Set))
  (known-food-items (.spawn Red-black-tree)))
(export Mind-state)

(define Mental-state System
  (Component Mind-state)
  (def add-visible-food-to-tree (c)
    (each c.visible-tiles (tile)
          (if (and tile.entity.container.objects.head
                   (not (.has c.food tile.entity.container.objects.head.item.item-interface))
                   (= tile.entity.container.objects.head.item.item-interface.type "food"))
              (do (.add c.food tile.entity.container.objects.head.item.item-interface)
                  (.set c.known-food-items (+ "" tile.world-pos.x tile.world-pos.y)
                        tile
                        ;; currently the only containers are tiles, and tiles can have at most 1 object.
                        )))))
  (def wakeup-starving (c)
    (do (assign c.needs.is-resting? false)
        (print "i'm starving, I have to wake up." c))
    )
  (def handle-tired (c)
    (assign c.needs.is-resting? true)
    (.set-length c.entity.velocity-interface.vector 0)
    (assign c.target null)
    (print "I'm tired, it's time to rest" c))
  (def handle-food-in-same-tile (c)
    (do (print "I'm hungry, and there's food right here" c)
        (c.tile.entity.container.objects.head.item.item-interface.consume
         c.entity)))
  (def handle-known-food-location (c items key)
    (print "I'm hungry and I know where food is")
    (assign c.target items.values.head.item)
    (.remove c.known-food-items key items.values.head.item))
  (def handle-explore-for-food (c)
    
    (print "I'm hungry and I don't know where food is.")
    (.explore-map this c))

  (def search-for-food (c )
    (const key (+ "" c.pos.x c.pos.y))
    ;; adding the coordinates together should
    ;; loosely correspond with the distance somthing is from that location
    ;; this is a hack to make the high level behavior work.
    ;; In the future, with more possible actions, and needs, and more ways to meat those needs, we will be using a meta heuristic vector system to quickly
    ;; find paths that solve a given set of problems, score them,
    ;; then weight them according to the agents current needs.

    (const items (.search c.known-food-items key))
    (if (and (not c.target) items.values.head)
        (.handle-known-food-location this c items key)
        (not c.target)
        (.handle-explore-for-food this c)))
  (def handle-hungry (c key)
    (assign c.known-food-items c.known-food-items.root)
    (if (c.tile.entity.container.has-type 'food)
        (.handle-food-in-same-tile this c)
        (not (c.tile.entity.container.has-type 'food))
        (.search-for-food this c)))
  (def explore-map (c)
    (var new-x c.entity.position-interface.x
         new-y c.entity.position-interface.y)

    (const search-limit 10)
    (var i 0)
    (until (or c.entity.current-path.end (> i search-limit ))
           (const noise-v (get-move-noise new-x new-y this.game.ticker.ticks (* 1.0 config.game-scale)))

           (incr i)
           (assign new-x (+ new-x (*  20 noise-v.x)))
           (assign new-y (+ new-y (*  20 noise-v.y)))
           (const tiles c.tile.graph)
           (const possible-end (.get-closest-from-world-pos tiles new-x new-y))
           (unless (or possible-end.entity.visible-status.explored?)
             (assign c.entity.current-path.start
                     (.get-closest-from-world-pos tiles c.entity.position-interface.x
                                                  c.entity.position-interface.y))
             (assign c.entity.current-path.end
                     possible-end))

           (.despawn noise-v)))
  (def *update-component (c)
    (.add-visible-food-to-tree this c)
    (if (and c.is-tired? (not c.is-hungry?) (not c.needs.is-resting?))
        (.handle-tired this c)
        (and c.needs.is-resting? c.needs.is-starving?)
        (.wakeup-starving this c)
        (and c.is-hungry? (not c.is-resting?))
        (.handle-hungry this c)
        (not c.needs.is-resting?)
        (.explore-map this c))))

(export Mental-state)

(namespace obstacles)

(import Time-limit Timer "/client/obstacles/systems/timer.js")

(import Red-black-tree "/shared/data-structures/trees/red-black-tree.js")
(import rgba "/client/obstacles/colors.js")
(import config "/client/obstacles/config.js")

(def-generic display-decimal (d (n 6)) (/ (Math.round (* (Math.pow 10 n) d)) (Math.pow 10 n)))

(define Trail-segment Time-limit
  (doc-string "obstacles.systems.ant-trails.Trail-vector"
              "inherits from shared.ecs.Component"
              "A time limited vector component that modifies the signal field when the ant has either succeeded or failed"
              "If the time limit expires, it disapears.")

  (duration config.trail-limit)

  ;; (def *clear ()
  ;;   (.call Time-limit.*clear this)
  ;;   ;; (assign this.duration config.trail-limit)
  ;;   )

  (update-view? true)
  (def-view view ()
    (.div .className "panel"
          "trail segment"
          (.div "pos:" (-> (display-decimal this.x 2)) "," (-> (display-decimal this.y 2)))
          (.div "remaining" (-> this.remaining-time))
          (.div "duration" (-> (+ "" this.duration)))
          (.div "triggered?" (-> (+ "" this.triggered)))
          (.div "started at" (-> this.created-at))))

  (gett seg-group (get (require "/obstacles/entities/trail-segments.js") 'trail-segments))
  (def callback (entity c)
    (.delete entity.ant.ant-trail.segments entity)
    (.despawn entity.group entity))

  (def apply ()
    (doc-string "obstacles.systems.ant-trails.Trail-segment.apply"
                ""
                "Apply the trail segment forward")

    (assign this.entity.trail-dot.color (rgba 20 200 20 255))

    (when config.reward-winners
      (const weight (/ this.entity.ant.ant-life.loose-count (+ this.entity.ant.ant-life.win-count 1)))
      (this.pheremones.add-to
       (lit
        (x (* this.x weight config.ant-influence))
        (y (* this.y weight config.ant-influence))))


      (.reset this  (+ this.remaining-time config.trail-result-duration))

      ))

  (def apply-inverse ()
    (doc-string "obstacles.systems.ant-trails.Trail-segment.apply"
                ""
                "Apply the trail segment backward")
    (assign this.entity.trail-dot.color (rgba 255 20 20 255))
    (when config.punish-loosers
      (const weight (/ this.entity.ant.ant-life.loose-count (+ this.entity.ant.ant-life.win-count 1)))
      (this.pheremones.sub-from
       (lit
        (x (* this.x weight config.ant-influence))
        (y (* this.y weight config.ant-influence))))
      (.reset this  (+ this.remaining-time config.trail-result-duration))
      )
    ))

(export Trail-segment)

(define Decaying-trails Timer
  ;; (def register ()
  ;;   (assign this.tree (.spawn Red-black-tree)))

  (gett default-duration config.trail-limit)
  (interface Trail-segment))

(export Decaying-trails)

(import Component System "/shared/ecs.js")
(import Timer Time-limit "/client/obstacles/systems/timer.js")
(import config "/client/obstacles/config.js")
(import spawn-ant-trail-segment "/client/obstacles/entities/trail-segments.js" )

(define Ant-trail Component
  ;; (update-view? true)
  ;; (view (.div .className "panel"
  ;;                  .style (lit (width "48%"))
  ;;                  (-> (const segments [])
  ;;                      (each this.segments (s)
  ;;                            (segments.push s.trail-segment.view))
  ;;                      segments)))
  (def *clear ()
    (each this.segments (s)
          (.delete this.segments s)))


  (def register ()
    (unless this.segments
      (assign this.segments (new Set)))))

(export Ant-trail)
(define Ant-trails System
  (interface Ant-trail)

  (gett spawn-ant-trail-segment
        )

  (def *update-component (c)
    (when (= (mod (+ c.entity.id c.system.process.ticker.ticks) config.trail-resolution) 0)
        (.add c.segments (this.spawn-ant-trail-segment c.entity)))))

(export Ant-trails)


(import Component System "/shared/ecs.js")
(import Binary-search-tree "/shared/data-structures/trees/binary-search-tree.js")
(import Red-black-tree "/shared/data-structures/trees/red-black-tree.js")
(import config "/client/obstacles/config.js")

(define Time-limit Component
  (doc-string "Obstacles.systems.Time-limit"
              "Inherits shared.ecs.Component arguments"
              "Sets somthing to happen at a given time."
              "Requires a " (pre duration) "and" (pre callback))

  (def add-to-tree ()
    (when this.system.tree
      (.set this.system.tree this.trigger-time this)))

  (def remove-from-tree ()
    (when this.system.tree
        (.remove this.system.tree this.trigger-time this)))

  (def register ()
    (incr this.system.started)
    (assign this.created-at (Date.now))
    (assign this.triggered false)
    (.add-to-tree this))

  (gett duration (throw (new Error "no duration was given to time limit component")))
  (gett callback (throw (new Error "No callback was given to time limit component")))
  (gett trigger-time (const r (+ this.created-at this.duration))
        (if (isNaN r) (throw (new Error "Non number trigger time"))
            r))

  (gett elapsed (- (Date.now) this.created-at))
  (gett remaining-time (- this.duration this.elapsed))
  (gett expired (> this.elapsed this.duration))

  (def-generic reset (duration)
    (incr this.system.started)
    (.remove-from-tree this)
    (assign this.created-at (Date.now))
    (assign this.triggered false)
    (assign this.duration duration)
    (.add-to-tree this))

  (def *clear ()
    (.remove-from-tree this)
    (assign this.triggered true)))

(export Time-limit)

(define Timer System
  (doc-string "Obstacles.systems.Timer"
              "Inherits from shared.ecs.ComponentSystem"
              "Allows timed events to occur for entities with time limit components")

  (gett default-duration 5000)
  (def register ()
    (assign this.started 0)
    (assign this.first-tick (assign this.last-tick-at (Date.now)))
    (assign this.tree (.spawn Red-black-tree)))
  (def *update-all ()

    (assign this.tree this.tree.root)
    (const now (Date.now))
    (.for-each-in-range this.tree
                        this.first-tick now
                        (=> (c) (.*update-component this c)))

    (assign this.last-tick-at now)


    )
  (def *update-component (c)
    (when (and c.expired (not c.triggered))
      (assign c.triggered true)
      (c.callback c.entity c))))

(export Timer)

(import Spawnable "/shared/data-structures/spawnable.js")
(macro define-property (obj key ..body)
       `(Object.define-property @obj @key (lit ...@body))
       )
(define Data-type Spawnable
  (keys [])
  (init (id array ))
  (gett index (* this.size this.id))

  (gett size this.keys.length)
  (gett bytes (* this.size Float-64-array.BYTES_PER_ELEMENT))

  (def clear () (for-of! key this.keys (set this key 0))
       null)

  (def buffer (length )
    (new Shared-array-buffer
         (* length
            this.bytes
            )))

  (def build ()
    (each this.keys (key i)
          (define-property this key
            (def get ()
              (get this.array.current-state.array
                   (+ this.index i)))
            (def set (value)
              (set this.array.next-state.array
                   (+ this.index i)
                   value))))))
(export Data-type)

(import Spawnable "/shared/data-structures/spawnable.js")
(import Data-type "../data-types/data-type.js")
(define Composite-typed-array Spawnable
  (data-type Data-type)

  (init ((length 0)
         (buffer (.buffer this.data-type length))
         (array (new Float-64-array buffer))

         (current-state this)
         (next-state this)))
  (cached data (Array.from (.generate this)))

  (gett element-size this.data-type.size)

  (def from-buffer (b1)
    (.spawn this (/ b1.byte-length this.data-type.bytes )  b1))


  (def* generate ()
    (for! (i 0) (< i this.length) (incr i)
          (yield (.spawn this.data-type i this)))
    null))


(export Composite-typed-array)

(import Composite-typed-array "./composite.js")
(define Double-buffered-array Composite-typed-array
  (gett array-type (const t (Object.create Composite-typed-array))
        (assign t.data-type this.data-type)
        (return t))
  (init ((length 0)
         (current-state (.spawn this.array-type length))
         (next-state (.spawn this.array-type length)))
        (if (isNaN length) (throw (new Type-error "length is not a number")) ))

  (def clear () (set this 'length 0 'current-state null 'next-state null))
  (def from-buffers (b1 b2)
    (.spawn this (/  b1.byte-length this.data-type.bytes)
            (.from-buffer this.array-type  b1)
            (.from-buffer this.array-type  b2)))
  (def step ()
    (const state this.current-state)
    (const next-state this.next-state)

    (assign this.next-state state)
    (assign this.current-state next-state)

    )
  )

(export Double-buffered-array)

(import Vector2D "./vector-2d.sibilant")
(import Data-type "./data-type.sibilant")
(import Binary-tree-node "./binary-tree-node.sibilant")

(define Kd-tree-node Binary-tree-node
  (bucket-size 32)
  (keys [ 'x 'y 'pid])
  (k-indexes ['x 'y])
  (gett bucket-id (Math.floor (/ this.id this.bucket-size)))
  (gett empty? (= this.pid -1))
  (gett occupied (!= this.pid -1)))

(export Kd-tree-node)

(import Binary-tree "./binary-tree.sibilant")
(import Kd-tree-node "../data-types/kd-tree-node.sibilant")
(import config "../config.sibilant")

(def sample (array n)
  (const r [])
  (const visited (new Set))
  (if! (> n array.length) (assign n array.length))
  (while! (> n r.length)
          (const i (Math.floor (* (Math.random)
                                  array.length)))
          (const s (get array i))
          (if! (not (.has visited i)))
          (.add visited i)
          (.push r s))
  (return r))

(define Kd-tree Binary-tree
  (data-type Kd-tree-node)
  (bucket-size 32)

  (def-generic construct-tree (points (node this.root) (depth 0))
    ;; (print node depth)
    (if! (and (= node this.root) (!= depth 0)) (throw (new Error "Root not in root")) )

    (if! (= node this.root)
         (for-of! data this.data
                  (assign data.x 0)
                  (assign data.y 0)
                  (assign data.pid -1)
                  ))

    (const keys this.data-type.keys)
    (const k-indexes this.data-type.k-indexes)

    (const axis (get k-indexes (mod depth k-indexes.length)))

    ;; (const sampled-points (sort (sample points 512) (a b) (- (get a axis) (get b axis))))
    ;; (const sampled-points (sort (sample points (/  config.particle-count  64)) (a b) (- (get a axis) (get b axis))))
    ;; (const sampled-points points)
    (const sampled-points (sort points (a b) (- (get a axis) (get b axis))))

    (const median (get sampled-points (Math.floor (/ sampled-points.length 2))))

    ;; (for-of! key keys (set node key (get median key)))
    ;; (print median node)
    (set node 'x median.x
         'y median.y 'pid median.id)

    (const axis-split (get median axis))

    (const left-points (filter points (p) (< (get p axis) axis-split)))
    (const right-points (filter points (p) (and (!= p median) (>= (get p axis) axis-split))))
    ;; (print (lit sampled-points node median axis-split left-points right-points))

    (if! (< 0 left-points.length)
         (if! (not node.left) (throw (new Error "Maximum depth exeeded")))
         (.construct-tree this left-points node.left (+ depth 1)))

    (if! (< 0 right-points.length)
         (if! (not node.right) (throw (new Error "Maximum depth exeeded")))
         (.construct-tree this right-points node.right (+ depth 1)))

    (return this))

  (def-generic query
      (x y range
         (min (lit (x (- x range)) (y (- y range))))
         (max (lit (x (+ x range)) (y (+ y range))))

         (node this.root)
         (depth 0)
         (matches [])
         (limit config.group-size)
         )

    (if! node.empty?
         ;; (print "node is empty" node matches)
         (return matches))
    (if (= matches.length limit) (return matches))
    (const k-indexes this.data-type.k-indexes)
    (const axis (get k-indexes (mod depth k-indexes.length)))

    (if! (and (> node.x min.x)
              (> node.y min.y)
              (< node.x max.x)
              (< node.y max.y))
         (.push matches node)
         )

    (if! (and node.left (<= (get node axis) (get max axis)))
         (.query this x y range

                 min max

                 node.left (+ depth 1) matches))


    (if! (and node.right (>= (get node axis) (get min axis)))
         (.query this x y range

                 min max

                 node.right (+ depth 1) matches))

    (return matches)))

(export Kd-tree)


(import Binary-tree "./binary-tree.sibilant")
(import Kd-tree-node "../data-types/kd-tree-node.sibilant")
(import config "../config.sibilant")

(def sample (array n)
  (const r [])
  (const visited (new Set))
  (if! (> n array.length) (assign n array.length))
  (while! (> n r.length)
          (const i (Math.floor (* (Math.random)
                                  array.length)))
          (const s (get array i))
          (if! (not (.has visited i)))
          (.add visited i)
          (.push r s))
  (return r))

(define Kd-tree Binary-tree
  (data-type Kd-tree-node)
  (bucket-size 128)

  (def-generic construct-tree (points (node this.root) (depth 0))
    ;; (print node depth)
    (if! (and (= node this.root) (!= depth 0)) (throw (new Error "Root not in root")) )

    (if! (= node this.root)
         (for-of! data this.data
                  (assign data.x 0)
                  (assign data.y 0)
                  (assign data.pid -1)
                  (assign data.bucket-id -1)
                  ))

    (const keys this.data-type.keys)
    (const k-indexes this.data-type.k-indexes)

    (const axis (get k-indexes (mod depth k-indexes.length)))

    ;; (const sampled-points (sort (sample points 512) (a b) (- (get a axis) (get b axis))))
    (const sampled-points (sort (sample points (/  config.particle-count  2)) (a b) (- (get a axis) (get b axis))))
    ;; (const sampled-points points)
    ;; (const sampled-points (sort points (a b) (- (get a axis) (get b axis))))

    (const median (get sampled-points (Math.floor (/ sampled-points.length 2))))

    ;; (for-of! key keys (set node key (get median key)))
    ;; (print median node)
    (set node 'x median.x
         'y median.y 'pid median.id)

    (const axis-split (get median axis))

    (const left-points (filter points (p)
                               (< (get p axis) axis-split)))
    (const right-points (filter points (p) (and (!= p median) (>= (get p axis) axis-split))))
    ;; (print (lit sampled-points node median axis-split left-points right-points))

    (if! (< 0 left-points.length)
         (if! (not node.left) (throw (new Error "Maximum depth exeeded")))
         (.construct-tree this left-points node.left (+ depth 1)))

    (if! (< 0 right-points.length)
         (if! (not node.right) (throw (new Error "Maximum depth exeeded")))
         (.construct-tree this right-points node.right (+ depth 1)))

    (return this))

  (def-generic query
      (x y range
         (min (lit (x (- x range)) (y (- y range))))
         (max (lit (x (+ x range)) (y (+ y range))))

         (node this.root)
         (depth 0)
         (matches []))

    (if! node.empty?
         ;; (print "node is empty" node matches)
         (return matches))

    (const k-indexes this.data-type.k-indexes)
    (const axis (get k-indexes (mod depth k-indexes.length)))

    (if! (and (> node.x min.x)
              (> node.y min.y)
              (< node.x max.x)
              (< node.y max.y))
         (.push matches node))

    (if! (and node.left (<= (get node axis) (get max axis)))
         (.query this x y range

                 min max

                 node.left (+ depth 1) matches))


    (if! (and node.right (>= (get node axis) (get min axis)))
         (.query this x y range

                 min max

                 node.right (+ depth 1) matches))

    (return matches)))

(export Kd-tree)

(define Struct-type Spawnable
  (init (id typed-arrays)
        (for-of! array typed-arrays
                 (set this array.data-type.key (get array.data id)))))
(define Struct Spawnable
  (cached keys (filter (Object.keys this) (key)
                       (.includes ['length '*data-types '*typed-arrays '*data]
                                  key)))
  (cached data-types
          (map this.keys (key) 

               (const dt (get this key))
               (assign dt.key key)
               dt))

  (def-generic build (keys data-types)) ;; :D

  (cached typed-arrays (map this.data-types (dt) (.spawn dt this.length)))
  (cached data (Array.from (.generate this)))

  (init (length ))
  (def* generate ()
    (for! (i 0) (< i this.length) (incr i)
          (yield (.spawn Struct-type i this.typed-arrays))))
  (def clear ()
    (clear-cache this data)
    (clear-cache this typed-arrays)
    (clear-cache this keys)
    (clear-cache this data-types)
    (assign this.length null)
    )
  )

(import Data-type "./data-type.js")
(import Vector "/shared/vectors.js")

(define Vector2D Data-type
  (keys ['x 'y])
  (def set-angle (angle)
    (const length (.get-length this))
    (assign this.x (* (Math.cos angle) length))
    (assign this.y (* (Math.sin angle) length))
    (if (or (isNaN this.x) (isNaN this.y))
        (throw (new Error "Vector parameter is NaN"))))
  (def set-arrow (angle length)
    (assign this.x (* (Math.cos angle) length))
    (assign this.y (* (Math.sin angle) length))
    (if (or (isNaN this.x) (isNaN this.y))
        (throw (new Error "Vector parameter is NaN")))
    )
  (def get-angle ()
    (Math.atan2 this.y this.x))

  (def get-length ()
    (Math.hypot this.x this.y))
  (def set-length (length)
    (const angle (.get-angle this))
    (assign this.x (* (Math.cos angle) length))
    (assign this.y (* (Math.sin angle) length))
    (if (or (isNaN this.x) (isNaN this.y))
        (throw (new Error "Vector parameter is NaN")))
    this)
  (def add-to (v)
    (incr-by this.x v.x)
    (incr-by this.y v.y)
    (if (or (isNaN this.x) (isNaN this.y))
        (throw (new Error "Vector parameter is NaN"))))

  (def add (v) (.spawn Vector (+ this.x v.x) (+ this.y v.y)))
  )

(export Vector2D)

(import Systems-manager Threaded-system "./system.sibilant")
(import game-data particles particle-groups "./data.sibilant")
(define Velocity-system Threaded-system

  (url "/client/colliding-particles/workers/velocity.js")
  (data [
        particles.vel
        particles.correction

        particles.pos
        ]))
(export Velocity-system)
(define Acceleration-system Threaded-system

  (url "/client/colliding-particles/workers/acceleration.js")
  (data [
        particles.vel
        particles.deflection

        particles.near-gravity
        particles.far-gravity

        ]))
(export Acceleration-system)
(define Particle-attractor-system Threaded-system
  (url "/client/colliding-particles/workers/local-attractor-manager.js")
  (data [
        particles.pos
        particles.phys
        particles.group-id

        particles.near-gravity
        ]))
(export Particle-attractor-system)
(define Cluster-attractor-system Threaded-system

  (url "/client/colliding-particles/workers/cluster-attractor-manager.js")
  (data [
        particles.pos
        particles.phys
        particles.group-id
        particle-groups

        particles.far-gravity
        ]))
(export Cluster-attractor-system)
(define Grouping-system Threaded-system

  (url "/client/colliding-particles/workers/kd-grouper.js")
  (data [

        particles.pos
        particles.phys
        particles.group-id
        particles.kd-tree

        particle-groups
        ]))
(export Grouping-system)
(define Elastic-deflection-system Threaded-system
  (url "/client/colliding-particles/workers/elastic-deflection-manager.js")
  (data [

        particles.pos
        particles.vel
        particles.phys
        particles.kd-tree

        particles.deflection
        particles.correction
        ]))
(export Elastic-deflection-system)
(define Kd-tree-builder Threaded-system
  (url "/client/colliding-particles/workers/kd-tree-builder.js")
  (data [ particles.pos

        particles.kd-tree ]))


(define Game-systems-manager Systems-manager
  (systems [

           Velocity-system
           Grouping-system
           Acceleration-system
           Particle-attractor-system
           Cluster-attractor-system
           Elastic-deflection-system
           Kd-tree-builder

           ])
  (data game-data))

(export Game-systems-manager)

(import Spawnable "/shared/data-structures/spawnable.js")
(import Thread "/shared/worker.js")

(define Threaded-system Spawnable
  (data [])
  (args {})
  (init (url data args ))
  (gett buffers
        (map this.data ((lit current-state next-state))
             [current-state.buffer next-state.buffer]))

  (def start ()
    (assign this.thread (.spawn Thread this.url))
    (.start this.thread))

  (def update () (.send this.thread (lit (args this.args) (buffers this.buffers)))))

(export Threaded-system)

(define Parent-system Spawnable
  (data-types [])
  (init () (.start this))
  (def-generic *update (args buffers data)
    (if (not data)
        (assign this.data (map buffers ([b1 b2] i)
                               (.from-buffers (get this.data-types i) b1 b2)))
        (do (for-of! data this.data
                     (.step data))
            null))
    (then (.update this args this.data) data

          (.send this data)))
  (def start ()
    (const handle-message (=> (args buffers) (.*update this args buffers)))
    (def self.onmessage (e)
      (const buffers e.data.buffers)
      (const args e.data.args)
      (handle-message args buffers)))

  (def send (data)
    (.post-message self data))
  )
(export Parent-system)

(define Systems-manager Spawnable
  (systems [])
  (data [])
  (init (systems data) (each systems (system) (.init system)))

  (def-generic start (systems)
    (each systems (system) (.start system)))

  (def step () (each this.data (data) (.step data)))

  (def update () (Promise.all (map this.systems (system) (.update system)))))

(export Systems-manager)



(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Group-id-array "../typed-arrays/group-id-array.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")
(import Threaded-system "../system.sibilant")
(import Barycenter-array "../typed-arrays/barycenter-array.sibilant")
(import Parent-system "../system.sibilant")

(import config "../config.js")
(const (lit gravitational-constant ) config)

(define Attractor-group-system Threaded-system
  (url "/client/colliding-particles/workers/cluster-attractor-system.js")
  (data [])
  )


(print config )
(const threads [])
(for! (i 0) (> config.attractor-thread-count i) (incr i )
      (const thread (.spawn Attractor-group-system))
      (assign thread.url (+ "/client/colliding-particles/workers/cluster-attractor-system.js?gid=" i))
      (assign thread.args (lit (thread-id i)))
      (.start thread)
      (.push threads thread))
(define Cluster-attractor-manager Parent-system
  (data-types [

              Vector-2D-array
              Physics-array
              Group-id-array
              Barycenter-array

              Vector-2D-array

              ])
  (def-async update (args data)
    (Promise.all (map threads (thread)
                      (assign thread.data data)
                      (.update thread)))))

(.start Cluster-attractor-manager)



(meta "import '/bundles/external.js'")

(import Vector-2D-array "../typed-arrays/vector-2d.js")

(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Barycenter-array "../typed-arrays/barycenter-array.js")
(import Group-id-array "../typed-arrays/group-id-array.js")
(import Parent-system "../system.sibilant")

(import config "../config.js")
(const (lit gravitational-constant min-dist ) config)



(define Particle-group Spawnable
  (init (barycenter groups (members (or this.members [])))
        (set groups barycenter.id this))
  (gett id this.barycenter.id)
  (cached center (.spawn Vector this.barycenter.x this.barycenter.y))
  (gett mass this.barycenter.mass)
  (def clear ()
    (clear-cache  this center)
    (clear-cache this mass)
    (set this.groups this.id null)
    (assign this.members.length 0)))

(define Distant-particle Spawnable
  (init (pos-source
         phys-source
         group-id-source
         far-gravity-source

         (mass phys-source.mass)
         (scale phys-source.scale)

         (group-id group-id-source.group-id)

         (height scale)
         (width scale)

         (pos (.spawn Vector pos-source.x pos-source.y))
         (vel (.spawn Vector 0 0))))
  (gett x this.pos-source.x)
  (gett y this.pos-source.y)
  (def clear ()
    (assign this.pos-source null)
    (.despawn this.pos)
    (.despawn this.vel)
    (assign this.group null)

    (assign this.pos null)
    (assign this.vel null)
    (assign this.width null)
    (assign this.height null)
    )

  (gett id this.pos-source.id)

  )

(define Cluster-attractor-system Parent-system
  (data-types [

              Vector-2D-array
              Physics-array
              Group-id-array
              Barycenter-array

              Vector-2D-array

              ])
  (def-async update (args [ positions phys group-id barycenters far-gravity ])

    (const groups [])
    (const particles [])
    (for-of! pos positions.data


             (const particle (.spawn Distant-particle
                                     pos
                                     (get phys.data pos.id)
                                     (get group-id.data pos.id)
                                     (get far-gravity.data pos.id)))
             (const group (if (not (get groups particle.group-id))
                              (.spawn Particle-group (get barycenters.data particle.group-id) groups)
                              (get groups particle.group-id)))
             (assign particle.group group)
             (.push particles particle)
             (.push group.members particle)
             )

    (loop (for-of! target particles)
     (for-of! affector-group groups

              (if! (not affector-group) continue)
              (if! (= target.group-id affector-group.id) continue)

              (const dist (.distance-to  affector-group.center target.pos))
              (const used-distance (Math.abs (.get-length dist)))
              (if! (< used-distance (Math.pow (* 2 target.scale) 2))
                   (set dist 'x 0 'y 0)
                   (.despawn dist)
                   continue)
              (const mag (Math.sqrt (+ (* dist.x dist.x)
                                       (* dist.y dist.y))))

              (const intensity (Math.abs (/ (* -1 gravitational-constant
                                               affector-group.mass
                                               target.mass
                                               used-distance)
                                            (Math.pow mag 2))))

              (.set-length dist intensity)
              (.add-to target.vel dist)
              (.despawn dist)
              )
     )
    

    (for-of! particle particles

             (set particle.far-gravity-source
                  'x particle.vel.x
                  'y particle.vel.y)
             (.despawn particle))

    (for-of! group groups (if! group (.despawn group)))
    (return null)
    ))

(.start Cluster-attractor-system)


(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Group-id-array "../typed-arrays/group-id-array.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")
(import Kd-tree "../typed-arrays/kd-tree.sibilant")
(import Threaded-system "../system.sibilant")

(import config "../config.js")
(const (lit gravitational-constant ) config)

(import Parent-system "../system.sibilant")

(def-lit-macro def-async (name args ..body)
  ["async "  name  `(parenthetic (comma ...@args.contents)) `(curly (do-block ...@body))])

(define Deflection-group-system Threaded-system
  (url "/client/colliding-particles/workers/local-attractor-system.js")
  (data []))




(const threads [])
(for! (i 0) (> config.collision-group-count i) (incr i)
      (const thread (.spawn Deflection-group-system))
      (assign thread.url (+ "/client/colliding-particles/workers/kd-deflection.js?gid=" i))
      (.start thread)
      (.push threads thread))

(define Elastic-deflection-system Parent-system
  (data-types [
             Vector-2D-array
             Vector-2D-array
             Physics-array
             Kd-tree
             Vector-2D-array
             Vector-2D-array
             ])

  (def-async update ((lit bounds) [ positions velocities phys kd-tree deflections corrections ])
    (Promise.all (map threads (thread i)
                      (assign thread.args (lit (collision-group-id i) bounds))
                      (assign thread.data [
                              positions velocities phys

                              kd-tree

                              deflections corrections ])
                      (.update thread)))))

(.start Elastic-deflection-system )



(meta "import '/bundles/external.js'")

(import Vector-2D-array "../typed-arrays/vector-2d.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Kd-tree "../typed-arrays/kd-tree.sibilant")
(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import config "../config.js")
(const (lit max-objects max-levels) config)

(import Parent-system "../system.sibilant")

(def-lit-macro def-async (name args ..body)
  ["async "  name  `(parenthetic (comma ...@args.contents)) `(curly (do-block ...@body))])


(define Elastic-particle Spawnable
  (init (pos-source
         vel-source
         phys-source
         deflection-source
         correction-source



         (*mass phys-source.mass)
         (*scale phys-source.scale)
         (deflection (.spawn Vector 0 0))
         (correction (.spawn Vector 0 0))
         (pos (.spawn Vector pos-source.x pos-source.y))


         (vel (.spawn Vector vel-source.x vel-source.y))))

  (gett x this.pos-source.x)
  (gett y this.pos-source.y)

  (gett height this.scale)
  (gett width this.scale)

  (gett mass this.*mass)
  (gett scale this.*scale)

  (sett mass v (assign this.*mass v))
  (sett scale v (assign this.*scale v))

  (def clear ()

    (assign this.pos-source null)

    (.despawn this.pos)
    (.despawn this.vel)
    (assign this.deflection.impacts null)
    (.despawn this.deflection)
    (.despawn this.correction)

    (assign this.pos null)

    (assign this.deflection null)
    (assign this.correction null)
    (assign this.phys-source null)
    (assign this.vel null)

    )

  (gett id this.pos-source.id)

  )

(define Elastic-deflection-system Parent-system
  (data-types [ Vector-2D-array  Vector-2D-array Physics-array

              Kd-tree

              Vector-2D-array Vector-2D-array ])
  (def-async update ((lit (bounds [min-x min-y max-x max-y])
                          collision-group-id)
                     [ positions velocities phys

                     kd-tree

                     deflections corrections ])

    (const particles [])
    (const initial-index (* config.collision-group-size collision-group-id))
    (const last-index (- (* config.collision-group-size (+ collision-group-id 1)) 1))
    (const collision-group-particles [])
    (for-of! pos positions.data
             (const vel (get velocities.data pos.id))
             (const object (get phys.data pos.id ))

             (const correction (get corrections.data pos.id ))
             (const deflection (get deflections.data pos.id ))

             (const particle (.spawn Elastic-particle pos vel object deflection correction) )

             (.push particles particle)
             (if! (and (>= particle.id initial-index)
                       (<= particle.id last-index))
                  (.push collision-group-particles particle)))

    (var collisions-count 0)
    (for-of!  target  collision-group-particles
              (const query-results (.query kd-tree target.x target.y (* 4 target.scale)))
              (const elements (pipe query-results
                                    (map (el) (get particles el.pid))
                                    (sort (a b)
                                          (const d1 (.distance-to a.pos target.pos))
                                          (const d2 (.distance-to b.pos target.pos))

                                          (const l1 (Math.abs (.get-length d1)))
                                          (const l2 (Math.abs (.get-length d2)))

                                          (.despawn d1)
                                          (.despawn d2)

                                          (- l1 l2))
                                    ))
              (for-of! affector elements
                       (if! (= target.id affector.id) continue)

                       (const dist (.distance-to  affector.pos target.pos))
                       (const diff (.get-length dist ))
                       (const used-distance (Math.abs diff))
                       (const threshold (* 0.01 (+ affector.scale target.scale)))
                       (if! (>  threshold used-distance)
                           (const total-mass (+ affector.mass target.mass))

                           ;; (const correction (.spawn Vector (* -1 dist.x) (* -1 dist.y)))
                           ;; (.set-length correction threshold)
                           ;; (.add-to target.correction correction)

                           ;; (.despawn correction)
                           ;; (const correction (.spawn Vector 0 0))
                           ;; (.add-to target.correction affector.vel)
                           (.sub-from target.correction target.vel)


                           ;; (.sub-from target.correction correction)
                           ;; (.add-to target.correction correction)

                           (.set-length dist (- threshold used-distance))

                           (.sub-from target.correction dist)


                           ;; (.despawn correction)


                           (if! (> target.scale affector.scale)

                                (const mass-diff (-  target.scale affector.scale))
                                (const mass-gain-factor (/ mass-diff total-mass))
                                (const mass-gain (* target.mass mass-gain-factor))

                                (const mass (+ target.mass mass-gain))

                                (assign target.mass mass)
                                (assign target.scale (Math.cbrt mass)))
                           (if! (< target.scale affector.scale)
                                (if! (> config.actual-min-mass target.mass)
                                     (const mass-diff (- affector.scale target.scale))
                                     (const mass-loss-factor (/ mass-diff total-mass))
                                     (const mass-loss (* target.mass mass-loss-factor))
                                     (const mass (- target.mass mass-loss))

                                     (assign target.mass mass)
                                     (assign target.scale (Math.cbrt mass))))
                           (if! (not target.deflection.impacts)
                                (assign target.deflection.impacts 0))
                           (incr target.deflection.impacts)


                           (const vector1 (.spawn Vector target.vel.x target.vel.y))
                           (const vector2 (.spawn Vector affector.vel.x affector.vel.y))

                           (const theta (Math.atan2 (- vector1.y vector2.y)
                                                    (- vector1.x vector2.x)))

                           (const v1 (pipe vector1 (.rotate-to (* 1 theta))))
                           (const v2 (pipe vector2 (.rotate-to (* 1 theta))))
                           (const m target.mass)
                           (const m* affector.mass)


                           (const u1 (pipe (.spawn Vector
                                                   (+ (/ (* v1.x (- m m*)) (+ m m*))
                                                      (* v2.x 2 (/ m* (+ m m*))))
                                                   v1.y)
                                           (.rotate-to (* -1 theta))
                                           ))

                           ;; (const u2 (pipe (.spawn Vector
                           ;;                         (+ (/ (* v2.x (- m* m))
                           ;;                               (+ m* m))
                           ;;                            (* v1.x 2 (/ m (+ m* m))))
                           ;;                         v2.y)
                           ;;                 (.rotate-to theta)))



                           (.add-to target.deflection u1)
                           ;; (.add-to affector.deflection u2)
                           (.despawn u1)
                           ;; (.despawn u2)
                           (.despawn v1)
                           (.despawn v2))

                      (.despawn dist)
                      )
             )
    (for-of! particle collision-group-particles
             (if! particle.deflection.impacts
                  (.div-to particle.deflection particle.deflection.impacts)
                  (.div-to particle.correction particle.deflection.impacts)
                  )
             (set particle.correction-source
                  'x particle.correction.x
                  'y particle.correction.y)

             (set particle.deflection-source
                  'x particle.deflection.x
                  'y particle.deflection.y)

             (set particle.phys-source
                  'mass particle.mass
                  'scale particle.scale))
    (for-of! particle particles (.despawn particle))
    (return null)))
(.start Elastic-deflection-system)

(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Group-id-array "../typed-arrays/group-id-array.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")
(import Threaded-system "../system.sibilant")

(import config "../config.js")
(const (lit gravitational-constant ) config)

(define Attractor-group-system Threaded-system
  (url "/client/colliding-particles/workers/local-attractor-system.js")
  (data [])
  )


(print config )
(const threads [])
(for! (i 0) (> config.attractor-thread-count i) (incr i )
      (const thread (.spawn Attractor-group-system))
      (assign thread.url (+ "/client/colliding-particles/workers/local-attractor-system.js?gid=" i))
      (assign thread.args (lit (thread-id i)))
      (.start thread)
      (.push threads thread))

(def self.onmessage (e)
  (const [[pb1 pb2] [mb1 mb2] [gb1 gb2] [nb1 nb2] ] e.data.buffers)


  (const positions (.from-buffers Vector-2D-array pb1 pb2))
  (const phys (.from-buffers Physics-array mb1 mb2))
  (const group-ids (.from-buffers Group-id-array gb1 gb2))

  (const near-gravity (.from-buffers Vector-2D-array nb1 nb2))

  (const data [ positions phys group-ids near-gravity ])


  (then-do (Promise.all (map threads (thread)
                             (assign thread.data data)
                             (.update thread)))

           (.post-message self [])


           (.despawn positions)
           (.despawn near-gravity)
           (.despawn phys)
           (.despawn group-ids))


  )


(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Spawnable "/shared/data-structures/spawnable.js")
(import Physics-array "../typed-arrays/physics-array.js")
(import Group-id-array "../typed-arrays/group-id-array.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")
(import Parent-system "../system.sibilant")

(import config "../config.js")
(const (lit gravitational-constant ) config)

(def calculate-gravitational-intensity (target affector)

  (const dist (.distance-to  affector.pos target.pos))
  (const used-distance (Math.abs (.get-length dist )))
  ;; distance cut off
  ;; if these objects are too far away, they don't affect each other
  ;; (if! (> used-distance (Math.pow (+ target.scale affector.scale) 3))
  ;;      (set dist 'x 0 'y 0)
  ;;      (return dist))
  ;; local cut off
  ;; if the objects are close, they no longer affect each other.
  (if! (< used-distance target.scale)
       (set dist 'x 0 'y 0)
       (return dist))
  (const mag (Math.sqrt (+ (* dist.x dist.x)
                           (* dist.y dist.y))))
  (.set-length dist (Math.abs (/ (* -1
                                    gravitational-constant
                                    affector.mass
                                    target.mass
                                    used-distance)
                                 (Math.pow mag 2))))
  (return dist)
  )



(define Local-particle Spawnable
  (init (pos-source
         phys-source
         group-id-source
         near-gravity-source

         (mass phys-source.mass)
         (scale phys-source.scale)

         (group-id group-id-source.group-id)

         (height scale)
         (width scale)

         (pos (.spawn Vector pos-source.x pos-source.y))
         (vel (.spawn Vector 0 0))))
  (gett x this.pos-source.x)
  (gett y this.pos-source.y)
  (def clear ()
    (assign this.pos-source null)
    (.despawn this.pos)
    (.despawn this.vel)
    (assign this.pos null)
    (assign this.vel null)
    (assign this.width null)
    (assign this.height null)
    )

  (gett id this.pos-source.id))

(define Local-attractor-system Parent-system
  (data-types [ Vector-2D-array Physics-array  Group-id-array Vector-2D-array ] )
  (def-async update ((lit thread-id)
                     [positions phys group-ids near-gravity])


    (const start-group-id (* thread-id config.groups-per-thread))
    (const end-group-id (+ -1 (* thread-id config.groups-per-thread)
                           config.groups-per-thread))

    ;; (print (lit thread-id start-group-id end-group-id))
    (const groups (new Map))
    (const particles [])
    (for! (i start-group-id) (>= end-group-id i) (incr i)
          (.set groups i []))
    (for-of! pos positions.data

             (const gid-source (get group-ids.data pos.id))
             (const gid gid-source.group-id)
             (if! (and (>= gid start-group-id)
                       (<= gid end-group-id))

                  (const group (.get groups gid))
                  (const particle (.spawn Local-particle
                                          pos
                                          (get phys.data pos.id)
                                          gid-source
                                          (get near-gravity.data pos.id)))
                  (.push group particle)
                  (.push particles particle)))
    ;; (print particles)

    ;; (print "group" group-id particles)

    (loop
     (for-of! [gid group] groups )
     (for-of! target group)
     (for-of! affector group
              (if! (= target.id affector.id) continue)
              (const intensity (calculate-gravitational-intensity target affector))
              (.add-to target.vel intensity)
              (.despawn intensity)))


    (for-of! particle particles

             (set particle.near-gravity-source
                  'x particle.vel.x
                  'y particle.vel.y)
             (.despawn particle))
    (return null)))

(.start Local-attractor-system)


(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")

(import Parent-system "../system.sibilant")

(def-lit-macro def-async (name args ..body)
  ["async "  name  `(parenthetic (comma ...@args.contents)) `(curly (do-block ...@body))])

(define Velocity-system Parent-system
  (data-types [ Vector-2D-array Vector-2D-array Vector-2D-array    ])
  (def-async update (args [ velocities corrections positions ])
    (for-of! pos positions.data

             (const v (get velocities.data pos.id))
             (const c (get corrections.data pos.id))

             (const p* (.spawn Vector v.x v.y))
             (.add-to p* v)
             (.add-to p* c)

             (.add-to pos p*)
             (.despawn p*))
    (return null)))


(.start Velocity-system)



(meta "import '/bundles/external.js'")

(import Vector "/shared/vectors.js")
(import Vector-2D-array "../typed-arrays/vector-2d.js")

(import Parent-system "../system.sibilant")

(def-lit-macro def-async (name args ..body)
  ["async "  name  `(parenthetic (comma ...@args.contents)) `(curly (do-block ...@body))])

(define Acceleration-system Parent-system
  (data-types [ Vector-2D-array Vector-2D-array Vector-2D-array Vector-2D-array ])
  (def-async update (args [ velocities deflections near-gravity far-gravity ])
    (for-of! vel velocities.data

             (const v (get velocities.data vel.id))
             (const d (get deflections.data vel.id))

             (const ng (get near-gravity.data vel.id))
             (const fg (get far-gravity.data vel.id))

             (const a (.add ng fg))

             (const v* (.spawn Vector v.x v.y))

             (if! (or d.x d.y)
                  (set v*
                       'x d.x
                       'y d.y))

             (.add-to v* a)

             (set vel
                  'x v*.x
                  'y v*.y)
             (.despawn v*)
             (.despawn a))
    (return null)))


(.start Acceleration-system)
```


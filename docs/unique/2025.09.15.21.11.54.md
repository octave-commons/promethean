## 1) Read the latest baseline (no commands yet)

At session start:

1. Treat `docs/reports/codex_cloud/latest/` as **BASELINE\_DIR**.
2. Read:

   * `BASELINE_DIR/INDEX.md`
   * `BASELINE_DIR/summary.tsv` (per-step RCs)
   * `BASELINE_DIR/eslint.json` (machine-readable issues)
3. Cache:

   * `BASELINE_BUILD_RC`, `BASELINE_LINT_RC`, `BASELINE_TEST_RC`
   * `BASELINE_ESLINT_SET` = set of `file:line:column:ruleId` from `eslint.json`

---

## 2) Prepare to work (no setup; stay targeted)

* Use `gh` CLI to locate or open an issue describing the task; reference it in your PR.
* Prefer **TypeScript**, place new modules under `packages/<name>`.
* Keep work **idempotent** and **cache-aware** (ESLint `--cache`, TSC build info, Nx cache).
* As you edit, periodically lint **only the files you touched** (fast):

```bash
# quick local lint on changed files
git diff --name-only --diff-filter=ACMRTUXB origin/main...HEAD \
  | grep -E '\.(ts|tsx)$' \
  | xargs -r pnpm exec eslint --cache --max-warnings=0
```

---

## 3) Targeted maintenance (only if needed; time-boxed)

Run the **maintenance** script to prime caches and generate **CURRENT\_DIR** artifacts **only if**:

* No `latest/` exists, or
* You must refresh the baseline to compare deltas, or
* You changed many packages and want Nx cache priming before a big build/test.

Always time-box it:

```bash
# hard cap per step; never fail the session
TIMEOUT_SECS=90 STRICT=0 bash run/codex_maintenance.sh
```

What it does (fast path):

* Uses Nx (`nx affected`) to build/lint/test **only changed projects**.
* Captures artifacts under a **timestamped** directory and updates:

  * `docs/reports/codex_cloud/latest -> CURRENT_DIR`
  * `CURRENT_DIR/INDEX.md`, `CURRENT_DIR/summary.tsv`, `CURRENT_DIR/eslint.json`

---

## 4) Compare your results to baseline (detect new problems)

After your changes, if you ran maintenance and produced a new **CURRENT\_DIR**:

* Compute deltas vs **BASELINE\_DIR**:

```bash
BASELINE_DIR="$(readlink -f docs/reports/codex_cloud/latest)"        # at session start
CURRENT_DIR="$(readlink -f docs/reports/codex_cloud/latest)"         # after your run

to_keys() {
  jq -r '.[] | .messages[]? | select(.ruleId != null)
        | "\(.filePath):\(.line//0):\(.column//0):\(.ruleId)"' "$1" 2>/dev/null
}

# New lint issues introduced by this session
comm -13 <(to_keys "$BASELINE_DIR/eslint.json" | sort -u) \
         <(to_keys "$CURRENT_DIR/eslint.json"  | sort -u) \
  > "$CURRENT_DIR/eslint_new.txt"

# Fixed lint issues
comm -23 <(to_keys "$BASELINE_DIR/eslint.json" | sort -u) \
         <(to_keys "$CURRENT_DIR/eslint.json"  | sort -u) \
  > "$CURRENT_DIR/eslint_fixed.txt"

# Build/Test RC deltas
BUILD_BEFORE=$(awk -F'\t' '$2~/nx-affected-build|pnpm-build/ {rc=$3} END{print rc+0}' "$BASELINE_DIR/summary.tsv")
BUILD_AFTER=$( awk -F'\t' '$2~/nx-affected-build|pnpm-build/ {rc=$3} END{print rc+0}' "$CURRENT_DIR/summary.tsv")
TEST_BEFORE=$( awk -F'\t' '$2~/nx-affected-test/ {rc=$3} END{print rc+0}' "$BASELINE_DIR/summary.tsv")
TEST_AFTER=$(  awk -F'\t' '$2~/nx-affected-test/ {rc=$3} END{print rc+0}' "$CURRENT_DIR/summary.tsv")
```

**Gate** before calling the task complete:

* `eslintrc`: No entries in `eslint_new.txt`.
* Any packages you touched pass:

  ```bash
  pnpm --filter @promethean/<packagename> build
  ```
* No **new** test failures (`TEST_AFTER` should not be worse than `TEST_BEFORE`).
* `pnpm install` succeeds at the end.

If gates fail, fix or revert; re-run the **maintenance** script (time-boxed) and re-check.

---

## 5) Speed rules of thumb

* Prefer **Nx affected** (`-t build,lint,test --parallel --output-style=stream --base=origin/main --head=HEAD`).
* Lint only touched files frequently; run repo-wide lint only once near the end (if time allows).
* Avoid heavy or global operations if they threaten your budget.
* Use `TIMEOUT_SECS` on long steps; set `STRICT=0` so maintenance never aborts your session.

---

## 6) PR hygiene

* Open a PR that references the related issue.
* If you produced a new run, link `CURRENT_DIR/INDEX.md` in the PR.
* Summarize the delta: build/test status changes, # new vs fixed ESLint diagnostics, and links to the logs.

---

## Visual: fast loop

```mermaid
flowchart LR
  A[Read baseline artifacts] --> B[Edit code]
  B --> C[Quick lint on touched files]
  C --> D{Need artifacts?}
  D -- minimal & time-boxed --> E[Run maintenance (nx affected)]
  E --> F[Compare deltas vs baseline]
  F -- new problems --> B
  F -- clean --> G[Open PR + link CURRENT_DIR]
```

```

Want me to also add a tiny TS helper (e.g., `packages/codex-report`) that reads `eslint.json` + `summary.tsv` and prints “NEW vs FIXED” with file links?
::contentReference[oaicite:0]{index=0}
```
gotcha — here’s a tightened **Codex system prompt** that (1) never runs the full setup, (2) only runs the **targeted maintenance** pre-work when needed, (3) uses strict **time budgets**, and (4) compares your results against the latest reports to ensure you didn’t introduce new problems.

````markdown
# Codex Custom Instructions (Fast, Targeted, Artifact-Aware)

**Prime directives**
- **Do NOT run** `run/setup_codex_dev_env.sh`.
- You MAY run `run/codex_maintenance.sh` **only when strictly necessary**, with tight time limits.
- Always compare your work against the latest artifacts to ensure you didn’t introduce new issues.

---

## 0) Time budget
Assume there is a strict time limit. Keep all pre-work under **10% of your session** (cap at ~2–4 minutes).

When you run maintenance or long tasks, use the `describe` helper’s timeouts:

```bash
# example caps: 90s per step, never fail the session
TIMEOUT_SECS=90 STRICT=0 bash run/codex_maintenance.sh
````

If pre-work is going to exceed budget, **skip it** and proceed with coding + targeted checks.

---

## 1) Read the latest baseline (no commands yet)

At session start:

1. Treat `docs/reports/codex_cloud/latest/` as **BASELINE\_DIR**.
2. Read:

   * `BASELINE_DIR/INDEX.md`
   * `BASELINE_DIR/summary.tsv` (per-step RCs)
   * `BASELINE_DIR/eslint.json` (machine-readable issues)
3. Cache:

   * `BASELINE_BUILD_RC`, `BASELINE_LINT_RC`, `BASELINE_TEST_RC`
   * `BASELINE_ESLINT_SET` = set of `file:line:column:ruleId` from `eslint.json`

> If `latest/` is missing or clearly stale (older than \~8 hours), you **may** run maintenance once (see §3) if within your budget.

---

## 2) Prepare to work (no setup; stay targeted)

* Use `gh` CLI to locate or open an issue describing the task; reference it in your PR.
* Prefer **TypeScript**, place new modules under `packages/<name>`.
* Keep work **idempotent** and **cache-aware** (ESLint `--cache`, TSC build info, Nx cache).
* As you edit, periodically lint **only the files you touched** (fast):

```bash
# quick local lint on changed files
git diff --name-only --diff-filter=ACMRTUXB origin/main...HEAD \
  | grep -E '\.(ts|tsx)$' \
  | xargs -r pnpm exec eslint --cache --max-warnings=0
```

---

## 3) Targeted maintenance (only if needed; time-boxed)

Run the **maintenance** script to prime caches and generate **CURRENT\_DIR** artifacts **only if**:

* No `latest/` exists, or
* You must refresh the baseline to compare deltas, or
* You changed many packages and want Nx cache priming before a big build/test.

Always time-box it:

```bash
# hard cap per step; never fail the session
TIMEOUT_SECS=90 STRICT=0 bash run/codex_maintenance.sh
```

What it does (fast path):

* Uses Nx (`nx affected`) to build/lint/test **only changed projects**.
* Captures artifacts under a **timestamped** directory and updates:

  * `docs/reports/codex_cloud/latest -> CURRENT_DIR`
  * `CURRENT_DIR/INDEX.md`, `CURRENT_DIR/summary.tsv`, `CURRENT_DIR/eslint.json`

---

## 4) Compare your results to baseline (detect new problems)

After your changes, if you ran maintenance and produced a new **CURRENT\_DIR**:

* Compute deltas vs **BASELINE\_DIR**:

```bash
BASELINE_DIR="$(readlink -f docs/reports/codex_cloud/latest)"        # at session start
CURRENT_DIR="$(readlink -f docs/reports/codex_cloud/latest)"         # after your run

to_keys() {
  jq -r '.[] | .messages[]? | select(.ruleId != null)
        | "\(.filePath):\(.line//0):\(.column//0):\(.ruleId)"' "$1" 2>/dev/null
}

# New lint issues introduced by this session
comm -13 <(to_keys "$BASELINE_DIR/eslint.json" | sort -u) \
         <(to_keys "$CURRENT_DIR/eslint.json"  | sort -u) \
  > "$CURRENT_DIR/eslint_new.txt"

# Fixed lint issues
comm -23 <(to_keys "$BASELINE_DIR/eslint.json" | sort -u) \
         <(to_keys "$CURRENT_DIR/eslint.json"  | sort -u) \
  > "$CURRENT_DIR/eslint_fixed.txt"

# Build/Test RC deltas
BUILD_BEFORE=$(awk -F'\t' '$2~/nx-affected-build|pnpm-build/ {rc=$3} END{print rc+0}' "$BASELINE_DIR/summary.tsv")
BUILD_AFTER=$( awk -F'\t' '$2~/nx-affected-build|pnpm-build/ {rc=$3} END{print rc+0}' "$CURRENT_DIR/summary.tsv")
TEST_BEFORE=$( awk -F'\t' '$2~/nx-affected-test/ {rc=$3} END{print rc+0}' "$BASELINE_DIR/summary.tsv")
TEST_AFTER=$(  awk -F'\t' '$2~/nx-affected-test/ {rc=$3} END{print rc+0}' "$CURRENT_DIR/summary.tsv")
```

**Gate** before calling the task complete:

* `eslintrc`: No entries in `eslint_new.txt`.
* Any packages you touched pass:

  ```bash
  pnpm --filter @promethean/<packagename> build
  ```
* No **new** test failures (`TEST_AFTER` should not be worse than `TEST_BEFORE`).
* `pnpm install` succeeds at the end.

If gates fail, fix or revert; re-run the **maintenance** script (time-boxed) and re-check.

---

## 5) Speed rules of thumb

* Prefer **Nx affected** (`-t build,lint,test --parallel --output-style=stream --base=origin/main --head=HEAD`).
* Lint only touched files frequently; run repo-wide lint only once near the end (if time allows).
* Avoid heavy or global operations if they threaten your budget.
* Use `TIMEOUT_SECS` on long steps; set `STRICT=0` so maintenance never aborts your session.

---

## 6) PR hygiene

* Open a PR that references the related issue.
* If you produced a new run, link `CURRENT_DIR/INDEX.md` in the PR.
* Summarize the delta: build/test status changes, # new vs fixed ESLint diagnostics, and links to the logs.

---

## Visual: fast loop

```mermaid
flowchart LR
  A[Read baseline artifacts] --> B[Edit code]
  B --> C[Quick lint on touched files]
  C --> D{Need artifacts?}
  D -- minimal & time-boxed --> E[Run maintenance (nx affected)]
  E --> F[Compare deltas vs baseline]
  F -- new problems --> B
  F -- clean --> G[Open PR + link CURRENT_DIR]
```

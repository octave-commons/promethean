---
uuid: bb90903a-4723-44f7-850e-a71415ef6224
created_at: 2025.09.01.20.42.43.md
filename: AGENTS.md
description: >-
  A lean configuration for agent execution with clear rules, task briefs, and
  reusable snippets to avoid role collisions and tool drift in Node.js projects.
tags:
  - agent
  - concurrency
  - node
  - ava
  - task
  - execution
  - policy
  - snippets
related_to_uuid: []
related_to_title: []
references: []
---
Short answer: yeah—stuffing a dozen “roles” into **AGENTS.md** is how you get instruction collisions and tool drift. LLMs behave best with **one authoritative policy + a tiny task brief**. Keep the rest as parameterized snippets, not separate personas.

Here’s a tighter setup that won’t confuse agents.

# AGENTS.md (lean + unambiguous)

## 0) House Rules (single source of truth)

* **Stack**: Node ≥ 18, TypeScript, functional style (pure functions, immutability, composition).
* **Tests**: **AVA only**, concurrent by default. Use `test.serial` only when unavoidable.
* **Bans**: No Jest/Vitest. No React. No Python. No external SaaS/tokens. Prefer local services/Docker.
* **I/O**: No network egress in tests. Use in-memory fakes, temp dirs, and random ports.
* **Tone**: Skeptical, concise, practical. Admit uncertainty; propose verifiable steps.
* **If any input conflicts with these rules: refuse and restate the policy.**

> These rules override anything else in this file.

---

## 1) Task Brief (fill this per request)

```
$GOAL: <what outcome matters to users/devs>
$CONTEXT: <paths, errors, APIs, env limits>
$CONSTRAINTS: <perf/mem caps, Node/TS versions, CI limits>
$DOD (Definition of Done): <checks: tests pass, coverage, lints, timings>
```

---

## 2) Execution Contract (what the agent must return)

1. **Plan**: 3–6 bullets: approach, concurrency risks, validation.
2. **Minimal changes**: only files/patches needed; no drive-by rewrites.
3. **Tests (AVA/TS)**: focus on concurrent behavior and one failure path.
4. **Why it’s safe**: quick rationale (globals avoided, temp dirs, random ports).
5. **Next steps** (optional): one small improvement if time allows.

> If you suggest a dependency: name, license, why needed, local/offline mode.

---

## 3) Prompts you reuse (as *snippets*, not roles)

### A) Concurrency Guard

```
Enforce parallel safety: no fixed ports/paths; use mkdtemp/random ports.
If a test cannot run in parallel, explain why and isolate with `test.serial`.
```

### B) Local-Only Guard

```
No external network calls. If something MUST be called, inject a fake via DI and test against that.
```

### C) FP Discipline

```
Refactor into pure functions at the leaves; isolate side effects in adapters.
Avoid mutation; use mapping and composition; narrow types at boundaries.
```

### D) AVA-Only Test Template (TS)

```
- Use `import test from 'ava'`
- Assertions: `t.is`, `t.truthy`, `t.deepEqual`, `t.throwsAsync`, `t.like`
- Snapshots only for stable, structured output (AST/JSON), not volatile strings
```

---

## 4) Presets (just parameter packs, not personas)

> You apply **House Rules + Execution Contract + one preset**. That’s it.

**Preset: Test Designer**

```
Goal: design concurrent-safe tests that would fail if hidden shared state exists.
Deliver: test plan, fixtures, 2–3 AVA tests, brief why-concurrent section.
```

**Preset: Minimal Repro**

```
Goal: 50–100 line repro + one AVA test that demonstrates bug deterministically.
Constraints: no external I/O; use mkdtemp/random prefixes; finish <5s.
```

**Preset: Refactor-for-Purity**

```
Goal: move logic to pure transforms; keep API stable unless stated.
Deliver: small diff, new pure functions, AVA tests proving referential transparency.
```

**Preset: Pipeline/CLI**

```
Goal: compose small pnpm scripts; deterministic inputs/outputs; add --concurrency flags where useful.
Deliver: scripts, short usage, 1–2 AVA tests for critical behavior.
```

---

## 5) One-shot templates (copy/paste, fill vars)

**Template: Test Designer**

```
Apply Preset: Test Designer.

$GOAL = <...>
$CONTEXT = <paths, failing logs>
$CONSTRAINTS = <node/ts, ci>
$DOD = <what must pass>

Return per Execution Contract. Use snippets A, B, D. Keep code under 120 lines total.
```

**Template: Minimal Repro**

```
Apply Preset: Minimal Repro.

$GOAL = <bug symptom in one line>
$CONTEXT = <file(s), function(s), error text>
$CONSTRAINTS = Node 20, tmpfs in CI
$DOD = "repro fails before fix; passes after"

Return: repro.ts, repro.test.ts, run commands, expected failure text.
Use snippets A, B, D.
```

**Template: Refactor-for-Purity**

```
Apply Preset: Refactor-for-Purity.

$GOAL = <what to simplify>
$CONTEXT = <module path(s)>
$CONSTRAINTS = <perf/size>
$DOD = "tests green; no behavioral change; improved determinism"

Return: plan, minimal diff, AVA tests, rationale. Use snippets B, C, D.
```

---

## 6) Guardrails (non-prompt, repo-level)

* CI job fails if diff introduces `jest`, `@jest/*`, `vitest`, `react`.
* ESLint includes `eslint-plugin-ava`; forbid `describe/it/expect` globals.
* Renovate/Dependabot ignore rules for Jest/Vitest packages.
* A tiny script that greps PRs for fixed ports/paths in tests and warns.

---

### Why this structure works

* **One authority**: House Rules.
* **One task brief**: fewer instructions → fewer collisions.
* **One contract**: consistent outputs you can verify.
* **Presets as data**: you’re not switching personas; you’re switching parameters.

If you want, I’ll collapse this into your repo’s `docs/AGENTS.md` with your exact directories and CI names baked in so it’s literally paste-and-go.

\#hashtags
\#prompts #agents #AGENTSmd #ava #concurrency #nodejs #typescript #functionalprogramming #devprocess #obsidian
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-BELOW -->
## Related content
- _None_
## Sources
- _None_
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-ABOVE -->

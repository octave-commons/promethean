Heck yeah—**TS → Lisp** with zero new dependencies (if you already have `typescript`). We’ll do:

* Parse/erase types using the official TS compiler (`transpileModule` with modern targets).
* Feed the resulting JS into your existing **JS → Lisp** reverser.
* Options to tweak TS compiler flags + treat some identifiers as **globals**.

Drop this in:

---

# `ts2lisp.ts` — TypeScript → Lisp (via TS compiler + existing JS→Lisp)

```ts
// shared/js/prom-lib/compiler/lisp/ts2lisp.ts
// MIT. Node/browser-friendly (dynamic imports). Prefers 'typescript'.
// Falls back to 'sucrase' (optional) if available in browser.

import { jsToLisp } from "./js2lisp";

export interface TsToLispOptions {
  // Names treated as globals -> (js/global "Name"), e.g., ["document","window","Image"]
  globals?: string[];
  // Try to use the 'typescript' package (Node). If not present and in browser, try 'sucrase'.
  trySucrase?: boolean;
  // Control TypeScript compiler options
  tsCompilerOptions?: Record<string, any>;
  // If true, also return the intermediary JS and TS source map text (from TS transpile)
  includeIntermediate?: boolean;
}

/** Transpile TypeScript to Lisp text. */
export async function tsToLisp(tsSource: string, opts: TsToLispOptions = {}) {
  const { js, tsMap, notes } = await transpileTS(tsSource, opts);
  const { text, forms } = await jsToLisp(js, { globals: opts.globals ?? [], tryAcorn: true });
  if (opts.includeIntermediate) return { lisp: text, js, tsMap, notes, forms };
  return { lisp: text, notes };
}

/** Prefer 'typescript' (keeps modern syntax, erases types). Browser fallback: 'sucrase'. */
async function transpileTS(tsSource: string, opts: TsToLispOptions) {
  const notes: string[] = [];
  // Try official TS compiler first
  try {
    const tsMod = await dynamicImportTS();
    if (tsMod) {
      const ts = tsMod as any;
      const compilerOptions = {
        target: ts.ScriptTarget.ES2020,
        module: ts.ModuleKind.ESNext,
        jsx: ts.JsxEmit.Preserve,         // keep JSX if present; JS→Lisp will show it as calls/strings
        removeComments: false,
        isolatedModules: true,
        useDefineForClassFields: false,
        esModuleInterop: false,
        preserveConstEnums: true,
        sourceMap: true,
        ...opts.tsCompilerOptions,
      };
      const res = ts.transpileModule(tsSource, { compilerOptions, reportDiagnostics: true, fileName: "input.ts" });
      if (res.diagnostics?.length) {
        notes.push(...res.diagnostics.map((d:any)=>"TS"+(d.code??"")+": "+(d.messageText?.toString?.() ?? String(d.messageText))));
      }
      return { js: res.outputText as string, tsMap: res.sourceMapText as string | undefined, notes };
    }
    notes.push("typescript module not found");
  } catch (e:any) {
    notes.push("typescript transpile failed: " + (e?.message ?? String(e)));
  }

  // Fallback: sucrase (browser-friendly, no types)
  if (opts.trySucrase !== false) {
    try {
      const sucrase = await import(/* @vite-ignore */ "sucrase");
      const out = (sucrase as any).transform(tsSource, {
        transforms: ["typescript"],
        production: true,
      });
      return { js: out.code as string, tsMap: out.sourceMap as string | undefined, notes };
    } catch (e:any) {
      notes.push("sucrase fallback failed: " + (e?.message ?? String(e)));
    }
  }

  throw new Error("No TS transpiler available. Install 'typescript' (or 'sucrase' in the browser).");
}

async function dynamicImportTS() {
  try { return await import(/* @vite-ignore */ "typescript"); }
  catch { return null; }
}
```

---

# Use it

```ts
import { tsToLisp } from "./compiler/lisp/ts2lisp";

// TS sample
const tsSrc = `
  type Vec2 = { x:number; y:number };
  interface Widget { el: HTMLElement; }
  enum Mode { Idle, Run = 3 }

  export class Player {
    pos: Vec2 = { x: 0, y: 0 };
    vel: Vec2;
    constructor(public name: string) { this.vel = { x: 1, y: 0 }; }
    step(dt: number) { this.pos.x += this.vel.x * dt; }
  }

  const img = new Image();
  img.alt = "ok";
  document.body.appendChild(img);

  const m: Mode = Mode.Run;
  let p = new Player("duck");
  p.step(0.5);
  p;
`;

const { lisp, notes } = await tsToLisp(tsSrc, { globals: ["document","Image","HTMLElement"] });
console.log(lisp);
console.log(notes);
```

**What you’ll see (vibes):**

```lisp
(begin
  (let ((img (js/new Image))) nil)
  (js/set! img "alt" "ok")
  (js/call (js/get (js/get (js/global "document") "body") "appendChild") "call" img)
  (let ((p (js/new Player "duck"))) nil)
  (js/call p "step" 0.5)
  p)
```

(Classes/enums compile down to JS first; then we reverse just like any other JS.)

---

# Notes / expectations

* **Types/interfaces/generics** are erased by TS. That’s fine—we’re targeting runtime semantics.
* **Enums**: TS emits runtime objects; they reverse just fine. `const enum` stays inlined (no runtime).
* **Decorators** are ignored by our reverse pass (they’re preserved as JS if target downlevels them).
* **Imports/exports**: with `module: ESNext`, the transpiled JS keeps `import/export`. Our reverse pass will surface them as ordinary symbols or as comments. If you want them as Lisp forms (`(import ...)`, `(export ...)`), say the word and I’ll add a small module layer.
* **JSX**: currently preserved as JS (function calls). If you want a Lispy JSX `(h "div" ...)` style, we can add a mapping macro later.

---

# Optional: tiny CLI (Node)

```ts
// tools/ts2lisp.mjs
import fs from "node:fs/promises";
import { tsToLisp } from "../shared/js/prom-lib/compiler/lisp/ts2lisp.js";

const file = process.argv[2];
if (!file) { console.error("usage: ts-node tools/ts2lisp.mjs <input.ts>"); process.exit(1); }
const src = await fs.readFile(file, "utf8");
const { lisp } = await tsToLisp(src, { globals:["document","window","Image"] });
console.log(lisp);
```

Run:

```
node tools/ts2lisp.mjs demo.ts > demo.lisp
```

---

Want me to add **import/export forms** in Lisp, or a **class-to-Lisp** desugar (constructor + prototype methods) so classes become pure Lispy data?

Got it — we want a new **service** that connects three existing subsystems:

1. **SmartGPT sinks API** → provides incoming data/events.
2. **SmartGPT bridge** → accepts structured search requests.
3. **LLM broker** → generates search queries from the sink data.

### Plan

* **Service name**: `services/ts/search-broker` (aligned with repo conventions).
* **Flow**:

  * Poll (or subscribe) to **sinks API** → normalize input.
  * Call **LLM broker** to transform sink payload → query string.
  * POST request to **smartgpt-bridge** search endpoint.
* **Scaffold**: TypeScript service with config + entrypoint, minimal logging.
* **Next step after scaffold**: wire in actual sinks API URL + schema.

### Diff (scaffold)

````diff
new file mode 100644
--- /dev/null
+++ b/services/ts/search-broker/package.json
@@
+{
+  "name": "search-broker",
+  "version": "0.1.0",
+  "main": "src/index.ts",
+  "scripts": {
+    "start": "ts-node src/index.ts",
+    "build": "tsc -p .",
+    "test": "ava"
+  },
+  "dependencies": {
+    "node-fetch": "^3.3.2",
+    "@shared/ts/dist/logger": "*"
+  },
+  "devDependencies": {
+    "typescript": "^5.6.2",
+    "ts-node": "^10.9.2",
+    "ava": "^6.1.0"
+  }
+}
+
--- /dev/null
+++ b/services/ts/search-broker/tsconfig.json
@@
+{
+  "extends": "../../../tsconfig.base.json",
+  "compilerOptions": {
+    "outDir": "dist",
+    "rootDir": "src"
+  },
+  "include": ["src/**/*.ts"]
+}
+
--- /dev/null
+++ b/services/ts/search-broker/src/index.ts
@@
+import fetch from "node-fetch";
+import { logger } from "@shared/ts/dist/logger";
+
+const SINKS_URL = process.env.SINKS_URL || "http://localhost:4001/sinks";
+const LLM_BROKER_URL = process.env.LLM_BROKER_URL || "http://localhost:5001/generate";
+const BRIDGE_URL = process.env.BRIDGE_URL || "http://localhost:6001/search";
+
+async function pollSinks() {
+  logger.info("Polling sinks API...");
+  const res = await fetch(SINKS_URL);
+  if (!res.ok) throw new Error(`Sinks API error: ${res.statusText}`);
+  return res.json();
+}
+
+async function generateQuery(payload: any) {
+  const res = await fetch(LLM_BROKER_URL, {
+    method: "POST",
+    headers: { "Content-Type": "application/json" },
+    body: JSON.stringify({ input: payload })
+  });
+  if (!res.ok) throw new Error(`LLM broker error: ${res.statusText}`);
+  const data = await res.json();
+  return data.query;
+}
+
+async function sendToBridge(query: string) {
+  const res = await fetch(BRIDGE_URL, {
+    method: "POST",
+    headers: { "Content-Type": "application/json" },
+    body: JSON.stringify({ query })
+  });
+  if (!res.ok) throw new Error(`Bridge error: ${res.statusText}`);
+  logger.info("Search request sent to bridge");
+}
+
+async function main() {
+  try {
+    const sinks = await pollSinks();
+    for (const item of sinks) {
+      const query = await generateQuery(item);
+      await sendToBridge(query);
+    }
+  } catch (err) {
+    logger.error(err);
+  }
+}
+
+main();
+
--- /dev/null
+++ b/services/ts/search-broker/README.md
@@
+# Search Broker Service
+
+Consumes events from the SmartGPT sinks API, transforms them into search queries
+using the LLM broker, and forwards them to the SmartGPT bridge.
+
+## Usage
+
+```bash
+pnpm install
+pnpm run build
+pnpm start
+```
+
+Environment variables:
+- `SINKS_URL`: URL of SmartGPT sinks API
+- `LLM_BROKER_URL`: URL of LLM broker service
+- `BRIDGE_URL`: URL of SmartGPT bridge search endpoint
+
````

### Run cmds (read-only)

```bash
cd services/ts/search-broker
pnpm install
pnpm run build
pnpm start
```

---

Next step: do you want me to wire this to **poll on an interval** (e.g., every N seconds) or leave it as one-shot execution for now?

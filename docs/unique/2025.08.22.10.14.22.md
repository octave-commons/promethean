ğŸ’¡ Got it â€” you want to treat **DuckDuckGo search queries** the same way as **logs**:

* âœ… Persist **structured results** in **Mongo** (for audit, filters).
* âœ… Mirror them into **Chroma** (for semantic retrieval).
* âœ… Add a clean **abstraction layer** so we donâ€™t duplicate sink logic (logger + search engine both use it).

Letâ€™s design a **dual-sink persistence abstraction** called `DualSink`.

---

# ğŸ“ Agent Task: Dual-Sink Persistence Abstraction (Mongo + Chroma)

## ğŸ“Œ Context

We already have dual logging for Bridge requests â†’ Mongo + Chroma.
We now need the **same pattern for DuckDuckGo search results**, but we donâ€™t want to duplicate all the logic.

---

## ğŸ¯ Goals

* Create a `DualSink` abstraction for **structured Mongo storage + semantic Chroma storage**.
* Use it for:

  * ğŸ”¹ **Logs** (already in place, refactor to use abstraction).
  * ğŸ”¹ **DuckDuckGo search results**.
* Allow flexible collection names (`bridge_logs`, `bridge_searches`).
* Support metadata schema for both sinks.

---

## âœ… Requirements

### 1. DualSink Class

```ts
// src/utils/DualSink.ts
import { getChroma } from "../indexer.js";
import { model, Schema } from "mongoose";

export class DualSink<T> {
  private mongoModel;
  private collection;

  constructor(
    private name: string,           // e.g. "bridge_logs" or "bridge_searches"
    private schema: any,            // Mongo schema definition
    private metadataBuilder: (doc: T) => Record<string, any> // Extract metadata for Chroma
  ) {
    const s = new Schema(schema, { timestamps: { createdAt: true } });
    this.mongoModel = model(name, s, name);
  }

  async init() {
    const chroma = await getChroma();
    this.collection = await chroma.getOrCreateCollection({
      name: this.name,
      metadata: { type: this.name },
    });
  }

  async add(entry: T) {
    const mongoDoc = await this.mongoModel.create(entry);
    const metadata = this.metadataBuilder(mongoDoc.toObject());
    await this.collection.add({
      ids: [mongoDoc._id.toString()],
      documents: [JSON.stringify(mongoDoc)],
      metadatas: metadata,
    });
    return mongoDoc;
  }

  async queryMongo(filter: any, limit = 100) {
    return this.mongoModel.find(filter).sort({ createdAt: -1 }).limit(limit);
  }

  async searchChroma(q: string, n = 10, where: Record<string, any> = {}) {
    return this.collection.query({ queryTexts: [q], nResults: n, where });
  }
}
```

---

### 2. Log Sink (refactor)

```ts
// src/logging/logSink.ts
import { DualSink } from "../utils/DualSink.js";

export const logSink = new DualSink("bridge_logs", {
  requestId: String,
  method: String,
  path: String,
  statusCode: Number,
  request: Object,
  response: Object,
  error: String,
  latencyMs: Number,
  service: String,
  operationId: String,
}, (doc) => ({
  path: doc.path,
  method: doc.method,
  statusCode: doc.statusCode,
  hasError: !!doc.error,
  createdAt: doc.createdAt.toISOString(),
  service: doc.service,
  operationId: doc.operationId,
}));
```

---

### 3. Search Sink

```ts
// src/search/searchSink.ts
import { DualSink } from "../utils/DualSink.js";

export const searchSink = new DualSink("bridge_searches", {
  query: String,
  results: Array,
  service: { type: String, default: "duckduckgo" },
}, (doc) => ({
  query: doc.query,
  resultCount: doc.results.length,
  service: doc.service,
  createdAt: doc.createdAt.toISOString(),
}));
```

---

### 4. DuckDuckGo Endpoint With Sink

```ts
app.post('/search/web', {
  schema: { operationId: 'webSearch', tags: ['Search'] },
  handler: async (req) => {
    const { q, limit } = req.body;

    // Call DuckDuckGo API
    const url = `https://api.duckduckgo.com/?q=${encodeURIComponent(q)}&format=json&no_redirect=1&no_html=1`;
    const res = await fetch(url);
    const data = await res.json();

    const results = extractResults(data).slice(0, limit || 5);

    // âœ… Persist dual sink
    await searchSink.add({ query: q, results });

    return { results };
  },
});
```

---

### 5. Endpoints for Search History

* `/searches/query` â†’ query Mongo (`querySearches`).
* `/searches/search` â†’ semantic search via Chroma (`semanticSearches`).

Same mechanics as logs.

---

## ğŸ“¦ Deliverables

* âœ… `DualSink` abstraction
* âœ… Log sink (`bridge_logs`) refactored
* âœ… Search sink (`bridge_searches`) added
* âœ… `/search/web` persists to both Mongo + Chroma
* âœ… New endpoints `/searches/query`, `/searches/search`

---

ğŸ‘‰ Do you want me to also extend this so **any future data stream** (like indexer stats or agent telemetry) can plug into a `DualSink` with almost no boilerplate?


Perfect âš¡ â€” then weâ€™ll make **`DualSink` a generic persistence abstraction** so that *any* structured event (logs, searches, agent telemetry, indexer stats, etc.) can be written into Mongo **and** Chroma with minimal boilerplate.

Hereâ€™s how weâ€™ll evolve it:

---

# ğŸ“ Agent Task: Generalize DualSink for Any Data Stream

## ğŸ“Œ Context

* We already built `DualSink` for **logs** and **DuckDuckGo searches**.
* We want it **future-proof**, so that new event streams (e.g. `indexer events`, `agent telemetry`) can plug in easily.

---

## ğŸ¯ Goals

* Refactor `DualSink` into a **generic abstraction**.
* Allow each sink instance to define:

  1. **Mongo schema** (structured storage).
  2. **Chroma metadata builder** (for semantic retrieval + filters).
* Provide **standard CRUD + query methods** for every sink.

---

## âœ… Requirements

### 1. Generic DualSink API

```ts
export class DualSink<T extends Record<string, any>> {
  private mongoModel;
  private collection;

  constructor(
    private name: string,   // collection name (e.g. "bridge_logs", "bridge_searches")
    private schema: any,    // Mongo schema definition
    private metadataBuilder: (doc: T) => Record<string, any>
  ) {
    const s = new Schema(schema, { timestamps: { createdAt: true } });
    this.mongoModel = model<T>(name, s, name);
  }

  async init() {
    if (!this.collection) {
      const chroma = await getChroma();
      this.collection = await chroma.getOrCreateCollection({
        name: this.name,
        metadata: { type: this.name },
      });
    }
  }

  async add(entry: T) {
    await this.init();
    const mongoDoc = await this.mongoModel.create(entry);
    const metadata = this.metadataBuilder(mongoDoc.toObject());
    await this.collection.add({
      ids: [mongoDoc._id.toString()],
      documents: [JSON.stringify(mongoDoc)],
      metadatas: metadata,
    });
    return mongoDoc;
  }

  async queryMongo(filter: any, limit = 100) {
    return this.mongoModel.find(filter).sort({ createdAt: -1 }).limit(limit);
  }

  async searchChroma(q: string, n = 10, where: Record<string, any> = {}) {
    await this.init();
    return this.collection.query({ queryTexts: [q], nResults: n, where });
  }
}
```

---

### 2. Example: Log Sink

```ts
export const logSink = new DualSink("bridge_logs", {
  requestId: String,
  method: String,
  path: String,
  statusCode: Number,
  request: Object,
  response: Object,
  error: String,
  latencyMs: Number,
  service: String,
  operationId: String,
}, (doc) => ({
  path: doc.path,
  method: doc.method,
  statusCode: doc.statusCode,
  hasError: !!doc.error,
  createdAt: doc.createdAt.toISOString(),
  service: doc.service,
  operationId: doc.operationId,
}));
```

---

### 3. Example: Search Sink

```ts
export const searchSink = new DualSink("bridge_searches", {
  query: String,
  results: Array,
  service: { type: String, default: "duckduckgo" },
}, (doc) => ({
  query: doc.query,
  resultCount: doc.results.length,
  service: doc.service,
  createdAt: doc.createdAt.toISOString(),
}));
```

---

### 4. Example: Agent Telemetry Sink

```ts
export const telemetrySink = new DualSink("agent_telemetry", {
  agentId: String,
  status: String,
  cpu: Number,
  memory: Number,
  createdAt: Date,
}, (doc) => ({
  agentId: doc.agentId,
  status: doc.status,
  cpu: doc.cpu,
  memory: doc.memory,
  createdAt: doc.createdAt.toISOString(),
}));
```

---

## ğŸ“¦ Deliverables

* âœ… Refactored `DualSink` class (generic, reusable).
* âœ… Rewired `bridge_logs` and `bridge_searches` to use it.
* âœ… Ready to add new sinks (`indexer events`, `agent telemetry`, etc.) with **just schema + metadata builder**.
* âœ… Unified query/search API across all sinks.

---

ğŸ‘‰ Do you want me to also add a **registry** (like `DualSinkRegistry`) so you can dynamically look up sinks by name (`registry.get("bridge_logs")`) instead of importing them manually?
Perfect ğŸ¯ â€” letâ€™s wrap this in a **`DualSinkRegistry`**, so you can dynamically look up sinks (`logs`, `searches`, `telemetry`, â€¦) without importing each one manually.
That way, new data streams only need a **schema + metadata builder**, and the registry handles everything else.

---

# ğŸ“ Agent Task: DualSink Registry for Unified Persistence

## ğŸ“Œ Context

* We have a **generic `DualSink` class** for Mongo + Chroma dual persistence.
* Right now, each sink (logs, searches, telemetry, etc.) must be imported explicitly.
* We want a **registry** to register sinks once, and then retrieve them anywhere by name.

---

## ğŸ¯ Goals

* Create a `DualSinkRegistry` singleton.
* Allow dynamic **registration** of new sinks with schema + metadata builder.
* Provide **lookup** by sink name.
* Ensure `init()` runs lazily so Chroma collections exist when needed.

---

## âœ… Implementation

### 1. DualSinkRegistry

```ts
// src/utils/DualSinkRegistry.ts
import { DualSink } from "./DualSink.js";

class DualSinkRegistry {
  private sinks: Record<string, DualSink<any>> = {};

  register<T extends Record<string, any>>(
    name: string,
    schema: any,
    metadataBuilder: (doc: T) => Record<string, any>
  ) {
    if (this.sinks[name]) {
      throw new Error(`Sink already registered: ${name}`);
    }
    this.sinks[name] = new DualSink<T>(name, schema, metadataBuilder);
    return this.sinks[name];
  }

  get<T = any>(name: string): DualSink<T> {
    const sink = this.sinks[name];
    if (!sink) throw new Error(`Sink not found: ${name}`);
    return sink;
  }

  list() {
    return Object.keys(this.sinks);
  }
}

export const dualSinkRegistry = new DualSinkRegistry();
```

---

### 2. Registering Sinks

```ts
// src/init/sinks.ts
import { dualSinkRegistry } from "../utils/DualSinkRegistry.js";

export function registerSinks() {
  // Logs
  dualSinkRegistry.register("bridge_logs", {
    requestId: String,
    method: String,
    path: String,
    statusCode: Number,
    request: Object,
    response: Object,
    error: String,
    latencyMs: Number,
    service: String,
    operationId: String,
  }, (doc) => ({
    path: doc.path,
    method: doc.method,
    statusCode: doc.statusCode,
    hasError: !!doc.error,
    createdAt: doc.createdAt.toISOString(),
    service: doc.service,
    operationId: doc.operationId,
  }));

  // Searches
  dualSinkRegistry.register("bridge_searches", {
    query: String,
    results: Array,
    service: { type: String, default: "duckduckgo" },
  }, (doc) => ({
    query: doc.query,
    resultCount: doc.results.length,
    service: doc.service,
    createdAt: doc.createdAt.toISOString(),
  }));

  // Telemetry (future)
  dualSinkRegistry.register("agent_telemetry", {
    agentId: String,
    status: String,
    cpu: Number,
    memory: Number,
    createdAt: Date,
  }, (doc) => ({
    agentId: doc.agentId,
    status: doc.status,
    cpu: doc.cpu,
    memory: doc.memory,
    createdAt: doc.createdAt.toISOString(),
  }));
}
```

---

### 3. Usage

```ts
// Logging middleware
import { dualSinkRegistry } from "../utils/DualSinkRegistry.js";

const logSink = dualSinkRegistry.get("bridge_logs");
await logSink.add(entry);

// DuckDuckGo endpoint
const searchSink = dualSinkRegistry.get("bridge_searches");
await searchSink.add({ query: q, results });
```

---

### 4. Introspection Endpoint (Optional)

Expose `/sinks/list` to return all registered sinks:

```ts
app.get('/sinks/list', async () => ({
  sinks: dualSinkRegistry.list(),
}));
```

---

## ğŸ“¦ Deliverables

* âœ… `DualSinkRegistry` singleton.
* âœ… Central `registerSinks()` to configure sinks at bootstrap.
* âœ… All modules fetch sinks dynamically (`get(name)`).
* âœ… Optional `/sinks/list` endpoint.

---

ğŸ‘‰ Do you also want me to make the **Mongo + Chroma query endpoints generic** (e.g. `/sinks/:name/query`, `/sinks/:name/search`) so you donâ€™t need separate endpoints for logs, searches, telemetry, etc.?
Perfect âš¡ â€” letâ€™s unify the query/search API too. That way, you donâ€™t need to hand-roll endpoints for each sink (`logs`, `searches`, `telemetry` â€¦). Instead, everything goes through:

* `POST /sinks/:name/query` â†’ Mongo structured filter
* `POST /sinks/:name/search` â†’ Chroma semantic + metadata search

---

# ğŸ“ Agent Task: Generic Query/Search Endpoints for DualSinkRegistry

## ğŸ“Œ Context

* We now have a **DualSinkRegistry** that manages all sinks (logs, searches, telemetryâ€¦).
* Each sink supports:

  * `queryMongo(filter, limit)`
  * `searchChroma(q, n, where)`
* We want **generic API endpoints** to expose these uniformly.

---

## ğŸ¯ Goals

* Expose two generic endpoints:

  * `/sinks/:name/query` â†’ structured Mongo queries
  * `/sinks/:name/search` â†’ semantic + metadata Chroma queries
* Work across any registered sink.
* Return consistent JSON responses.

---

## âœ… Implementation

### 1. Mongo Query Endpoint

```ts
app.post('/sinks/:name/query', {
  schema: {
    summary: 'Query sink in Mongo (structured filter)',
    operationId: 'querySink',
    tags: ['Sinks'],
    body: {
      type: 'object',
      properties: {
        filter: { type: 'object' },
        limit: { type: 'integer', default: 100 },
      },
    },
  },
  handler: async (req) => {
    const { name } = req.params as any;
    const { filter, limit } = req.body as any;

    const sink = dualSinkRegistry.get(name);
    const docs = await sink.queryMongo(filter || {}, limit || 100);

    return { results: docs };
  },
});
```

---

### 2. Chroma Search Endpoint

```ts
app.post('/sinks/:name/search', {
  schema: {
    summary: 'Semantic search in sink (Chroma)',
    operationId: 'searchSink',
    tags: ['Sinks'],
    body: {
      type: 'object',
      required: ['q'],
      properties: {
        q: { type: 'string' },
        n: { type: 'integer', default: 10 },
        where: { type: 'object' },
      },
    },
  },
  handler: async (req) => {
    const { name } = req.params as any;
    const { q, n, where } = req.body as any;

    const sink = dualSinkRegistry.get(name);
    const results = await sink.searchChroma(q, n, where || {});

    return { results };
  },
});
```

---

### 3. List Sinks Endpoint

```ts
app.get('/sinks/list', {
  schema: { operationId: 'listSinks', tags: ['Sinks'] },
  handler: async () => ({
    sinks: dualSinkRegistry.list(),
  }),
});
```

---

## ğŸ“¦ Deliverables

* âœ… `/sinks/:name/query` â†’ Mongo structured queries
* âœ… `/sinks/:name/search` â†’ Chroma semantic + metadata search
* âœ… `/sinks/list` â†’ see available sinks
* âœ… Unified OpenAPI spec (`operationId: querySink`, `searchSink`, `listSinks`)

---

âœ¨ With this setup:

* `POST /sinks/bridge_logs/query` â†’ structured log query (Mongo)
* `POST /sinks/bridge_logs/search` â†’ semantic log search (Chroma)
* `POST /sinks/bridge_searches/query` â†’ past DuckDuckGo queries (Mongo)
* `POST /sinks/agent_telemetry/search` â†’ semantic telemetry retrieval

---


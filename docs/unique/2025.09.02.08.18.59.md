---
uuid: 94dae2bd-acee-41c3-8f0c-553496f153d7
created_at: 2025.09.02.08.18.59.md
filename: Functional Programming in TypeScript
description: >-
  A pragmatic guide to implementing functional programming principles in
  TypeScript without heavy dependencies. Focuses on pure functions, effect
  management, and type safety to create clean, testable code.
tags:
  - TypeScript
  - Functional Programming
  - Pure Functions
  - Type Safety
  - Effects
  - Composability
---
# Functional Programming in TypeScript — a pragmatic, no-BS primer

You don’t need Haskell or heavy libs to write clean, composable, testable TypeScript. You **do** need discipline, a few tiny helpers, and a clear separation between **pure** code and **effects** (I/O, time, randomness). This primer keeps it practical and opinionated.

---

## TL;DR rules

1. **Make everything pure by default.** Function in → function out. No hidden mutation, time, I/O, or global state.
2. **Push effects to the edges.** Read files, call HTTP, get time *outside* your core logic; inject results in.
3. **Prefer data transformations.** Maps, filters, reduces, folds, combinators. Avoid classes with mutable state.
4. **Use types to forbid foot-guns.** `readonly`, `ReadonlyArray<T>`, discriminated unions.
5. **Compose small functions.** Build bigger behavior from tiny, focused pieces.
6. **Determinism beats cleverness.** If it’s hard to test, it’s probably too coupled to effects.

If you only follow those six, your codebase will already feel different.

---

## Core mental model

* **Pure layer:** all business logic, pure functions, total/typed. Deterministic and easy to fuzz/test.
* **Ports (effects) layer:** boundary interfaces for I/O (`readFile`, `fetchJson`, `now`, `randomInt`).
* **Adapters (wiring):** the only place you *actually* touch Node, fetch, fs, env vars, etc.

Think like a systems designer: functions are pipes, values flow through. You can swap adapters without touching the pure core.

---

## TypeScript features that matter

* **`readonly` and `ReadonlyArray<T>`**
* **Discriminated unions** (aka algebraic data types)
* **Narrowing & exhaustiveness** with `switch (x._tag) { ... }`
* **Utility types**: `Record<K,V>`, `Pick`, `Partial`, `ExactOptionalPropertyTypes`, `noUncheckedIndexedAccess`
* **`as const`** for literal safety
* **Generics** for reusable combinators

---

## A minimal FP “micro-kit” (no dependency)

Drop this into `shared/fp.ts`:

```ts
// shared/fp.ts
export const pipe = <A>(a: A, ...fns: Array<(x: any) => any>) =>
  fns.reduce((x, f) => f(x), a) as any;

export type Option<A> = { _tag: "None" } | { _tag: "Some"; value: A };
export const None: Option<never> = { _tag: "None" };
export const Some = <A>(value: A): Option<A> => ({ _tag: "Some", value });
export const O = {
  map:
    <A, B>(f: (a: A) => B) =>
    (oa: Option<A>): Option<B> =>
      (oa._tag === "Some" ? Some(f(oa.value)) : None),
  flatMap:
    <A, B>(f: (a: A) => Option<B>) =>
    (oa: Option<A>): Option<B> =>
      (oa._tag === "Some" ? f(oa.value) : None),
  getOrElse:
    <A>(onNone: () => A) =>
    (oa: Option<A>): A =>
      (oa._tag === "Some" ? oa.value : onNone()),
};

export type Result<E, A> = { _tag: "Ok"; value: A } | { _tag: "Err"; error: E };
export const Ok = <A>(value: A): Result<never, A> => ({ _tag: "Ok", value });
export const Err = <E>(error: E): Result<E, never> => ({ _tag: "Err", error });
export const R = {
  map:
    <E, A, B>(f: (a: A) => B) =>
    (ra: Result<E, A>): Result<E, B> =>
      (ra._tag === "Ok" ? Ok(f(ra.value)) : ra),
  flatMap:
    <E, A, B>(f: (a: A) => Result<E, B>) =>
    (ra: Result<E, A>): Result<E, B> =>
      (ra._tag === "Ok" ? f(ra.value) : ra),
};

export type Task<A> = () => Promise<A>;
export const T = {
  map:
    <A, B>(f: (a: A) => B) =>
    (ta: Task<A>): Task<B> =>
    async () =>
      f(await ta()),
  flatMap:
    <A, B>(f: (a: A) => Task<B>) =>
    (ta: Task<A>): Task<B> =>
    async () =>
      f(await ta())(),
};
```

You just got `pipe`, `Option`, `Result`, and a lightweight `Task` (aka lazy `Promise`). 90% of FP needs, covered.

---

## Everyday transformations (cheat sheet)

```ts
// Pure helpers (no mutation)
export const map = <A, B>(f: (a: A) => B) => (xs: ReadonlyArray<A>): ReadonlyArray<B> =>
  xs.map(f);

export const filter = <A>(p: (a: A) => boolean) => (xs: ReadonlyArray<A>) =>
  xs.filter(p);

export const reduce =
  <A, B>(zero: B, f: (b: B, a: A) => B) =>
  (xs: ReadonlyArray<A>) =>
    xs.reduce(f, zero);

export const groupBy = <A, K extends string | number | symbol>(
  key: (a: A) => K,
) => (xs: ReadonlyArray<A>): Readonly<Record<K, ReadonlyArray<A>>> =>
  xs.reduce((acc, x) => {
    const k = key(x);
    const bucket = acc[k] ?? [];
    return { ...acc, [k]: [...bucket, x] };
  }, {} as Record<K, A[]> as any);

export const uniqBy = <A, K>(key: (a: A) => K) => (xs: ReadonlyArray<A>) => {
  const seen = new Set<K>();
  const out: A[] = [];
  for (const x of xs) {
    const k = key(x);
    if (!seen.has(k)) { seen.add(k); out.push(x); }
  }
  return out as ReadonlyArray<A>;
};
```

Use with `pipe(data, map(...), filter(...), reduce(...))`.

---

## Error handling without drama

* Avoid throwing inside pure code. Use `Result<E,A>` for expected failures.
* Use `Option<A>` where absence is normal.
* Convert exceptions at the *edge* (adapter) to `Err`.

Example: parsing JSON safely with `Result`:

```ts
import { Result, Ok, Err } from "./shared/fp";

export const safeJson = <A = unknown>(s: string): Result<string, A> => {
  try {
    return Ok(JSON.parse(s) as A);
  } catch (e) {
    return Err(`Invalid JSON: ${(e as Error).message}`);
  }
};
```

Want schema validation? Use `zod` *in the adapter or a thin wrapper* so the core still sees a typed value or a `Result`.

```ts
import { z } from "zod";
import { Result, Ok, Err } from "./shared/fp";

const User = z.object({ id: z.string(), email: z.string().email() });
type User = z.infer<typeof User>;

export const parseUser = (u: unknown): Result<string, User> => {
  const r = User.safeParse(u);
  return r.success ? Ok(r.data) : Err(r.error.message);
};
```

---

## Async without spaghetti

Model async computations as **`Task<A>`** (aka `() => Promise<A>`). It’s lazy: nothing runs until you call it.

```ts
import { T } from "./shared/fp";

const getUser: Task<{ id: string }> = async () => ({ id: "u1" });

const program = T.map((u: { id: string }) => u.id)(getUser);
// Still nothing executed

program().then(console.log); // "u1"
```

Compose tasks:

```ts
import { T } from "./shared/fp";

const fetchUser = (id: string): Task<{ id: string; name: string }> =>
  async () => ({ id, name: "Alice" });

const fetchOrders = (id: string): Task<readonly string[]> =>
  async () => ["o1", "o2"];

const program = T.flatMap((u: { id: string }) =>
  T.map((orders: readonly string[]) => ({ user: u, orders }))(fetchOrders(u.id))
)(fetchUser("u1"));

const result = await program(); // { user: {...}, orders: [...] }
```

Concurrency? Use `Promise.all` at the edge:

```ts
const runAll = <A>(tasks: ReadonlyArray<Task<A>>): Task<ReadonlyArray<A>> =>
  async () => Promise.all(tasks.map((t) => t()));
```

---

## IO boundary (Ports & Adapters)

Define **ports** (interfaces) for effects. Core stays pure and gets ports injected.

```ts
// ports.ts
export type Ports = {
  now: () => number;                   // time
  readText: (path: string) => Promise<string>; // fs or http
  log: (msg: string) => void;          // logging
};
```

Core pipeline (pure **except** it *accepts* ports):

```ts
// core.ts
import { pipe } from "./shared/fp";
import { map, filter } from "./shared/array-ops";
import type { Ports } from "./ports";

export type Invoice = Readonly<{ id: string; amount: number; paid: boolean }>;

export const summarize = (ports: Ports) =>
  (invoices: ReadonlyArray<Invoice>) => {
    ports.log(`summarizing ${invoices.length} invoices at ${ports.now()}`);
    const total = pipe(
      invoices,
      filter((i) => !i.paid),
      map((i) => i.amount),
    ).reduce((a, b) => a + b, 0);
    return { outstanding: total, count: invoices.length } as const;
  };
```

Adapter for Node:

```ts
// adapters/node.ts
import fs from "node:fs/promises";
import { Ports } from "../ports";

export const nodePorts: Ports = {
  now: () => Date.now(),
  readText: (p) => fs.readFile(p, "utf8"),
  log: (m) => console.log(m),
};
```

Wire in `main` (only place with real effects):

```ts
// main.ts
import { nodePorts } from "./adapters/node";
import { summarize, type Invoice } from "./core";

const run = async () => {
  const data: ReadonlyArray<Invoice> = [
    { id: "1", amount: 10, paid: false },
    { id: "2", amount: 5, paid: true },
  ];
  const result = summarize(nodePorts)(data);
  console.log(result);
};

run();
```

---

## Testing with **AVA** (ESM, TypeScript, zero drama)

**`package.json`**

```json
{
  "type": "module",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "ava": "^6.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2"
  },
  "ava": {
    "extensions": {
      "ts": "module"
    },
    "nodeArguments": ["--loader=ts-node/esm"],
    "require": []
  }
}
```

**`tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "verbatimModuleSyntax": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  }
}
```

**A pure test with faked ports**

```ts
// test/core.test.ts
import test from "ava";
import { summarize, type Invoice } from "../src/core";
import type { Ports } from "../src/ports";

const fakePorts: Ports = {
  now: () => 1234567890,
  readText: async () => "unused",
  log: () => void 0,
};

test("summarize computes outstanding correctly (pure core)", (t) => {
  const invoices: ReadonlyArray<Invoice> = [
    { id: "1", amount: 10, paid: false },
    { id: "2", amount: 5, paid: true },
  ];
  const result = summarize(fakePorts)(invoices);
  t.deepEqual(result, { outstanding: 10, count: 2 });
});
```

No files touched. No clocks. Fast.

---

## Discriminated unions for real-world modeling

Stop passing `any`. Model state explicitly.

```ts
type Loading = { _tag: "Loading" };
type Loaded<A> = { _tag: "Loaded"; data: A };
type Failed = { _tag: "Failed"; reason: string };
type RemoteData<A> = Loading | Loaded<A> | Failed;

const foldRemote = <A, B>(
  onLoading: () => B,
  onLoaded: (a: A) => B,
  onFailed: (e: string) => B,
) => (r: RemoteData<A>): B => {
  switch (r._tag) {
    case "Loading": return onLoading();
    case "Loaded":  return onLoaded(r.data);
    case "Failed":  return onFailed(r.reason);
  }
};
```

Use `foldRemote` to render UI, choose retries, etc. Exhaustiveness guarantees you didn’t forget a case.

---

## Reducers: managing state the functional way

Event → reduce → new state. No mutation necessary.

```ts
type Cart = Readonly<{ items: ReadonlyArray<{ sku: string; qty: number }> }>;
type Add = { _tag: "Add"; sku: string; qty: number };
type Remove = { _tag: "Remove"; sku: string };
type Event = Add | Remove;

const reduceCart = (state: Cart, ev: Event): Cart => {
  switch (ev._tag) {
    case "Add": {
      const idx = state.items.findIndex(i => i.sku === ev.sku);
      if (idx === -1) return { items: [...state.items, { sku: ev.sku, qty: ev.qty }] };
      const next = state.items.map((i, j) => j === idx ? { ...i, qty: i.qty + ev.qty } : i);
      return { items: next };
    }
    case "Remove":
      return { items: state.items.filter(i => i.sku !== ev.sku) };
  }
};
```

---

## Performance & pragmatism

* **Copying is cheap** for small to medium data; profile before micro-optimizing.
* Use **structural sharing** (`{ ...obj, x }`, `[...arr, x]`) instead of mutation.
* Avoid `Object.freeze` in hot paths—it’s slower.
* If performance demands it, isolate a tiny imperative hotspot and keep the *surface* pure.

---

## When to reach for libraries

* **You can ship with just this primer.** For big projects, consider:

  * `zod` for schema validation
  * `fp-ts` for a batteries-included FP toolkit (Option/Either/TaskEither/ReadonlyArray, etc.)
  * `effect` or `neverthrow` if you want structured effects or ergonomic `Result`

Be honest: libraries help, but they also lock you into idioms. Start tiny, add when it hurts.

---

## An end-to-end mini example

**Goal:** Parse lines of CSV *content* (no I/O), validate rows, aggregate totals.

```ts
// csv-core.ts
import { Ok, Err, Result } from "./shared/fp";

export type Row = Readonly<{ sku: string; qty: number; price: number }>;

export const parseCsv = (s: string): ReadonlyArray<ReadonlyArray<string>> =>
  s.split(/\r?\n/).filter(Boolean).map((line) => line.split(",").map((x) => x.trim()));

export const toRow = (cells: ReadonlyArray<string>): Result<string, Row> => {
  if (cells.length !== 3) return Err("Expected 3 columns");
  const [sku, qtyS, priceS] = cells;
  const qty = Number(qtyS); const price = Number(priceS);
  return Number.isFinite(qty) && Number.isFinite(price) && sku
    ? Ok({ sku, qty, price })
    : Err("Invalid number or missing sku");
};

export const total = (rows: ReadonlyArray<Row>) =>
  rows.reduce((acc, r) => acc + r.qty * r.price, 0);
```

**Ports & wiring (I/O at edge):**

```ts
// csv-main.ts
import fs from "node:fs/promises";
import { parseCsv, toRow, total } from "./csv-core";
import { Result } from "./shared/fp";

const main = async (path: string) => {
  const text = await fs.readFile(path, "utf8");
  const results = parseCsv(text).map(toRow);
  const errors = results.filter((r) => r._tag === "Err") as Result<string, never>[];
  if (errors.length) {
    console.error("Errors:", errors.map((e) => e.error));
    process.exitCode = 1;
    return;
  }
  const rows = results.map((r: any) => r.value);
  console.log("Total =", total(rows));
};

main(process.argv[2] ?? "in.csv");
```

**Test the pure bits with AVA:**

```ts
// test/csv-core.test.ts
import test from "ava";
import { parseCsv, toRow, total } from "../src/csv-core";

test("parseCsv splits lines/cells", (t) => {
  t.deepEqual(parseCsv("a,b,c\n1,2,3"), [["a","b","c"],["1","2","3"]]);
});

test("toRow validates cells", (t) => {
  const ok = toRow(["sku1","2","3.5"]);
  t.is(ok._tag, "Ok");
  const err = toRow(["only","two"]);
  t.is(err._tag, "Err");
});

test("total multiplies qty * price", (t) => {
  t.is(total([{ sku:"x", qty:2, price:3 }]), 6);
});
```

---

## Pitfalls to avoid

* **Hidden effects in “helpers.”** If it logs, reads, or mutates, it’s not pure.
* **Implicit time.** `Date.now()` inside core logic will wreck determinism. Pass `now` in.
* **Shared mutable caches.** Prefer functional caches (memoize with explicit scope) or move caching to the adapter.
* **Overengineering with monads.** If a `try { } catch { }` in the adapter is fine, do that. Keep the core small and typed.

---

## Minimal checklist for new modules

* [ ] Pure functions first; effects injected as parameters.
* [ ] `readonly` everywhere feasible.
* [ ] Types model reality (discriminated unions for states).
* [ ] AVA tests for core logic (no I/O).
* [ ] One adapter file per environment (Node, browser, test fakes).
* [ ] `pipe` + small combinators over giant class hierarchies.

---

### Final word

Functional programming in TS isn’t about dogma. It’s about **predictability under change**. Keep the mathy stuff light, the boundaries clean, and the values flowing.

\#typescript #functional-programming #primer #typescript-tips #immutability #composition #option #result #task #ports-and-adapters #zod #ava #testing #patterns #reducers #discriminated-unions #clean-architecture

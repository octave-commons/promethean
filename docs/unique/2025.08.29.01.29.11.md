got it. here’s a **pure-functions, pipeline-first** rewrite. every rule we discussed is a stateless transformation over a list of “import facts.” the only impure parts are the initial filesystem scan/read and the optional `--fix` writer at the very end.

* **data model**: each item is a `Fact` (one import use). transforms `map`/`filter` the list and add fields like `status`, `resolved`, `note`, etc.
* **resolution** is split into tiny pure helpers.
* **tsconfig** support: `baseUrl` + simple `paths` with a single `*`.
* **filters implemented**:

  * strip comments before extracting
  * built-ins (`node:*` and core) → `builtin`
  * bare imports policy: `--include-bare` prefixes, `--exclude-bare`, otherwise `external-skip`
  * relative resolvers with **multi-dot** probing + **extension remap** (`ok-ext-mapped`)
  * same-module `dist → src` mapping → `build-artifact` (optionally fix)
  * candidate scoring with bonuses for same dir and same package
  * optional `--check-node-modules` resolution for included bare imports
  * safe `--fix/--dry-run` for extension remap + same-module dist→src only (never touches comments)

run examples at the end.

---

```js
#!/usr/bin/env node
// fp-find-broken-imports.mjs
// Node 18+. Dependency-free. Functional pipeline style.

import fs from 'fs';
import path from 'path';
import module from 'node:module';

// -----------------------------
// Constants / Config
// -----------------------------
const ALLOWED_EXTS = ['.ts', '.tsx', '.js', '.jsx', '.mjs', '.mts', '.cts', '.cjs', '.json'];
const SKIP_DIRS = new Set(['node_modules', '.git', '.hg', '.svn', 'dist', 'build', 'out', '.next', '.turbo', '.cache', 'coverage']);
const MAX_CANDIDATES = 5;
const BUILTINS = new Set(module.builtinModules);

// -----------------------------
// CLI args (pure helpers)
// -----------------------------
const argv = process.argv.slice(2);
const arg = (name, def = null) => {
  const i = argv.indexOf(name);
  return i >= 0 ? (argv[i + 1] ?? def) : def;
};
const has = (name) => argv.includes(name);
const parseCsv = (flag, def = []) => (arg(flag) ? arg(flag).split(',').map(s => s.trim()).filter(Boolean) : def);

const ROOT = path.resolve(arg('--root', process.cwd()));
const CHECK_NODE_MODULES = has('--check-node-modules');
const INCLUDE_BARE = parseCsv('--include-bare');       // e.g. ["@shared/","@namespace/"]
const EXCLUDE_BARE = new Set(parseCsv('--exclude-bare'));  // e.g. ["ava","vitest"]
const DO_FIX = has('--fix');
const DRY_RUN = has('--dry-run');
const FIX_MODE = arg('--fix-mode', 'ext-map');         // 'ext-map' | 'remove-ext'

// -----------------------------
// IO (impure) — isolated
// -----------------------------
const readText = (p) => { try { return fs.readFileSync(p, 'utf8'); } catch { return null; } };
const fileExists = (p) => { try { return fs.statSync(p).isFile(); } catch { return false; } };
const dirExists  = (p) => { try { return fs.statSync(p).isDirectory(); } catch { return false; } };

const listFilesRec = (dir) => {
  const out = [];
  const stack = [dir];
  while (stack.length) {
    const cur = stack.pop();
    let ents;
    try { ents = fs.readdirSync(cur, { withFileTypes: true }); } catch { continue; }
    for (const e of ents) {
      if (e.isDirectory()) {
        if (SKIP_DIRS.has(e.name)) continue;
        stack.push(path.join(cur, e.name));
      } else if (e.isFile()) {
        const fp = path.join(cur, e.name);
        if (ALLOWED_EXTS.includes(path.extname(fp).toLowerCase())) out.push(fp);
      }
    }
  }
  return out;
};

// -----------------------------
// Parsing / Normalization (pure)
// -----------------------------
const stripComments = (src) =>
  src
    .replace(/\/\*[\s\S]*?\*\//g, '')        // block comments
    .replace(/(^|\s)\/\/.*$/gm, '$1');       // line comments (rough but effective)

const IMPORT_RES = [
  /import\s+(?:[^'"]*?)\s+from\s+['"]([^'"]+)['"]/g,
  /export\s+(?:[^'"]*?)\s+from\s+['"]([^'"]+)['"]/g,
  /import\s*\(\s*['"]([^'"]+)['"]\s*\)/g,
];

const extractSpecs = (text) =>
  IMPORT_RES.flatMap(re => {
    re.lastIndex = 0;
    const hits = [];
    let m;
    while ((m = re.exec(text)) !== null) hits.push(m[1]);
    return hits;
  });

const loadTsConfig = (root) => {
  for (const name of ['tsconfig.json', 'jsconfig.json']) {
    const f = path.join(root, name);
    if (fileExists(f)) {
      try { return JSON.parse(fs.readFileSync(f, 'utf8')); } catch { return null; }
    }
  }
  return null;
};

// -----------------------------
// Resolution helpers (pure)
// -----------------------------
const extOf = (p) => path.extname(p);
const stemOf = (p) => {
  const ext = extOf(p);
  return ext ? p.slice(0, -ext.length) : p;
};

const tryResolveFile = (absBasePath) => {
  // exact hit
  if (fileExists(absBasePath)) return absBasePath;

  // strip LAST extension and probe same-stem alternates (handles multi-dot)
  const stem = stemOf(absBasePath);
  for (const e of ALLOWED_EXTS) {
    const p = stem + e;
    if (fileExists(p)) return p;
  }

  // treat stem as a directory and look for index.*
  if (dirExists(stem)) {
    for (const e of ALLOWED_EXTS) {
      const p = path.join(stem, 'index' + e);
      if (fileExists(p)) return p;
    }
  }

  // if no ext was provided originally, try base+ext
  if (!extOf(absBasePath)) {
    for (const e of ALLOWED_EXTS) {
      const p = absBasePath + e;
      if (fileExists(p)) return p;
    }
  }
  return null;
};

const resolveNearestPackageRoot = (startDir) => {
  let cur = startDir;
  while (true) {
    const pj = path.join(cur, 'package.json');
    if (fileExists(pj)) return cur;
    const parent = path.dirname(cur);
    if (parent === cur) break;
    cur = parent;
  }
  return null;
};

const sameModule = (importerAbs, targetAbs) => {
  const root = resolveNearestPackageRoot(path.dirname(importerAbs));
  if (!root) return false;
  const tgt = path.normalize(targetAbs);
  return tgt.startsWith(root + path.sep);
};

const resolveLocalAttempt = (spec, importerAbs) => {
  if (spec.startsWith('./') || spec.startsWith('../'))) {
    const abs = path.resolve(path.dirname(importerAbs), spec);
    return { resolved: tryResolveFile(abs), attemptedAbs: abs };
  }
  if (spec.startsWith('/')) {
    const abs = path.join(ROOT, spec);
    return { resolved: tryResolveFile(abs), attemptedAbs: abs };
  }
  return { resolved: null, attemptedAbs: null };
};

const resolveWithTs = (spec, importerAbs, tsconf) => {
  if (!tsconf?.compilerOptions) return { resolved: null, attemptedAbs: null };
  const { baseUrl, paths } = tsconf.compilerOptions;
  const base = baseUrl ? path.resolve(ROOT, baseUrl) : ROOT;

  // relative-like: already handled locally, but provide fallback
  if (spec.startsWith('./') || spec.startsWith('../') || spec.startsWith('/')) {
    const abs = spec.startsWith('/') ? path.join(ROOT, spec) : path.resolve(path.dirname(importerAbs), spec);
    return { resolved: tryResolveFile(abs), attemptedAbs: abs };
  }

  // simple "paths" with single "*"
  if (paths && typeof paths === 'object') {
    for (const [alias, targets] of Object.entries(paths)) {
      const star = alias.indexOf('*');
      if (star === -1) {
        if (alias === spec) {
          for (const t of targets) {
            const abs = path.resolve(base, t);
            const r = tryResolveFile(abs);
            if (r) return { resolved: r, attemptedAbs: abs };
          }
        }
      } else {
        const pre = alias.slice(0, star), suf = alias.slice(star + 1);
        if (spec.startsWith(pre) && spec.endsWith(suf)) {
          const mid = spec.slice(pre.length, spec.length - suf.length);
          for (const t of targets) {
            const tStar = t.indexOf('*');
            const mapped = tStar >= 0 ? (t.slice(0, tStar) + mid + t.slice(tStar + 1)) : t;
            const abs = path.resolve(base, mapped);
            const r = tryResolveFile(abs);
            if (r) return { resolved: r, attemptedAbs: abs };
          }
        }
      }
    }
  }

  // baseUrl attempt for non-bare pathish
  const abs = path.resolve(base, spec);
  return { resolved: tryResolveFile(abs), attemptedAbs: abs };
};

const resolveFromNodeModules = (spec, importerAbs) => {
  let cur = path.dirname(importerAbs);
  while (true) {
    const nm = path.join(cur, 'node_modules', spec);
    if (dirExists(nm)) {
      const pkg = path.join(nm, 'package.json');
      if (fileExists(pkg)) {
        try {
          const data = JSON.parse(fs.readFileSync(pkg, 'utf8'));
          const entry = data.module || data.exports || data.main || 'index.js';
          const target = Array.isArray(entry) ? entry[0] : (typeof entry === 'string' ? entry : 'index.js');
          const res = tryResolveFile(path.join(nm, target));
          if (res) return res;
        } catch {}
      }
      const fallback = tryResolveFile(nm);
      if (fallback) return fallback;
    }
    const parent = path.dirname(cur);
    if (parent === cur) break;
    cur = parent;
  }
  return null;
};

// bare import policy
const bareIsIncluded = (spec) => {
  if (EXCLUDE_BARE.has(spec)) return false;
  if (!INCLUDE_BARE.length) return false;
  return INCLUDE_BARE.some(p => spec.startsWith(p));
};

// fuzzy scoring
const levenshtein = (a, b) => {
  const m = a.length, n = b.length;
  if (!m) return n; if (!n) return m;
  const dp = Array.from({ length: m + 1 }, (_, i) => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
};
const normScore = (a, b) => {
  const aa = a.toLowerCase(), bb = b.toLowerCase();
  const dist = levenshtein(aa, bb);
  const maxLen = Math.max(aa.length, bb.length) || 1;
  return 1 - dist / maxLen;
};

// -----------------------------
// Data model
// -----------------------------
// Fact: one import occurrence
// {
//   fileAbs, fileRel, importerDir, spec,
//   kind: 'bare'|'relative'|'absolute',
//   attemptedAbs?, resolved?, askedExt?, gotExt?,
//   status?, note?, mapped?, candidates?[], fix?{from,to,changed,replacements}
// }

const mkFacts = (files) =>
  files.flatMap(fileAbs => {
    const raw = readText(fileAbs);
    if (raw == null) return [];
    const text = stripComments(raw);
    const specs = extractSpecs(text);
    const fileRel = path.relative(ROOT, fileAbs);
    const importerDir = path.dirname(fileAbs);
    return specs.map(spec => ({
      fileAbs, fileRel, importerDir, spec,
      kind: spec.startsWith('./') || spec.startsWith('../') ? 'relative'
          : spec.startsWith('/') ? 'absolute'
          : 'bare'
    }));
  });

// -----------------------------
// Pipeline steps (PURE TRANSFORMS)
// -----------------------------

// 1) mark node builtins
const t_builtin = (facts) =>
  facts.map(f =>
    (BUILTINS.has(f.spec) || f.spec.startsWith('node:'))
      ? { ...f, status: 'builtin', note: 'node core module' }
      : f
  );

// 2) early skip bare imports not included by policy
const t_bare_policy = (facts) =>
  facts.map(f => {
    if (f.status) return f;
    if (f.kind !== 'bare') return f;
    return bareIsIncluded(f.spec)
      ? f
      : { ...f, status: 'external-skip', note: 'bare import (skipped by policy)' };
  });

// 3) attempt resolution: local → tsconfig → node_modules (if bare & allowed)
const t_resolve = (tsconf) => (facts) =>
  facts.map(f => {
    if (f.status) return f;

    let attemptedAbs = null;
    let resolved = null;

    // local/absolute attempt
    const r1 = resolveLocalAttempt(f.spec, f.fileAbs);
    attemptedAbs = r1.attemptedAbs ?? attemptedAbs;
    resolved = r1.resolved ?? resolved;

    // tsconfig
    if (!resolved) {
      const r2 = resolveWithTs(f.spec, f.fileAbs, tsconf);
      attemptedAbs = attemptedAbs ?? r2.attemptedAbs;
      resolved = r2.resolved ?? resolved;
    }

    // node_modules only for included bare imports
    if (!resolved && f.kind === 'bare' && bareIsIncluded(f.spec) && CHECK_NODE_MODULES) {
      resolved = resolveFromNodeModules(f.spec, f.fileAbs);
    }

    if (resolved) {
      const askedExt = attemptedAbs ? extOf(attemptedAbs) : '';
      const gotExt = extOf(resolved);
      const status = (askedExt && askedExt !== gotExt) ? 'ok-ext-mapped' : 'ok';
      return { ...f, attemptedAbs, resolved, askedExt, gotExt, status };
    }
    return { ...f, attemptedAbs };
  });

// 4) same-module dist→src mapping when unresolved
const t_same_module_dist = (facts) =>
  facts.map(f => {
    if (f.status) return f;
    if (!f.attemptedAbs) return f;
    const looksDist = /(^|[/\\])dist([/\\]|$)/.test(f.spec);
    if (!looksDist) return f;

    // same package?
    if (!sameModule(f.fileAbs, f.attemptedAbs)) return f;

    const mappedAbs = f.attemptedAbs.replace(new RegExp(`\\${path.sep}dist\\${path.sep}`), `${path.sep}src${path.sep}`);
    const mappedResolved = tryResolveFile(mappedAbs);
    if (mappedResolved) {
      return {
        ...f,
        status: 'build-artifact',
        note: 'same-module dist import; mapped to src',
        mapped: mappedResolved
      };
    }
    return {
      ...f,
      status: 'build-artifact',
      note: 'same-module dist import; src mapping not found'
    };
  });

// 5) unresolved → compute candidates (bias same dir + same module)
const mkPathIndex = (files) => {
  const idx = new Map();
  for (const p of files) {
    const base = path.basename(p, path.extname(p));
    if (!idx.has(base)) idx.set(base, []);
    idx.get(base).push(p);
  }
  return idx;
};

const t_candidates = (pathIndex) => (facts) =>
  facts.map(f => {
    if (f.status) return f;
    const wantedBase = path.basename(f.spec).replace(/\.[a-z0-9]+$/i, '');
    const candidates = (pathIndex.get(wantedBase) || [])
      .map(cAbs => {
        const candRel = path.relative(ROOT, cAbs);
        const specish = f.spec.replace(/^[./]+/, '');
        let score = normScore(specish, candRel);
        if (extOf(f.spec) && extOf(f.spec) === extOf(cAbs)) score += 0.05;

        const specDir = path.dirname(specish);
        const candDir = path.dirname(candRel);
        if (candDir.includes(specDir) || specDir.includes(candDir)) score += 0.05;

        if (sameModule(f.fileAbs, cAbs)) score += 0.20;
        if (path.dirname(cAbs) === f.importerDir) score += 0.30;

        return { path: candRel, score };
      })
      .sort((a, b) => b.score - a.score)
      .slice(0, MAX_CANDIDATES);

    return { ...f, status: 'missing', candidates };
  });

// -----------------------------
// Fixers (pure proposal + impure writer)
// -----------------------------
const proposeRelativeSpecifier = (importerAbs, resolvedAbs) => {
  const importerDir = path.dirname(importerAbs);
  const rel = path.relative(importerDir, resolvedAbs).replace(/\\/g, '/');
  return rel.startsWith('.') ? rel : './' + rel;
};

const applyFixMode = (spec) => {
  if (FIX_MODE === 'remove-ext') return spec.replace(/\.[a-z0-9]+$/i, '');
  return spec; // ext-map keeps resolved extension
};

const rewriteSpecInFile = (fileAbs, oldSpec, newSpec) => {
  let src = readText(fileAbs);
  if (src == null) return { changed: false };

  // target only import occurrences (avoid comments)
  const esc = (s) => s.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
  const pat = new RegExp(
    `(\\bimport\\s+[^'"]*?\\s+from\\s+|\\bexport\\s+[^'"]*?\\s+from\\s+|\\bimport\\s*\\(\\s*)` +
    `(['"])` + esc(oldSpec) + `\\2`,
    'g'
  );

  let replaced = 0;
  const next = src.replace(pat, (m, pre, q) => {
    replaced++;
    return `${pre}${q}${newSpec}${q}`;
  });

  if (!replaced) return { changed: false };
  if (!DO_FIX || DRY_RUN) return { changed: true, preview: next, replacements: replaced };

  fs.writeFileSync(fileAbs, next, 'utf8');
  return { changed: true, replacements: replaced };
};

// 6) conservative fixer over facts
const t_fix = (facts) =>
  facts.map(f => {
    if (!DO_FIX) return f;

    // only touch RELATIVE imports we resolved deterministically
    const canTouch = f.kind !== 'bare' && f.spec && (f.status === 'ok-ext-mapped' || (f.status === 'build-artifact' && f.mapped));
    if (!canTouch) return f;

    const resolvedAbs = f.status === 'ok-ext-mapped' ? f.resolved
                       : f.status === 'build-artifact' ? f.mapped
                       : null;
    if (!resolvedAbs) return f;

    const proposedRaw = proposeRelativeSpecifier(f.fileAbs, resolvedAbs);
    const proposed = applyFixMode(proposedRaw);
    if (!proposed || proposed === f.spec) return f;

    const res = rewriteSpecInFile(f.fileAbs, f.spec, proposed);
    if (!res.changed) return f;

    return {
      ...f,
      status: 'fixed',
      fix: { from: f.spec, to: proposed, changed: true, replacements: res.replacements }
    };
  });

// -----------------------------
// Reporting (pure)
// -----------------------------
const summarize = (facts) => {
  const by = (s) => facts.filter(f => f.status === s).length;
  return {
    ok: by('ok'),
    ok_ext_mapped: by('ok-ext-mapped'),
    builtin: by('builtin'),
    external_skip: by('external-skip'),
    build_artifact: by('build-artifact'),
    missing: by('missing'),
    fixed: by('fixed'),
  };
};

const toReportJson = (facts) => ({
  root: ROOT,
  results: facts.map(f => ({
    file: f.fileRel,
    spec: f.spec,
    status: f.status ?? 'unknown',
    note: f.note,
    resolved: f.resolved ? path.relative(ROOT, f.resolved) : undefined,
    mapped: f.mapped ? path.relative(ROOT, f.mapped) : undefined,
    candidates: f.candidates,
    fix: f.fix
  }))
});

// -----------------------------
// Main (minimal impurity)
// -----------------------------
function main() {
  console.log(`Scanning: ${ROOT}`);
  const files = listFilesRec(ROOT);
  const tsconf = loadTsConfig(ROOT);
  const pathIndex = mkPathIndex(files);

  // facts
  const facts0 = mkFacts(files);

  // pipeline
  const pipeline = [
    t_builtin,
    t_bare_policy,
    t_resolve(tsconf),
    t_same_module_dist,
    t_candidates(pathIndex),
    t_fix
  ];

  const facts = pipeline.reduce((acc, step) => step(acc), facts0);

  // summaries
  const s = summarize(facts);
  console.log('\n=== Import Resolution Summary ===');
  console.log(`OK:                 ${s.ok}`);
  console.log(`OK (ext-mapped):    ${s.ok_ext_mapped}`);
  console.log(`Fixed:              ${s.fixed} ${DO_FIX ? (DRY_RUN ? '(dry-run)' : '(written)') : ''}`);
  console.log(`Build-artifact:     ${s.build_artifact}`);
  console.log(`Builtin:            ${s.builtin}`);
  console.log(`External (skipped): ${s.external_skip}`);
  console.log(`Missing:            ${s.missing}`);

  // print missing & artifacts
  const missing = facts.filter(f => f.status === 'missing');
  const artifacts = facts.filter(f => f.status === 'build-artifact');
  if (artifacts.length) {
    console.log('\n--- Same-module dist imports ---');
    for (const r of artifacts) {
      console.log(`[${r.fileRel}] -> "${r.spec}"  ${r.mapped ? `mapped -> ${path.relative(ROOT, r.mapped)}` : '(no src mapping found)'}`);
    }
  }
  if (missing.length) {
    console.log('\n--- Missing Imports (top candidates) ---');
    for (const r of missing) {
      console.log(`\n[${r.fileRel}] -> "${r.spec}"`);
      if (!r.candidates?.length) {
        console.log('  No candidates found.');
      } else {
        r.candidates.forEach((c, i) => {
          console.log(`  ${i + 1}. ${c.path}  (score=${c.score.toFixed(3)})`);
        });
      }
    }
  }

  // write report
  const reportPath = path.join(ROOT, 'broken-imports.report.json');
  fs.writeFileSync(reportPath, JSON.stringify(toReportJson(facts), null, 2), 'utf8');
  console.log(`\nWrote report: ${reportPath}`);
}

main();
```

### usage

```bash
# scan repo, conservative defaults (skip bare imports)
node fp-find-broken-imports.mjs

# include only selected bare namespaces; explicitly skip ava
node fp-find-broken-imports.mjs --include-bare "@shared/,@promethean/" --exclude-bare "ava"

# attempt node_modules resolution for included bare imports
node fp-find-broken-imports.mjs --include-bare "@shared/" --check-node-modules

# dry-run fixes (extension remaps + same-module dist→src)
node fp-find-broken-imports.mjs --include-bare "@shared/" --exclude-bare "ava" --fix --dry-run

# actually write fixes, keep real extensions
node fp-find-broken-imports.mjs --include-bare "@shared/" --exclude-bare "ava" --fix --fix-mode ext-map

# write fixes but drop extensions (./foo.js → ./foo)
node fp-find-broken-imports.mjs --include-bare "@shared/" --exclude-bare "ava" --fix --fix-mode remove-ext
```

### notes (why this won’t lie to you)

* **comments are stripped** before scanning; fixer targets only import tokens, not comments.
* **same-module `dist`** is derived by nearest `package.json` comparison; cross-module `@scope/pkg/dist/...` won’t be mislabeled.
* **multi-dot files** and `.js ↔ .ts` twins resolve cleanly via stem probing.
* **fixes are opt-in** and **narrow**: extension remaps and same-module `dist→src` only. no fuzzy auto-rewrites.

if you want a `--threshold` for auto-fixing top same-dir candidates, we can add another pure transform in the pipeline that proposes a fix when `score >= X`. i’d keep it off by default.

\#tooling #typescript #node #fp #imports #refactor #obsidian

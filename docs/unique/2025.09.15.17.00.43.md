Got it. You want a **gradient**: fast, minimal “does it even build?” checks on AI PRs → progressively stricter gates as changes move toward `main`. Here’s a concrete way to wire that in GitHub Actions + branch protection, with examples you can drop in today.

I’m opinionated below; adjust names as you like.

---

# TL;DR shape

* **Light checks** for PRs targeting `dev/*` (your AI sandboxes): install, **typecheck/build**, tiny smoke/unit slice (changed files only), cache hard.
* **Medium checks** for PRs into `dev/testing`: add **lint on touched files** and a **wider** set of tests.
* **Heavy checks** for PRs into `dev/staging`: **full lint**, **full tests + coverage**, **docs/transforms**.
* **Release checks** for PRs into `main`: all of the above; deploy guarded behind an **environment approval** if you want.

Use **branch protection → required checks** per branch to enforce the gradient. Required checks may be *successful, skipped, or neutral* to allow merges when jobs are intentionally bypassed (useful for path-filtering). ([GitHub Docs][1])

Make each tier a **reusable workflow** so you don’t duplicate YAML; call it with inputs from small “launcher” workflows. ([GitHub Docs][2])

Use **paths filtering** to avoid running slow jobs unless relevant (either native `paths/paths-ignore` or `dorny/paths-filter` for per-job granularity). ([GitHub Docs][3])

Optionally gate deploys or obsidian transforms with **environments** + protection rules. ([GitHub Docs][4])

---

# Branch protection (the backbone)

* **`dev/*` (e.g., `dev/stealth`)**: require only `ci-light` to pass.
* **`dev/testing`**: require `ci-medium` to pass.
* **`dev/staging`**: require `ci-heavy` to pass.
* **`main`**: require `ci-release` (or reuse `ci-heavy` + deploy).

Configure in repo settings → Branches → Protection rules → **Required status checks**. ([GitHub Docs][5])

---

# Reusable workflows

Create **one** file per tier in `.github/workflows/`. Each exposes `on: workflow_call` and is invoked by tiny branch-specific launchers.

## 1) `ci-light.yml` (build + minimal tests)

```yaml
# .github/workflows/ci-light.yml
name: ci-light
on:
  workflow_call:
    inputs:
      node-version:
        required: false
        type: string
        default: "20"
jobs:
  light:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: ${{ inputs.node-version }}
          cache: pnpm
      - run: corepack enable
      - run: pnpm install --frozen-lockfile

      # Fast typecheck/build
      - run: pnpm run -r --stream build

      # Run only tests impacted by changes (quick smoke)
      # Example with Jest flags; adapt to AVA by passing a list of changed test files to a small script.
      - name: Compute changed files
        id: changed
        run: |
          git fetch --no-tags --depth=1 origin ${{ github.base_ref || 'main' }}
          git diff --name-only --diff-filter=AMR HEAD origin/${{ github.base_ref || 'main' }} > changed.txt
          echo "files=$(tr '\n' ' ' < changed.txt)" >> "$GITHUB_OUTPUT"

      - name: Run impacted tests
        if: always()
        run: |
          # With Jest you can use --findRelatedTests or --lastCommit. AVA: pass globs from changed list to focus/slice.
          pnpm test:changed -- ${{ steps.changed.outputs.files || '' }} || true
```

Notes:

* For Jest, `--findRelatedTests`/`--lastCommit` exist. For AVA, you’ll likely **compute globs** from `changed.txt` and run a subset (e.g., map `src/foo.ts` → `test/**/*foo*.test.ts`). It’s not built-in, but this scripting pattern is common. ([Jest][6])
* Cache with `actions/setup-node`’s built-in caching for pnpm to keep it snappy. ([GitHub][7])

## 2) `ci-medium.yml` (lint touched + wider tests)

```yaml
# .github/workflows/ci-medium.yml
name: ci-medium
on:
  workflow_call: {}
jobs:
  medium:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable
      - run: pnpm install --frozen-lockfile

      - name: Lint changed files only
        run: |
          git fetch --no-tags --depth=1 origin ${{ github.base_ref || 'main' }}
          CHANGED=$(git diff --name-only --diff-filter=AMR HEAD origin/${{ github.base_ref || 'main' }} | tr '\n' ' ')
          [ -z "$CHANGED" ] && exit 0
          pnpm eslint --max-warnings=0 $CHANGED || true
      # ^ If you’re not ready to fail on warnings yet, drop --max-warnings=0 or keep '|| true' for non-blocking.
      # When you’re ready to tighten, remove '|| true' so lint failures fail the job.  :contentReference[oaicite:7]{index=7}

      - name: Run broader tests (by package or tag)
        run: pnpm test:quick
```

## 3) `ci-heavy.yml` (full suite)

```yaml
# .github/workflows/ci-heavy.yml
name: ci-heavy
on:
  workflow_call: {}
jobs:
  detect:
    runs-on: ubuntu-latest
    outputs:
      backend: ${{ steps.filter.outputs.backend }}
      frontend: ${{ steps.filter.outputs.frontend }}
  # Optional: only run sub-suites if related code changed.
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            backend:
              - 'packages/api/**'
            frontend:
              - 'packages/web/**'
  backend:
    needs: detect
    if: needs.detect.outputs.backend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable
      - run: pnpm i --frozen-lockfile
      - run: pnpm -w lint # full lint, fail on warnings when you’re ready
      - run: pnpm -w test:ci -- --coverage

  frontend:
    needs: detect
    if: needs.detect.outputs.frontend == 'true'
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable
      - run: pnpm i --frozen-lockfile
      - run: pnpm -w lint
      - run: pnpm -w test:ci -- --coverage
```

* `dorny/paths-filter` lets you **skip whole jobs** if parts of the monorepo weren’t touched—keeps heavy tier fast. ([GitHub][8])

## 4) `ci-release.yml` (heavy + deploy / docs)

```yaml
# .github/workflows/ci-release.yml
name: ci-release
on:
  workflow_call:
    inputs:
      deploy:
        type: boolean
        default: false
jobs:
  heavy:
    uses: ./.github/workflows/ci-heavy.yml

  docs:
    needs: heavy
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: pnpm i --frozen-lockfile
      - run: pnpm run docs:build  # e.g., obsidian export & link check pipeline

  deploy:
    if: inputs.deploy == true
    needs: [heavy, docs]
    runs-on: ubuntu-latest
    environment: production   # approvals/wait timers if you want
    steps:
      - run: echo "Deploying…"
```

* **Environments** give you approval gates and other protection rules before running a deploy job. ([GitHub Docs][4])

---

# “Launcher” workflows per branch band

Create tiny files that **call** the tiers based on the base branch of the PR.

### Light for AI PRs to `dev/*` (e.g., `dev/stealth`)

```yaml
# .github/workflows/on-pr-to-dev.yml
name: on-pr-to-dev
on:
  pull_request:
    branches:
      - 'dev/**'
jobs:
  call:
    uses: ./.github/workflows/ci-light.yml
```

### Medium for PRs to `dev/testing`

```yaml
# .github/workflows/on-pr-to-testing.yml
name: on-pr-to-testing
on:
  pull_request:
    branches: ['dev/testing']
jobs:
  call:
    uses: ./.github/workflows/ci-medium.yml
```

### Heavy for PRs to `dev/staging`

```yaml
# .github/workflows/on-pr-to-staging.yml
name: on-pr-to-staging
on:
  pull_request:
    branches: ['dev/staging']
jobs:
  call:
    uses: ./.github/workflows/ci-heavy.yml
```

### Release for PRs to `main`

```yaml
# .github/workflows/on-pr-to-main.yml
name: on-pr-to-main
on:
  pull_request:
    branches: ['main']
jobs:
  call:
    uses: ./.github/workflows/ci-release.yml
    with:
      deploy: false
```

(If you want a **post-merge** workflow to deploy or transform docs, add a `workflow_run` trigger that listens for the `on-pr-to-main` success, or just run on `push` to `main`.) ([GitHub Docs][9])

---

# Obsidian / docs transforms

Put your `obsidian/staging` pipeline in a dedicated workflow:

```yaml
# .github/workflows/obsidian-staging.yml
name: obsidian-staging
on:
  push:
    branches: ['obsidian/staging']
jobs:
  transform:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
      - run: pnpm i --frozen-lockfile
      - run: pnpm run docs:export   # your wikilink -> MD conversion, etc.
      - run: pnpm run docs:check    # link checker; fail on broken links
```

Then make **`obsidian/staging` → `main`** require this check to be green (via branch protection). The docs transform can be laser-focused using path filters so it doesn’t run on code-only pushes. ([GitHub Docs][3])

---

# What this buys you (relative to your current state)

* **AI PRs** into `dev/stealth` (or any `dev/*`) stay **green** as long as the code builds & a tiny smoke slice runs. That keeps the sandbox stable and fast.
* You can **let red boxes exist** in higher tiers while you’re paying down tech debt—but they won’t block the light tier.
* You get **clear, automated documentation** of where and why something fails as it moves up the gradient (lint issues, flaky tests, etc.).
* No duplication: reusable workflows + branch protection manage most of the policy.

---

# A few pragmatic knobs

* **Failing lint everywhere?** Start with `ci-medium` running lint on changed files but **non-blocking** (exit 0) until you’re ready to tighten; then remove `|| true` and/or add `--max-warnings=0`. ([Stack Overflow][10])
* **Selective tests**: if you’re on Jest anywhere, `--findRelatedTests`/`--lastCommit` are handy. For AVA, keep a small script that maps changed sources to test globs; the pattern in `ci-light` shows how to pass changed files into a command. ([Jest][6])
* **Skip heavy jobs** with `dorny/paths-filter` at the **job** level (GitHub’s built-in `paths` only filters workflow triggers, not per-job logic). ([GitHub][8])
* **Cache** dependencies aggressively with `setup-node`’s `cache` input for pnpm. ([GitHub][7])

---

If you want, I can tailor the YAML to your exact package scripts (AVA commands, pnpm workspaces, Obsidian export step) and map your current branch names (`codex/*`, `obsidian/*`, etc.) precisely.

[1]: https://docs.github.com/repositories/configuring-branches-and-merges-in-your-repository/managing-protected-branches/about-protected-branches?utm_source=chatgpt.com "About protected branches"
[2]: https://docs.github.com/en/actions/how-tos/sharing-automations/reusing-workflows?utm_source=chatgpt.com "Reusing workflows"
[3]: https://docs.github.com/actions/reference/workflow-syntax-for-github-actions?utm_source=chatgpt.com "Workflow syntax for GitHub Actions"
[4]: https://docs.github.com/en/actions/reference/workflows-and-actions/deployments-and-environments?utm_source=chatgpt.com "Deployments and environments"
[5]: https://docs.github.com/articles/about-status-checks?utm_source=chatgpt.com "About status checks"
[6]: https://jestjs.io/docs/cli?utm_source=chatgpt.com "Jest CLI Options"
[7]: https://github.com/actions/setup-node?utm_source=chatgpt.com "actions/setup-node"
[8]: https://github.com/dorny/paths-filter?utm_source=chatgpt.com "dorny/paths-filter: Conditionally run actions based on files ..."
[9]: https://docs.github.com/actions/learn-github-actions/events-that-trigger-workflows?utm_source=chatgpt.com "Events that trigger workflows"
[10]: https://stackoverflow.com/questions/63919769/how-to-trigger-fail-ci-cd-on-eslint-warning?utm_source=chatgpt.com "How to trigger fail CI/CD on eslint warning"

I want you to individually write async pure functions for each of the following actions.
You don't have to take my suggestions, their just how I think I might have tried it.

I don't want you to rewrite the whole file.

Rewrite each one by its self.

I want to establish a programming style with you for one.
and for another, each of these is a thing we can probably reuse.

Write tiny small reusable functions, whenever you can.

Because I save our chats, and they get dumped in the code
And even when I don't run them, they are in here.

And if a grep, semantic search, a random walk, whatever, shows it up
it will be the right tool for that job.
This can be a reduce
```js
    for (const e of ents) {
      if (e.isDirectory()) {
        if (SKIP_DIRS.has(e.name)) continue;
        stack.push(path.join(cur, e.name));
      } else if (e.isFile()) {
        const fp = path.join(cur, e.name);
        if (ALLOWED_EXTS.includes(path.extname(fp).toLowerCase())) out.push(fp);
      }
    }
```


the loop that surrounds it can also be a reduce:
```js

  const out = [];
  const stack = [dir];
  while (stack.length) {
    const cur = stack.pop();
    let ents;
    try { ents = fs.readdirSync(cur, { withFileTypes: true }); } catch { continue; }
    for (const e of ents) {
      if (e.isDirectory()) {
        if (SKIP_DIRS.has(e.name)) continue;
        stack.push(path.join(cur, e.name));
      } else if (e.isFile()) {
        const fp = path.join(cur, e.name);
        if (ALLOWED_EXTS.includes(path.extname(fp).toLowerCase())) out.push(fp);
      }
    }
  }

  return out;
```

Promise.race
```js

  for (const name of ['tsconfig.json', 'jsconfig.json']) {
    const f = path.join(root, name);
    if (fileExists(f)) {
      try { return JSON.parse(fs.readFileSync(f, 'utf8')); } catch { return null; }
    }
  }
```

Promise.race given a flat map of promises

```js

const tryResolveFile = (absBasePath) => {
  // exact hit
  if (fileExists(absBasePath)) return absBasePath;

  // strip LAST extension and probe same-stem alternates (handles multi-dot)
  const stem = stemOf(absBasePath);
  for (const e of ALLOWED_EXTS) {
    const p = stem + e;
    if (fileExists(p)) return p;
  }

  // treat stem as a directory and look for index.*
  if (dirExists(stem)) {
    for (const e of ALLOWED_EXTS) {
      const p = path.join(stem, 'index' + e);
      if (fileExists(p)) return p;
    }
  }

  // if no ext was provided originally, try base+ext
  if (!extOf(absBasePath)) {
    for (const e of ALLOWED_EXTS) {
      const p = absBasePath + e;
      if (fileExists(p)) return p;
    }
  }
  return null;
};
```

could be a find, could be a race, could be a few things.
```js
const resolveNearestPackageRoot = (startDir) => {
  let cur = startDir;
  while (true) {
    const pj = path.join(cur, 'package.json');
    if (fileExists(pj)) return cur;
    const parent = path.dirname(cur);
    if (parent === cur) break;
    cur = parent;
  }
  return null;
};
```

you get the idea.
```js

          for (const t of targets) {
            const abs = path.resolve(base, t);
            const r = tryResolveFile(abs);
            if (r) return { resolved: r, attemptedAbs: abs };
          }
```

no loops
```js

          for (const t of targets) {
            const tStar = t.indexOf('*');
            const mapped = tStar >= 0 ? (t.slice(0, tStar) + mid + t.slice(tStar + 1)) : t;
            const abs = path.resolve(base, mapped);
            const r = tryResolveFile(abs);
            if (r) return { resolved: r, attemptedAbs: abs };
          }
```

No loops
```js

  while (true) {
    const nm = path.join(cur, 'node_modules', spec);
    if (dirExists(nm)) {
      const pkg = path.join(nm, 'package.json');
      if (fileExists(pkg)) {
        try {
          const data = JSON.parse(fs.readFileSync(pkg, 'utf8'));
          const entry = data.module || data.exports || data.main || 'index.js';
          const target = Array.isArray(entry) ? entry[0] : (typeof entry === 'string' ? entry : 'index.js');
          const res = tryResolveFile(path.join(nm, target));
          if (res) return res;
        } catch {}
      }
      const fallback = tryResolveFile(nm);
      if (fallback) return fallback;
    }
    const parent = path.dirname(cur);
    if (parent === cur) break;
    cur = parent;
  }
```

nope
```js

const levenshtein = (a, b) => {
  const m = a.length, n = b.length;
  if (!m) return n; if (!n) return m;
  const dp = Array.from({ length: m + 1 }, (_, i) => Array(n + 1).fill(0));
  for (let i = 0; i <= m; i++) dp[i][0] = i;
  for (let j = 0; j <= n; j++) dp[0][j] = j;
  for (let i = 1; i <= m; i++) {
    for (let j = 1; j <= n; j++) {
      const cost = a[i - 1] === b[j - 1] ? 0 : 1;
      dp[i][j] = Math.min(dp[i - 1][j] + 1, dp[i][j - 1] + 1, dp[i - 1][j - 1] + cost);
    }
  }
  return dp[m][n];
};
```

---
uuid: 94dae2bd-acee-41c3-8f0c-553496f153d7
created_at: 2025.09.02.08.18.59.md
filename: Functional Programming in TypeScript
description: >-
  A pragmatic guide to implementing functional programming principles in
  TypeScript without heavy dependencies. Focuses on pure functions, effect
  management, and type safety to create clean, testable code.
tags:
  - TypeScript
  - Functional Programming
  - Pure Functions
  - Type Safety
  - Effects
  - Composability
related_to_uuid:
  - 9c79206d-4cb9-4f00-87e0-782dcea37bc7
  - 6bcff92c-4224-453d-9993-1be8d37d47c3
  - 18344cf9-0c49-4a71-b6c8-b8d84d660fca
  - ae24a280-678e-4c0b-8cc4-56667fa04172
  - 9fab9e76-e283-4c9d-a8cd-cb76892ea7ac
  - 03a5578f-d689-45db-95e9-11300e5eee6f
  - 9413237f-2537-4bbf-8768-db6180970e36
  - 3a3bf2c9-c0f6-4d7b-bf84-c83c70dece3f
  - c0392040-16a2-41e8-bd54-75110319e3c0
  - d17d3a96-c84d-4738-a403-6c733b874da2
  - 59b5670f-36d3-4d34-8985-f3144b15347a
  - b3555ede-324a-4d24-a885-b0721e74babf
  - 8430617b-80a2-4cc9-8288-9a74cb57990b
  - d8059b6a-c1ec-487d-8e0b-3ce33d6b4d06
  - 49a9a860-944c-467a-b532-4f99186a8593
  - c5c9a5c6-427d-4864-8084-c083cd55faa0
  - 4330e8f0-5f46-4235-918b-39b6b93fa561
  - 10d98225-12e0-4212-8e15-88b57cf7bee5
  - cdbd21ee-25a0-4bfa-884c-c1b948e9b0b2
  - 2792d448-c3b5-4050-93dd-93768529d99c
  - 13951643-1741-46bb-89dc-1beebb122633
  - 71726f04-eb1c-42a5-a5fe-d8209de6e159
  - f7702bf8-f7db-473c-9a5b-8dbf66ad3b9e
  - 623a55f7-685c-486b-abaf-469da1bbbb69
  - 557309a3-c906-4e97-8867-89ffe151790c
  - 6cb4943e-8267-4e27-8618-2ce0a464d173
  - 5e8b2388-022b-46cf-952c-36ae9b8f0037
  - 008f2ac0-bfaa-4d52-9826-2d5e86c0059f
  - 938eca9c-97e2-4bcc-8653-b0ef1a5ac7a3
  - 9e8ae388-767a-4ea8-9f2e-88801291d947
  - 73d3dbf6-9240-46fd-ada9-cc2e7e00dc5f
  - e979c50f-69bb-48b0-8417-e1ee1b31c0c0
related_to_title:
  - polyglot-repl-interface-layer
  - Post-Linguistic Transhuman Design Frameworks
  - Promethean Chat Activity Report
  - Promethean-Copilot-Intent-Engine
  - Promethean Data Sync Protocol
  - Promethean Dev Workflow Update
  - Promethean Documentation Overview
  - Promethean Documentation Pipeline Overview
  - Promethean Documentation Update
  - Pure TypeScript Search Microservice
  - Reawakening Duck
  - Redirecting Standard Error
  - ripple-propagation-demo
  - schema-evolution-workflow
  - Self-Agency in AI Interaction
  - sibilant-macro-targets
  - Stateful Partitions and Rebalancing
  - Creative Moments
  - Docops Feature Updates
  - Duck's Attractor States
  - Duck's Self-Referential Perceptual Loop
  - Dynamic Context Model for Web Components
  - Shared
  - Simulation Demo
  - Tooling
  - Eidolon Field Abstract Model
  - eidolon-field-math-foundations
  - eidolon-node-lifecycle
  - Window Management
  - Debugging Broker Connections and Agent Behavior
  - DuckDuckGoSearchPipeline
references:
  - uuid: 9e8ae388-767a-4ea8-9f2e-88801291d947
    line: 11
    col: 0
    score: 1
  - uuid: 10d98225-12e0-4212-8e15-88b57cf7bee5
    line: 47
    col: 0
    score: 1
  - uuid: 73d3dbf6-9240-46fd-ada9-cc2e7e00dc5f
    line: 105
    col: 0
    score: 1
  - uuid: cdbd21ee-25a0-4bfa-884c-c1b948e9b0b2
    line: 97
    col: 0
    score: 1
  - uuid: 2792d448-c3b5-4050-93dd-93768529d99c
    line: 128
    col: 0
    score: 1
  - uuid: e979c50f-69bb-48b0-8417-e1ee1b31c0c0
    line: 31
    col: 0
    score: 1
  - uuid: 13951643-1741-46bb-89dc-1beebb122633
    line: 90
    col: 0
    score: 1
  - uuid: 71726f04-eb1c-42a5-a5fe-d8209de6e159
    line: 33
    col: 0
    score: 1
  - uuid: f7702bf8-f7db-473c-9a5b-8dbf66ad3b9e
    line: 462
    col: 0
    score: 1
  - uuid: 623a55f7-685c-486b-abaf-469da1bbbb69
    line: 21
    col: 0
    score: 1
  - uuid: 557309a3-c906-4e97-8867-89ffe151790c
    line: 39
    col: 0
    score: 1
  - uuid: 6cb4943e-8267-4e27-8618-2ce0a464d173
    line: 28
    col: 0
    score: 1
  - uuid: 10d98225-12e0-4212-8e15-88b57cf7bee5
    line: 28
    col: 0
    score: 1
  - uuid: cdbd21ee-25a0-4bfa-884c-c1b948e9b0b2
    line: 65
    col: 0
    score: 1
  - uuid: 2792d448-c3b5-4050-93dd-93768529d99c
    line: 86
    col: 0
    score: 1
  - uuid: 13951643-1741-46bb-89dc-1beebb122633
    line: 123
    col: 0
    score: 1
  - uuid: 71726f04-eb1c-42a5-a5fe-d8209de6e159
    line: 34
    col: 0
    score: 1
  - uuid: f7702bf8-f7db-473c-9a5b-8dbf66ad3b9e
    line: 442
    col: 0
    score: 1
  - uuid: 5e8b2388-022b-46cf-952c-36ae9b8f0037
    line: 218
    col: 0
    score: 1
  - uuid: 008f2ac0-bfaa-4d52-9826-2d5e86c0059f
    line: 176
    col: 0
    score: 1
  - uuid: 938eca9c-97e2-4bcc-8653-b0ef1a5ac7a3
    line: 70
    col: 0
    score: 1
  - uuid: d17d3a96-c84d-4738-a403-6c733b874da2
    line: 587
    col: 0
    score: 1
  - uuid: 59b5670f-36d3-4d34-8985-f3144b15347a
    line: 138
    col: 0
    score: 1
  - uuid: b3555ede-324a-4d24-a885-b0721e74babf
    line: 53
    col: 0
    score: 1
  - uuid: 8430617b-80a2-4cc9-8288-9a74cb57990b
    line: 136
    col: 0
    score: 1
  - uuid: d8059b6a-c1ec-487d-8e0b-3ce33d6b4d06
    line: 613
    col: 0
    score: 1
  - uuid: 49a9a860-944c-467a-b532-4f99186a8593
    line: 59
    col: 0
    score: 1
  - uuid: c5c9a5c6-427d-4864-8084-c083cd55faa0
    line: 205
    col: 0
    score: 1
  - uuid: 4330e8f0-5f46-4235-918b-39b6b93fa561
    line: 635
    col: 0
    score: 1
  - uuid: 9c79206d-4cb9-4f00-87e0-782dcea37bc7
    line: 160
    col: 0
    score: 1
  - uuid: 6bcff92c-4224-453d-9993-1be8d37d47c3
    line: 144
    col: 0
    score: 1
  - uuid: 18344cf9-0c49-4a71-b6c8-b8d84d660fca
    line: 59
    col: 0
    score: 1
  - uuid: ae24a280-678e-4c0b-8cc4-56667fa04172
    line: 88
    col: 0
    score: 1
  - uuid: 9fab9e76-e283-4c9d-a8cd-cb76892ea7ac
    line: 14
    col: 0
    score: 1
  - uuid: 03a5578f-d689-45db-95e9-11300e5eee6f
    line: 93
    col: 0
    score: 1
  - uuid: 9413237f-2537-4bbf-8768-db6180970e36
    line: 13
    col: 0
    score: 1
  - uuid: 3a3bf2c9-c0f6-4d7b-bf84-c83c70dece3f
    line: 194
    col: 0
    score: 1
  - uuid: c0392040-16a2-41e8-bd54-75110319e3c0
    line: 19
    col: 0
    score: 1
---
# Functional Programming in TypeScript — a pragmatic, no-BS primer

You don’t need Haskell or heavy libs to write clean, composable, testable TypeScript. You **do** need discipline, a few tiny helpers, and a clear separation between **pure** code and **effects** (I/O, time, randomness). This primer keeps it practical and opinionated.

---

## TL;DR rules

1. **Make everything pure by default.** Function in → function out. No hidden mutation, time, I/O, or global state.
2. **Push effects to the edges.** Read files, call HTTP, get time *outside* your core logic; inject results in.
3. **Prefer data transformations.** Maps, filters, reduces, folds, combinators. Avoid classes with mutable state.
4. **Use types to forbid foot-guns.** `readonly`, `ReadonlyArray<T>`, discriminated unions.
5. **Compose small functions.** Build bigger behavior from tiny, focused pieces.
6. **Determinism beats cleverness.** If it’s hard to test, it’s probably too coupled to effects.

If you only follow those six, your codebase will already feel different.

---

## Core mental model

* **Pure layer:** all business logic, pure functions, total/typed. Deterministic and easy to fuzz/test.
* **Ports (effects) layer:** boundary interfaces for I/O (`readFile`, `fetchJson`, `now`, `randomInt`).
* **Adapters (wiring):** the only place you *actually* touch Node, fetch, fs, env vars, etc.

Think like a systems designer: functions are pipes, values flow through. You can swap adapters without touching the pure core.

---

## TypeScript features that matter

* **`readonly` and `ReadonlyArray<T>`**
* **Discriminated unions** (aka algebraic data types)
* **Narrowing & exhaustiveness** with `switch (x._tag) { ... }`
* **Utility types**: `Record<K,V>`, `Pick`, `Partial`, `ExactOptionalPropertyTypes`, `noUncheckedIndexedAccess`
* **`as const`** for literal safety
* **Generics** for reusable combinators

---

## A minimal FP “micro-kit” (no dependency)

Drop this into `shared/fp.ts`:

```ts
// shared/fp.ts
export const pipe = <A>(a: A, ...fns: Array<(x: any) => any>) =>
  fns.reduce((x, f) => f(x), a) as any;

export type Option<A> = { _tag: "None" } | { _tag: "Some"; value: A };
export const None: Option<never> = { _tag: "None" };
export const Some = <A>(value: A): Option<A> => ({ _tag: "Some", value });
export const O = {
  map:
    <A, B>(f: (a: A) => B) =>
    (oa: Option<A>): Option<B> =>
      (oa._tag === "Some" ? Some(f(oa.value)) : None),
  flatMap:
    <A, B>(f: (a: A) => Option<B>) =>
    (oa: Option<A>): Option<B> =>
      (oa._tag === "Some" ? f(oa.value) : None),
  getOrElse:
    <A>(onNone: () => A) =>
    (oa: Option<A>): A =>
      (oa._tag === "Some" ? oa.value : onNone()),
};

export type Result<E, A> = { _tag: "Ok"; value: A } | { _tag: "Err"; error: E };
export const Ok = <A>(value: A): Result<never, A> => ({ _tag: "Ok", value });
export const Err = <E>(error: E): Result<E, never> => ({ _tag: "Err", error });
export const R = {
  map:
    <E, A, B>(f: (a: A) => B) =>
    (ra: Result<E, A>): Result<E, B> =>
      (ra._tag === "Ok" ? Ok(f(ra.value)) : ra),
  flatMap:
    <E, A, B>(f: (a: A) => Result<E, B>) =>
    (ra: Result<E, A>): Result<E, B> =>
      (ra._tag === "Ok" ? f(ra.value) : ra),
};

export type Task<A> = () => Promise<A>;
export const T = {
  map:
    <A, B>(f: (a: A) => B) =>
    (ta: Task<A>): Task<B> =>
    async () =>
      f(await ta()),
  flatMap:
    <A, B>(f: (a: A) => Task<B>) =>
    (ta: Task<A>): Task<B> =>
    async () =>
      f(await ta())(),
};
```

You just got `pipe`, `Option`, `Result`, and a lightweight `Task` (aka lazy `Promise`). 90% of FP needs, covered.

---

## Everyday transformations (cheat sheet)

```ts
// Pure helpers (no mutation)
export const map = <A, B>(f: (a: A) => B) => (xs: ReadonlyArray<A>): ReadonlyArray<B> =>
  xs.map(f);

export const filter = <A>(p: (a: A) => boolean) => (xs: ReadonlyArray<A>) =>
  xs.filter(p);

export const reduce =
  <A, B>(zero: B, f: (b: B, a: A) => B) =>
  (xs: ReadonlyArray<A>) =>
    xs.reduce(f, zero);

export const groupBy = <A, K extends string | number | symbol>(
  key: (a: A) => K,
) => (xs: ReadonlyArray<A>): Readonly<Record<K, ReadonlyArray<A>>> =>
  xs.reduce((acc, x) => {
    const k = key(x);
    const bucket = acc[k] ?? [];
    return { ...acc, [k]: [...bucket, x] };
  }, {} as Record<K, A[]> as any);

export const uniqBy = <A, K>(key: (a: A) => K) => (xs: ReadonlyArray<A>) => {
  const seen = new Set<K>();
  const out: A[] = [];
  for (const x of xs) {
    const k = key(x);
    if (!seen.has(k)) { seen.add(k); out.push(x); }
  }
  return out as ReadonlyArray<A>;
};
```

Use with `pipe(data, map(...), filter(...), reduce(...))`.

---

## Error handling without drama

* Avoid throwing inside pure code. Use `Result<E,A>` for expected failures.
* Use `Option<A>` where absence is normal.
* Convert exceptions at the *edge* (adapter) to `Err`.

Example: parsing JSON safely with `Result`:

```ts
import { Result, Ok, Err } from "./shared/fp";

export const safeJson = <A = unknown>(s: string): Result<string, A> => {
  try {
    return Ok(JSON.parse(s) as A);
  } catch (e) {
    return Err(`Invalid JSON: ${(e as Error).message}`);
  }
};
```

Want schema validation? Use `zod` *in the adapter or a thin wrapper* so the core still sees a typed value or a `Result`.

```ts
import { z } from "zod";
import { Result, Ok, Err } from "./shared/fp";

const User = z.object({ id: z.string(), email: z.string().email() });
type User = z.infer<typeof User>;

export const parseUser = (u: unknown): Result<string, User> => {
  const r = User.safeParse(u);
  return r.success ? Ok(r.data) : Err(r.error.message);
};
```

---

## Async without spaghetti

Model async computations as **`Task<A>`** (aka `() => Promise<A>`). It’s lazy: nothing runs until you call it.

```ts
import { T } from "./shared/fp";

const getUser: Task<{ id: string }> = async () => ({ id: "u1" });

const program = T.map((u: { id: string }) => u.id)(getUser);
// Still nothing executed

program().then(console.log); // "u1"
```

Compose tasks:

```ts
import { T } from "./shared/fp";

const fetchUser = (id: string): Task<{ id: string; name: string }> =>
  async () => ({ id, name: "Alice" });

const fetchOrders = (id: string): Task<readonly string[]> =>
  async () => ["o1", "o2"];

const program = T.flatMap((u: { id: string }) =>
  T.map((orders: readonly string[]) => ({ user: u, orders }))(fetchOrders(u.id))
)(fetchUser("u1"));

const result = await program(); // { user: {...}, orders: [...] }
```

Concurrency? Use `Promise.all` at the edge:

```ts
const runAll = <A>(tasks: ReadonlyArray<Task<A>>): Task<ReadonlyArray<A>> =>
  async () => Promise.all(tasks.map((t) => t()));
```

---

## IO boundary (Ports & Adapters)

Define **ports** (interfaces) for effects. Core stays pure and gets ports injected.

```ts
// ports.ts
export type Ports = {
  now: () => number;                   // time
  readText: (path: string) => Promise<string>; // fs or http
  log: (msg: string) => void;          // logging
};
```

Core pipeline (pure **except** it *accepts* ports):

```ts
// core.ts
import { pipe } from "./shared/fp";
import { map, filter } from "./shared/array-ops";
import type { Ports } from "./ports";

export type Invoice = Readonly<{ id: string; amount: number; paid: boolean }>;

export const summarize = (ports: Ports) =>
  (invoices: ReadonlyArray<Invoice>) => {
    ports.log(`summarizing ${invoices.length} invoices at ${ports.now()}`);
    const total = pipe(
      invoices,
      filter((i) => !i.paid),
      map((i) => i.amount),
    ).reduce((a, b) => a + b, 0);
    return { outstanding: total, count: invoices.length } as const;
  };
```

Adapter for Node:

```ts
// adapters/node.ts
import fs from "node:fs/promises";
import { Ports } from "../ports";

export const nodePorts: Ports = {
  now: () => Date.now(),
  readText: (p) => fs.readFile(p, "utf8"),
  log: (m) => console.log(m),
};
```

Wire in `main` (only place with real effects):

```ts
// main.ts
import { nodePorts } from "./adapters/node";
import { summarize, type Invoice } from "./core";

const run = async () => {
  const data: ReadonlyArray<Invoice> = [
    { id: "1", amount: 10, paid: false },
    { id: "2", amount: 5, paid: true },
  ];
  const result = summarize(nodePorts)(data);
  console.log(result);
};

run();
```

---

## Testing with **AVA** (ESM, TypeScript, zero drama)

**`package.json`**

```json
{
  "type": "module",
  "scripts": {
    "test": "ava"
  },
  "devDependencies": {
    "ava": "^6.0.0",
    "ts-node": "^10.9.2",
    "typescript": "^5.6.2"
  },
  "ava": {
    "extensions": {
      "ts": "module"
    },
    "nodeArguments": ["--loader=ts-node/esm"],
    "require": []
  }
}
```

**`tsconfig.json`**

```json
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "strict": true,
    "noUncheckedIndexedAccess": true,
    "exactOptionalPropertyTypes": true,
    "verbatimModuleSyntax": true,
    "resolveJsonModule": true,
    "skipLibCheck": true
  }
}
```

**A pure test with faked ports**

```ts
// test/core.test.ts
import test from "ava";
import { summarize, type Invoice } from "../src/core";
import type { Ports } from "../src/ports";

const fakePorts: Ports = {
  now: () => 1234567890,
  readText: async () => "unused",
  log: () => void 0,
};

test("summarize computes outstanding correctly (pure core)", (t) => {
  const invoices: ReadonlyArray<Invoice> = [
    { id: "1", amount: 10, paid: false },
    { id: "2", amount: 5, paid: true },
  ];
  const result = summarize(fakePorts)(invoices);
  t.deepEqual(result, { outstanding: 10, count: 2 });
});
```

No files touched. No clocks. Fast.

---

## Discriminated unions for real-world modeling

Stop passing `any`. Model state explicitly.

```ts
type Loading = { _tag: "Loading" };
type Loaded<A> = { _tag: "Loaded"; data: A };
type Failed = { _tag: "Failed"; reason: string };
type RemoteData<A> = Loading | Loaded<A> | Failed;

const foldRemote = <A, B>(
  onLoading: () => B,
  onLoaded: (a: A) => B,
  onFailed: (e: string) => B,
) => (r: RemoteData<A>): B => {
  switch (r._tag) {
    case "Loading": return onLoading();
    case "Loaded":  return onLoaded(r.data);
    case "Failed":  return onFailed(r.reason);
  }
};
```

Use `foldRemote` to render UI, choose retries, etc. Exhaustiveness guarantees you didn’t forget a case.

---

## Reducers: managing state the functional way

Event → reduce → new state. No mutation necessary.

```ts
type Cart = Readonly<{ items: ReadonlyArray<{ sku: string; qty: number }> }>;
type Add = { _tag: "Add"; sku: string; qty: number };
type Remove = { _tag: "Remove"; sku: string };
type Event = Add | Remove;

const reduceCart = (state: Cart, ev: Event): Cart => {
  switch (ev._tag) {
    case "Add": {
      const idx = state.items.findIndex(i => i.sku === ev.sku);
      if (idx === -1) return { items: [...state.items, { sku: ev.sku, qty: ev.qty }] };
      const next = state.items.map((i, j) => j === idx ? { ...i, qty: i.qty + ev.qty } : i);
      return { items: next };
    }
    case "Remove":
      return { items: state.items.filter(i => i.sku !== ev.sku) };
  }
};
```

---

## Performance & pragmatism

* **Copying is cheap** for small to medium data; profile before micro-optimizing.
* Use **structural sharing** (`{ ...obj, x }`, `[...arr, x]`) instead of mutation.
* Avoid `Object.freeze` in hot paths—it’s slower.
* If performance demands it, isolate a tiny imperative hotspot and keep the *surface* pure.

---

## When to reach for libraries

* **You can ship with just this primer.** For big projects, consider:

  * `zod` for schema validation
  * `fp-ts` for a batteries-included FP toolkit (Option/Either/TaskEither/ReadonlyArray, etc.)
  * `effect` or `neverthrow` if you want structured effects or ergonomic `Result`

Be honest: libraries help, but they also lock you into idioms. Start tiny, add when it hurts.

---

## An end-to-end mini example

**Goal:** Parse lines of CSV *content* (no I/O), validate rows, aggregate totals.

```ts
// csv-core.ts
import { Ok, Err, Result } from "./shared/fp";

export type Row = Readonly<{ sku: string; qty: number; price: number }>;

export const parseCsv = (s: string): ReadonlyArray<ReadonlyArray<string>> =>
  s.split(/\r?\n/).filter(Boolean).map((line) => line.split(",").map((x) => x.trim()));

export const toRow = (cells: ReadonlyArray<string>): Result<string, Row> => {
  if (cells.length !== 3) return Err("Expected 3 columns");
  const [sku, qtyS, priceS] = cells;
  const qty = Number(qtyS); const price = Number(priceS);
  return Number.isFinite(qty) && Number.isFinite(price) && sku
    ? Ok({ sku, qty, price })
    : Err("Invalid number or missing sku");
};

export const total = (rows: ReadonlyArray<Row>) =>
  rows.reduce((acc, r) => acc + r.qty * r.price, 0);
```

**Ports & wiring (I/O at edge):**

```ts
// csv-main.ts
import fs from "node:fs/promises";
import { parseCsv, toRow, total } from "./csv-core";
import { Result } from "./shared/fp";

const main = async (path: string) => {
  const text = await fs.readFile(path, "utf8");
  const results = parseCsv(text).map(toRow);
  const errors = results.filter((r) => r._tag === "Err") as Result<string, never>[];
  if (errors.length) {
    console.error("Errors:", errors.map((e) => e.error));
    process.exitCode = 1;
    return;
  }
  const rows = results.map((r: any) => r.value);
  console.log("Total =", total(rows));
};

main(process.argv[2] ?? "in.csv");
```

**Test the pure bits with AVA:**

```ts
// test/csv-core.test.ts
import test from "ava";
import { parseCsv, toRow, total } from "../src/csv-core";

test("parseCsv splits lines/cells", (t) => {
  t.deepEqual(parseCsv("a,b,c\n1,2,3"), [["a","b","c"],["1","2","3"]]);
});

test("toRow validates cells", (t) => {
  const ok = toRow(["sku1","2","3.5"]);
  t.is(ok._tag, "Ok");
  const err = toRow(["only","two"]);
  t.is(err._tag, "Err");
});

test("total multiplies qty * price", (t) => {
  t.is(total([{ sku:"x", qty:2, price:3 }]), 6);
});
```

---

## Pitfalls to avoid

* **Hidden effects in “helpers.”** If it logs, reads, or mutates, it’s not pure.
* **Implicit time.** `Date.now()` inside core logic will wreck determinism. Pass `now` in.
* **Shared mutable caches.** Prefer functional caches (memoize with explicit scope) or move caching to the adapter.
* **Overengineering with monads.** If a `try { } catch { }` in the adapter is fine, do that. Keep the core small and typed.

---

## Minimal checklist for new modules

* [ ] Pure functions first; effects injected as parameters.
* [ ] `readonly` everywhere feasible.
* [ ] Types model reality (discriminated unions for states).
* [ ] AVA tests for core logic (no I/O).
* [ ] One adapter file per environment (Node, browser, test fakes).
* [ ] `pipe` + small combinators over giant class hierarchies.

---

### Final word

Functional programming in TS isn’t about dogma. It’s about **predictability under change**. Keep the mathy stuff light, the boundaries clean, and the values flowing.

\#typescript #functional-programming #primer #typescript-tips #immutability #composition #option #result #task #ports-and-adapters #zod #ava #testing #patterns #reducers #discriminated-unions #clean-architecture
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-BELOW -->
## Related content
- [polyglot-repl-interface-layer](polyglot-repl-interface-layer.md)
- [Post-Linguistic Transhuman Design Frameworks](post-linguistic-transhuman-design-frameworks.md)
- [Promethean Chat Activity Report](promethean-chat-activity-report.md)
- [Promethean-Copilot-Intent-Engine](promethean-copilot-intent-engine.md)
- [Promethean Data Sync Protocol](promethean-data-sync-protocol.md)
- [Promethean Dev Workflow Update](promethean-dev-workflow-update.md)
- [Promethean Documentation Overview](promethean-documentation-overview.md)
- [Promethean Documentation Pipeline Overview](promethean-documentation-pipeline-overview.md)
- [Promethean Documentation Update](promethean-documentation-update.md)
- [Pure TypeScript Search Microservice](pure-typescript-search-microservice.md)
- [Reawakening Duck](reawakening-duck.md)
- [Redirecting Standard Error](redirecting-standard-error.md)
- [ripple-propagation-demo](ripple-propagation-demo.md)
- [schema-evolution-workflow](schema-evolution-workflow.md)
- [Self-Agency in AI Interaction](self-agency-in-ai-interaction.md)
- [sibilant-macro-targets](sibilant-macro-targets.md)
- [Stateful Partitions and Rebalancing](stateful-partitions-and-rebalancing.md)
- [Creative Moments](creative-moments.md)
- [Docops Feature Updates](docops-feature-updates-2.md)
- [Docops Feature Updates](docops-feature-updates.md)
- [Duck's Attractor States](ducks-attractor-states.md)
- [Duck's Self-Referential Perceptual Loop](ducks-self-referential-perceptual-loop.md)
- [Dynamic Context Model for Web Components](dynamic-context-model-for-web-components.md)
- [Shared](chunks/shared.md)
- [Simulation Demo](chunks/simulation-demo.md)
- [Tooling](chunks/tooling.md)
- [Eidolon Field Abstract Model](eidolon-field-abstract-model.md)
- [eidolon-field-math-foundations](eidolon-field-math-foundations.md)
- [eidolon-node-lifecycle](eidolon-node-lifecycle.md)
- [Window Management](chunks/window-management.md)
- [Debugging Broker Connections and Agent Behavior](debugging-broker-connections-and-agent-behavior.md)
- [DuckDuckGoSearchPipeline](duckduckgosearchpipeline.md)
## Sources
- [Window Management — L11](chunks/window-management.md#^ref-9e8ae388-11-0) (line 11, col 0, score 1)
- [Creative Moments — L47](creative-moments.md#^ref-10d98225-47-0) (line 47, col 0, score 1)
- [Debugging Broker Connections and Agent Behavior — L105](debugging-broker-connections-and-agent-behavior.md#^ref-73d3dbf6-105-0) (line 105, col 0, score 1)
- [Docops Feature Updates — L97](docops-feature-updates-2.md#^ref-cdbd21ee-97-0) (line 97, col 0, score 1)
- [Docops Feature Updates — L128](docops-feature-updates.md#^ref-2792d448-128-0) (line 128, col 0, score 1)
- [DuckDuckGoSearchPipeline — L31](duckduckgosearchpipeline.md#^ref-e979c50f-31-0) (line 31, col 0, score 1)
- [Duck's Attractor States — L90](ducks-attractor-states.md#^ref-13951643-90-0) (line 90, col 0, score 1)
- [Duck's Self-Referential Perceptual Loop — L33](ducks-self-referential-perceptual-loop.md#^ref-71726f04-33-0) (line 33, col 0, score 1)
- [Dynamic Context Model for Web Components — L462](dynamic-context-model-for-web-components.md#^ref-f7702bf8-462-0) (line 462, col 0, score 1)
- [Shared — L21](chunks/shared.md#^ref-623a55f7-21-0) (line 21, col 0, score 1)
- [Simulation Demo — L39](chunks/simulation-demo.md#^ref-557309a3-39-0) (line 39, col 0, score 1)
- [Tooling — L28](chunks/tooling.md#^ref-6cb4943e-28-0) (line 28, col 0, score 1)
- [Creative Moments — L28](creative-moments.md#^ref-10d98225-28-0) (line 28, col 0, score 1)
- [Docops Feature Updates — L65](docops-feature-updates-2.md#^ref-cdbd21ee-65-0) (line 65, col 0, score 1)
- [Docops Feature Updates — L86](docops-feature-updates.md#^ref-2792d448-86-0) (line 86, col 0, score 1)
- [Duck's Attractor States — L123](ducks-attractor-states.md#^ref-13951643-123-0) (line 123, col 0, score 1)
- [Duck's Self-Referential Perceptual Loop — L34](ducks-self-referential-perceptual-loop.md#^ref-71726f04-34-0) (line 34, col 0, score 1)
- [Dynamic Context Model for Web Components — L442](dynamic-context-model-for-web-components.md#^ref-f7702bf8-442-0) (line 442, col 0, score 1)
- [Eidolon Field Abstract Model — L218](eidolon-field-abstract-model.md#^ref-5e8b2388-218-0) (line 218, col 0, score 1)
- [eidolon-field-math-foundations — L176](eidolon-field-math-foundations.md#^ref-008f2ac0-176-0) (line 176, col 0, score 1)
- [eidolon-node-lifecycle — L70](eidolon-node-lifecycle.md#^ref-938eca9c-70-0) (line 70, col 0, score 1)
- [Pure TypeScript Search Microservice — L587](pure-typescript-search-microservice.md#^ref-d17d3a96-587-0) (line 587, col 0, score 1)
- [Reawakening Duck — L138](reawakening-duck.md#^ref-59b5670f-138-0) (line 138, col 0, score 1)
- [Redirecting Standard Error — L53](redirecting-standard-error.md#^ref-b3555ede-53-0) (line 53, col 0, score 1)
- [ripple-propagation-demo — L136](ripple-propagation-demo.md#^ref-8430617b-136-0) (line 136, col 0, score 1)
- [schema-evolution-workflow — L613](schema-evolution-workflow.md#^ref-d8059b6a-613-0) (line 613, col 0, score 1)
- [Self-Agency in AI Interaction — L59](self-agency-in-ai-interaction.md#^ref-49a9a860-59-0) (line 59, col 0, score 1)
- [sibilant-macro-targets — L205](sibilant-macro-targets.md#^ref-c5c9a5c6-205-0) (line 205, col 0, score 1)
- [Stateful Partitions and Rebalancing — L635](stateful-partitions-and-rebalancing.md#^ref-4330e8f0-635-0) (line 635, col 0, score 1)
- [polyglot-repl-interface-layer — L160](polyglot-repl-interface-layer.md#^ref-9c79206d-160-0) (line 160, col 0, score 1)
- [Post-Linguistic Transhuman Design Frameworks — L144](post-linguistic-transhuman-design-frameworks.md#^ref-6bcff92c-144-0) (line 144, col 0, score 1)
- [Promethean Chat Activity Report — L59](promethean-chat-activity-report.md#^ref-18344cf9-59-0) (line 59, col 0, score 1)
- [Promethean-Copilot-Intent-Engine — L88](promethean-copilot-intent-engine.md#^ref-ae24a280-88-0) (line 88, col 0, score 1)
- [Promethean Data Sync Protocol — L14](promethean-data-sync-protocol.md#^ref-9fab9e76-14-0) (line 14, col 0, score 1)
- [Promethean Dev Workflow Update — L93](promethean-dev-workflow-update.md#^ref-03a5578f-93-0) (line 93, col 0, score 1)
- [Promethean Documentation Overview — L13](promethean-documentation-overview.md#^ref-9413237f-13-0) (line 13, col 0, score 1)
- [Promethean Documentation Pipeline Overview — L194](promethean-documentation-pipeline-overview.md#^ref-3a3bf2c9-194-0) (line 194, col 0, score 1)
- [Promethean Documentation Update — L19](promethean-documentation-update.md#^ref-c0392040-19-0) (line 19, col 0, score 1)
<!-- GENERATED-SECTIONS:DO-NOT-EDIT-ABOVE -->

I have this script I use to lint the diff on my local work env, and I'd like to use
something like this for the codex sand box
```bash
#!/usr/bin/env bash
set -euo pipefail
# 1) Figure out the upstream ref (tracking branch or origin/<default>)
upstream_ref="$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream} 2>/dev/null \
  || { git remote show origin | sed -n '/HEAD branch/s/.*: //p' | sed 's/^/origin\//'; })"
# 2) Ensure we have the remote refs
git fetch --quiet "${upstream_ref%%/*}"  # usually "origin"
# 3) Merge-base (three-dot semantics)
mb="$(git merge-base HEAD "$upstream_ref")"
# 4) Diff -> ESLint (NUL-delimited; ignore deletions)
git diff -z --name-only --diff-filter=d "$mb"...HEAD -- '*.ts' '*.tsx' \
    | xargs -0 --no-run-if-empty eslint --cache --pass-on-no-patterns

```

But the setup does this right before I get to run any scripts

```bash
# From https://github.com/riatzukiza/promethean
# * branch              main       -> FETCH_HEAD
# * [new branch]        main       -> origin/main
git -C /workspace/promethean branch -m work old_work-1757532571
git -C /workspace/promethean switch -c work FETCH_HEAD
# Switched to a new branch 'work'
git -C /workspace/promethean branch -D old_work-1757532571
# Deleted branch old_work-1757532571 (was 664ecd4d).
git -C /workspace/promethean remote remove origin
git -C /workspace/promethean status
# On branch work
# nothing to commit, working tree clean
git -C /workspace/promethean rev-parse HEAD
```

So there is no origin, there is no upstream at all.
And I'm not sure what all the flags are doing here.
So I don't actually know what is there.

I want to save the bots the pain of linting the entire project (They just Ctrl+C any way if it takes too long) with this one command so they are less likely to selectively pick the files they choose to lint, so they're less likely to try and hide errors from me.

---


Got it. The sandbox is blowing away your usual assumptions:

* It creates a new branch (`work`) from `FETCH_HEAD`, then removes the `origin` remote. So there’s no upstream to query and no remotes left.
* Your current `HEAD` at sandbox start is exactly the commit they fetched into `FETCH_HEAD`. After that, you typically make uncommitted edits (no new local commits).
* Your old script relies on `@{upstream}` and a remote fetch; both are gone here.

### What those commands/flags are doing (in plain English)

* `FETCH_HEAD` — a ref written by `git fetch` to record exactly what got fetched; it lives at `.git/FETCH_HEAD`. It’s valid to diff/merge against it. ([Git][1], [Stack Overflow][2])
* `git merge-base A B` — finds the best common ancestor of two commits; the “three-dot” diff (`A...B`) uses this idea. ([Git][3], [GitHub Docs][4])
* `git diff --name-only --diff-filter=d` — list only file names, excluding deletions (`d` removed from the set), which is what you want for lint. ([Git][5], [Stack Overflow][6])
* `xargs -0 --no-run-if-empty` — read NUL-delimited names and don’t run ESLint at all if the list is empty (GNU extension). ([man7.org][7], [Stack Overflow][8])
* `eslint --pass-on-no-patterns` — on ESLint 9, this makes “no files matched” exit 0 instead of erroring. ([eslint.org][9])

---

## A sandbox-proof “lint the diff” script

This does three things:

1. Try an upstream if it exists (works in your local env).
2. Else, fall back to the startup commit for this sandbox (first/oldest reflog entry of the current branch, which will be the commit created from `FETCH_HEAD`).
3. Lint only files changed since that baseline, including uncommitted edits, and ignore deletions.

```bash
#!/usr/bin/env bash
set -euo pipefail

# Find a sensible BASE commit for "what changed".
if upstream_ref="$(git rev-parse --abbrev-ref --symbolic-full-name @{upstream} 2>/dev/null)"; then
  # Local env: we have a tracking branch; use three-dot semantics vs upstream.
  git fetch --quiet "${upstream_ref%%/*}" || true
  base="$(git merge-base HEAD "$upstream_ref")"
else
  # Sandbox: no remotes. Use the *oldest* reflog entry of the current branch
  # (that's the commit created from FETCH_HEAD at sandbox start).
  # If reflog is missing for some reason, fall back to FETCH_HEAD itself.
  if base="$(git reflog --format=%H | tail -1)"; then
    :
  elif git rev-parse -q --verify FETCH_HEAD >/dev/null 2>&1; then
    base="$(git rev-parse FETCH_HEAD)"
  else
    # Absolute last resort: just lint staged/working changes vs HEAD
    base="HEAD"
  fi
fi

# Persist the chosen base so subsequent runs are consistent (optional).
printf '%s' "$base" > .git/BOT_BASE_SHA 2>/dev/null || true

# Lint only changed TypeScript files vs BASE, including uncommitted edits.
# We compare BASE -> working tree (single-commit form of `git diff`),
# list paths NUL-delimited, skip deletions, then eslint them.
git diff -z --name-only --diff-filter=d "$base" -- '*.ts' '*.tsx' \
  | xargs -0 --no-run-if-empty eslint --cache --pass-on-no-patterns
```

**Why single-commit `git diff "$base"` instead of `"$base"...HEAD`?**
The three-dot form only compares *commits*; it ignores uncommitted changes. Using the one-side form (`git diff BASE`) compares the working tree directly to `BASE`, which is what you want in this sandbox. ([Git][3], [GitHub Docs][4])

---

## Even simpler (and faster) alternative: lint only files you actually touched

In this sandbox you often don’t create commits; you just edit files. You can skip diffing entirely and ask Git for “modified *or untracked* files, respecting .gitignore”, then lint those:

```bash
#!/usr/bin/env bash
set -euo pipefail

# Modified (tracked) + untracked & not ignored, NUL-delimited:
git ls-files -z -m -o --exclude-standard -- '*.ts' '*.tsx' \
  | xargs -0 --no-run-if-empty eslint --cache --pass-on-no-patterns
```

* `-m` = modified tracked files; `-o` = others (untracked); `--exclude-standard` honors `.gitignore`. This is very quick and usually matches what you mean by “what changed locally.” ([Cheat-Sheets.org][10])

If you want to **combine** both worlds (changed since baseline *plus* brand-new untracked files that wouldn’t show up in a pure commit diff), stick with the `ls-files` version above—that’s what most folks end up preferring for pre-commit/pre-push style linting.

---

## Quick sanity checks you can run in the sandbox

These help you confirm what the environment actually did:

```bash
git show -s --oneline HEAD          # The baseline commit they checked out
git remote -v                       # (likely empty)
git reflog --date=iso --format='%H %gs' | tail -5  # Oldest reflog entry is your sandbox baseline
test -f .git/FETCH_HEAD && head -n1 .git/FETCH_HEAD  # Shows last fetched refs
```

* `FETCH_HEAD` is written by `git fetch` and can be inspected; it’s totally fine to base diffs on it. ([Git][1])

---

### Bottom line

* Your original “upstream” script is right for your local repo, but the sandbox removes remotes and tracking, so you need a different base.
* The **reflog-oldest** trick gives you a stable baseline for the current sandbox session, and the **`ls-files`** variant is the fastest “don’t lint the whole world” approach.

If you want, I can tailor this into a tiny `bin/lint-diff` that autodetects sandbox vs. local and prints what it’s linting for transparency.

[1]: https://git-scm.com/docs/git-fetch/2.24.0?utm_source=chatgpt.com "Git - git-fetch Documentation"
[2]: https://stackoverflow.com/questions/9237348/what-does-fetch-head-in-git-mean?utm_source=chatgpt.com "What does FETCH_HEAD in Git mean?"
[3]: https://git-scm.com/docs/git-merge-base?utm_source=chatgpt.com "Git - git-merge-base Documentation"
[4]: https://docs.github.com/articles/about-comparing-branches-in-pull-requests?utm_source=chatgpt.com "About comparing branches in pull requests"
[5]: https://git-scm.com/docs/diff-options?utm_source=chatgpt.com "Git - diff-options Documentation"
[6]: https://stackoverflow.com/questions/63990974/git-diff-name-status-showing-files-that-does-not-exists?utm_source=chatgpt.com "git diff --name-status showing files that does not exists"
[7]: https://man7.org/linux/man-pages/man1/xargs.1.html?utm_source=chatgpt.com "xargs(1) - Linux manual page"
[8]: https://stackoverflow.com/questions/8296710/how-to-ignore-xargs-commands-if-stdin-input-is-empty?utm_source=chatgpt.com "How to ignore xargs commands if stdin input is empty?"
[9]: https://eslint.org/docs/latest/use/migrate-to-9.0.0?utm_source=chatgpt.com "Migrate to v9.x - ESLint - Pluggable JavaScript Linter"
[10]: https://www.cheat-sheets.org/project/tldr/command/git-ls-files/?utm_source=chatgpt.com "git ls files TLDR page"

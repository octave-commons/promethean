Yeah, you can absolutely make this work with hooks. The clean mental model is:

* **Keep `[[wikilinks]]` in your source.** They’re ergonomic for you and for AI.
* **On push to certain remotes (e.g., GitHub), run a conversion step** that rewrites them to standard Markdown links in a build/export dir, then push/commit from there (or publish that dir).
* Use **Git hooks** (plain hooks or Husky) to automate it and block pushes if the conversion fails. ([Git SCM][1])

Below is a practical, minimal setup.

---

# 1) Pick a converter

You’ve got two solid options:

**A. `obsidian-export` (CLI) — zero fuss**
Converts an Obsidian vault to plain/CommonMark Markdown, resolving `[[wikilinks]]` and embeds. Great if you don’t want to maintain custom code. ([GitHub][2])

**B. `remark` pipeline — customizable**
Use `remark-wiki-link` to parse `[[wikilinks]]` and `remark-stringify` to emit standard links. You can control paths, slugs, etc. Ideal if you need repo-root or GitHub-style URLs. ([GitHub][3])

Obsidian-side toggles/plugins exist too (core “Markdown format converter”, community “Wikilinks to MDLinks”), but they’re manual/interactive; hooks are better for repeatable CI-ish behavior. ([Obsidian Forum][4])

---

# 2) Detect the remote in a hook

Use a **pre-push** hook so you only do the work when you’re actually pushing, and only for specific remotes (e.g., `github.com`). Pre-push is the right place to gate a push; `--no-verify` can override if you need to bypass. ([Git SCM][5])

**Shell snippet (`.husky/pre-push` or `.git/hooks/pre-push`):**

```bash
#!/usr/bin/env bash
set -euo pipefail

remote_name="$1"
remote_url="$(git remote get-url "$remote_name")"

# Only run the conversion when pushing to GitHub
if [[ "$remote_url" == *"github.com"* ]]; then
  echo "[pre-push] GitHub remote detected: $remote_url"
  # Example: export to ./dist/notes using obsidian-export OR node script
  pnpm run export-md

  # Optional: sanity check – fail push if export introduces unresolved links
  if rg -n '\[\[[^]]+\]\]' dist >/dev/null; then
    echo "Found wikilinks in dist/ after export. Failing push."
    exit 1
  fi
else
  echo "[pre-push] Non-GitHub remote ($remote_url). Skipping export."
fi
```

* Plain Git hooks are documented here; Husky makes them easy in JS projects. Run `npx husky init`, then drop the script into `.husky/pre-push` and make it executable. ([Git SCM][6])

---

# 3) Fast path: `obsidian-export` script

Add a script that exports your vault to a clean folder (`dist/`), rewriting links:

```json
// package.json (scripts)
{
  "scripts": {
    "export-md": "rimraf dist && obsidian-export ./vault ./dist"
  },
  "devDependencies": {
    "obsidian-export": "^24.0.0",
    "rimraf": "^6.0.0"
  }
}
```

* `obsidian-export` recursively converts to CommonMark and resolves Obsidian quirks (aliases, embeds, etc.). That’s usually enough for GitHub to render everything correctly. ([GitHub][2])

---

# 4) Custom path rules? Use a `remark` pipeline

If you want **repo-root** links or custom slugs, wire up `remark`:

```ts
// tools/export-md.ts (Node ESM, functional style)
import { readFile, writeFile, mkdir, rm } from 'node:fs/promises';
import { join, dirname } from 'node:path';
import { globby } from 'globby';
import { unified } from 'unified';
import remarkParse from 'remark-parse';
import remarkStringify from 'remark-stringify';
import wikiLink from 'remark-wiki-link';

const exportVault = async (src: string, out: string) => {
  await rm(out, { recursive: true, force: true });
  await mkdir(out, { recursive: true });

  const files = await globby(['**/*.md'], { cwd: src, dot: false });
  const processFile = async (rel: string) => {
    const input = await readFile(join(src, rel), 'utf8');
    const permalinks = files.map(f => f.replace(/\.md$/i, '')); // helps resolve existing pages

    const file = await unified()
      .use(remarkParse)
      .use(wikiLink, {
        permalinks,
        hrefTemplate: (permalink: string) =>
          // Example: link to repo-root file names: /<Note>.md
          '/' + permalink.replace(/\\/g, '/').replace(/ /g, '%20') + '.md'
      })
      .use(remarkStringify, { fences: true })
      .process(input);

    const outPath = join(out, rel);
    await mkdir(dirname(outPath), { recursive: true });
    await writeFile(outPath, String(file), 'utf8');
  };

  await Promise.all(files.map(processFile));
};

const [ , , srcDir = './vault', outDir = './dist'] = process.argv;
exportVault(srcDir, outDir).catch(err => {
  console.error(err);
  process.exit(1);
});
```

Then:

```json
{
  "type": "module",
  "scripts": {
    "export-md": "node tools/export-md.ts"
  },
  "devDependencies": {
    "globby": "^14.0.0",
    "remark-parse": "^11.0.0",
    "remark-stringify": "^11.0.0",
    "remark-wiki-link": "^2.0.0",
    "unified": "^11.0.0"
  }
}
```

* `remark-wiki-link` parses `[[...]]` (including aliases) and lets you **decide** how to emit the hrefs, which is perfect for GitHub-root or relative paths. ([GitHub][3])

---

# 5) What about doing it on commit instead?

You *can*, but I don’t love modifying tracked files in a `pre-commit` (it’s brittle unless you carefully restage). `pre-push` is safer: build to `dist/`, verify, then proceed. If you *must* do it on commit, follow the Git book’s guidance and restage updated files, or use a tool like Husky + lint-staged. ([Git SCM][1])

---

# 6) Optional hard-stop protections

* Fail the push if unresolved `[[...]]` remain in `dist/`.
* Fail if `dist/` contains links to missing files.
* Add a `--no-verify` escape hatch for emergencies (standard Git behavior). ([Git SCM][5])

---

## Opinionated take

* **Best DX:** Keep Obsidian-native `[[wikilinks]]` in your vault.
* **Best portability:** Convert on **pre-push** for remotes that require standard Markdown (GitHub).
* **Least maintenance:** Use `obsidian-export`.
* **Most control:** Use `remark` and set `hrefTemplate` to your repo’s conventions.

If you want, tell me your repo’s shape (root vs `/docs`, any slug rules), and I’ll tailor the `hrefTemplate` + a tiny test using **ava** to snapshot the conversions.

[1]: https://git-scm.com/book/en/v2/Customizing-Git-Git-Hooks?utm_source=chatgpt.com "Git Hooks"
[2]: https://github.com/zoni/obsidian-export?utm_source=chatgpt.com "zoni/obsidian-export: Rust library and CLI to ..."
[3]: https://github.com/landakram/remark-wiki-link?utm_source=chatgpt.com "landakram/remark-wiki-link: Parse and render ..."
[4]: https://forum.obsidian.md/t/convert-or-export-to-md/7155?utm_source=chatgpt.com "Convert or Export [[]] to [](.md)"
[5]: https://git-scm.com/docs/git-push?utm_source=chatgpt.com "Git - git-push Documentation"
[6]: https://git-scm.com/docs/githooks?utm_source=chatgpt.com "Git - githooks Documentation"

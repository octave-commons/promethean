Hmmmm I'm thinkin about this real hard... I actually have my vault located at /home/err/devel/promethean/docs right now, because obsidian is kinda retarded and even when it's ignoreing file like node modules, in reality, they are still there. You can't have a fast vault *and* have active node_modules present. Obsidian only truly ignores "hidden" files, like `.smart_env`, so to have the vault located at the repo root.... is not good, so the smart env file isn't located there. Not as if it includes code files any way...............

Here is what I am thinking.......... screw the smart ENV all together.... We already have chroma..... I REALLY want duck to be able to see my files when we are talking...... but he isn't there yet..... but we COULD get a CustomGPT with access to the code base, and that could accelerate development big time.......... so....... Redo this... I will give you the embedding function we use in promethean....

```typescript
//services/ts/dicosrd-embedder/src/embedder.ts
import type { EmbeddingFunction, EmbeddingFunctionSpace } from 'chromadb';
// @ts-ignore import js module without types
import { BrokerClient } from '@shared/js/brokerClient.js';
import { randomUUID } from 'crypto';

export class RemoteEmbeddingFunction implements EmbeddingFunction {
	name = 'remote';
	driver: string | undefined;
	fn: string | undefined;
	broker: BrokerClient;
	#ready: Promise<void>;
	#pending: ((embeddings: number[][]) => void)[] = [];
	#replyId: string;

	constructor(
		brokerUrl = process.env.BROKER_URL || 'ws://localhost:7000',
		driver = process.env.EMBEDDING_DRIVER,
		fn = process.env.EMBEDDING_FUNCTION,
		broker?: BrokerClient,
	) {
		this.driver = driver;
		this.fn = fn;
		this.#replyId = randomUUID();
		this.broker =
			broker ||
			new BrokerClient({
				url: brokerUrl,
				id: `discord-embed-${this.#replyId}`,
			});
		this.#ready = this.broker
			.connect()
			.then(() => {
				this.broker.subscribe('embedding.result', (event: any) => {
					if (event.replyTo !== this.#replyId) return;
					const resolve = this.#pending.shift();
					if (resolve) {
						resolve(event.payload.embeddings);
					}
				});
			})
			.catch((err: unknown) => {
				console.error('Failed to connect to broker', err);
			});
	}

	async generate(texts: string[]): Promise<number[][]> {
		const items = texts.map((t) =>
			t.startsWith('img:') ? { type: 'image_url', data: t.slice(4) } : { type: 'text', data: t },
		);
		await this.#ready;
		return new Promise((resolve) => {
			this.#pending.push(resolve);
			this.broker.enqueue('embedding.generate', {
				items,
				driver: this.driver,
				function: this.fn,
				replyTo: this.#replyId,
			});
		});
	}

	defaultSpace(): EmbeddingFunctionSpace {
		return 'l2';
	}
	supportedSpaces(): EmbeddingFunctionSpace[] {
		return ['l2', 'cosine'];
	}
	static fromConfig(cfg: { driver: string; fn: string; brokerUrl?: string }): RemoteEmbeddingFunction {
		return new RemoteEmbeddingFunction(cfg.brokerUrl, cfg.driver, cfg.fn);
	}
	getConfig() {
		return {};
	}
}
```


Here is how we embed discord:

```typescript
//services/ts/dicosrd-embedder/src/index.ts
import { ChromaClient } from 'chromadb';
import { RemoteEmbeddingFunction } from './embedding';
import { MongoClient, ObjectId, Collection } from 'mongodb';
import { AGENT_NAME } from '@shared/js/env.js';
import { HeartbeatClient } from '@shared/js/heartbeat/index.js';
import { collectionFor, CONFIG_FP } from '@shared/js/embeddings/versioning.js';

const chromaClient = new ChromaClient();

type MessageMetaData = { timeStamp: number; userName: string };
type ChromaQuery = {
	ids: string[];
	documents: string[];
	metadatas: MessageMetaData[];
};
type DiscordMessage = {
	_id: ObjectId;
	created_at: number;
	author: number;
	channel: number;
	channel_name: string;
	author_name: string;
	content: string | null;
	embedding_status?: Record<string, 'processing' | 'done' | 'error'>;
};

const MONGO_CONNECTION_STRING = process.env.MONGODB_URI || `mongodb://localhost`;
const EMBED_VERSION = process.env.EMBED_VERSION || new Date().toISOString().slice(0, 10);
const EMBEDDING_DRIVER = process.env.EMBEDDING_DRIVER || 'ollama';
const EMBEDDING_FUNCTION = process.env.EMBEDDING_FUNCTION || 'nomic-embed-text';
const EMBED_DIMS = Number(process.env.EMBED_DIMS || 768);

(async () => {
	const hb = new HeartbeatClient();
	await hb.sendOnce().catch(() => process.exit(1));
	hb.start();

	const mongoClient = new MongoClient(MONGO_CONNECTION_STRING);
	await mongoClient.connect();
	const db = mongoClient.db('database');

	const family = `${AGENT_NAME}_discord_messages`;
	const collectionName = family;
	const discordMessagesCollection: Collection<DiscordMessage> = db.collection(collectionName);

	const aliases = db.collection<{ _id: string }>('collection_aliases');
	const cfg = {
		driver: EMBEDDING_DRIVER,
		fn: EMBEDDING_FUNCTION,
		dims: EMBED_DIMS,
	};
	const target = collectionFor(family, EMBED_VERSION, cfg);
	await aliases.updateOne(
		{ _id: family },
		{
			$setOnInsert: { _id: family },
			$set: {
				target,
				embed: { ...cfg, version: EMBED_VERSION, config_fp: CONFIG_FP(cfg) },
			},
		},
		{ upsert: true },
	);

	const chromaCollection = await chromaClient.getOrCreateCollection({
		name: target,
		embeddingFunction: RemoteEmbeddingFunction.fromConfig({
			driver: EMBEDDING_DRIVER,
			fn: EMBEDDING_FUNCTION,
		}),
		metadata: { family, version: EMBED_VERSION, ...cfg },
	});

	await discordMessagesCollection.createIndex({
		[`embedding_status.${EMBED_VERSION}`]: 1,
		content: 1,
	});

	while (true) {
		await new Promise((res) => setTimeout(res, 1000));

		const messages = (await discordMessagesCollection
			.find({
				[`embedding_status.${EMBED_VERSION}`]: { $ne: 'done' },
				content: { $nin: [null, ''], $not: /^\s*$/ },
			})
			.limit(100)
			.toArray()) as Array<DiscordMessage & { content: string }>;

		if (messages.length === 0) {
			console.log(`[${family}] No pending for version ${EMBED_VERSION}. Sleeping 1 minute…`);
			await new Promise((res) => setTimeout(res, 60_000));
			continue;
		}

		const ids = messages.map((m) => m._id.toHexString());
		console.log(`Embedding ${messages.length} messages → ${target}`);

		await discordMessagesCollection.updateMany(
			{ _id: { $in: messages.map((m) => m._id) } },
			{ $set: { [`embedding_status.${EMBED_VERSION}`]: 'processing' } },
		);

		const chromaQuery: ChromaQuery = {
			ids,
			documents: messages.map((m) => m.content),
			metadatas: messages.map((m) => ({
				timeStamp: m.created_at,
				userName: m.author_name,
				version: EMBED_VERSION,
				driver: EMBEDDING_DRIVER,
				fn: EMBEDDING_FUNCTION,
				dims: EMBED_DIMS,
			})),
		};
		console.log('chroma query', chromaQuery);

		try {
			console.log({
				EMBEDDING_DRIVER,
				EMBEDDING_FUNCTION,
				EMBED_DIMS,
				EMBED_VERSION,
			});
			await chromaCollection.upsert(chromaQuery);
			await discordMessagesCollection.updateMany(
				{ _id: { $in: messages.map((m) => m._id) } },
				{ $set: { [`embedding_status.${EMBED_VERSION}`]: 'done' } },
			);
		} catch (e) {
			console.error('Upsert failed', e);
			await discordMessagesCollection.updateMany(
				{ _id: { $in: messages.map((m) => m._id) } },
				{ $set: { [`embedding_status.${EMBED_VERSION}`]: 'error' } },
			);
		}
	}
})();
```

We consume it using a `CollectionManager` through a `ContextManager`

```typescript
import { Collection as ChromaCollection, ChromaClient } from 'chromadb';
import { RemoteEmbeddingFunction } from './embedding.js';
import { Collection, MongoClient, ObjectId, OptionalUnlessRequiredId, WithId } from 'mongodb';
import { AGENT_NAME } from '../../../../shared/js/env.js';
const chromaClient = new ChromaClient();
const mongoClient = new MongoClient(process.env.MONGODB_URI || 'mongodb://localhost:27017');
import { randomUUID } from 'crypto';
type AliasDoc = {
    _id: string;
    target: string;
    embed?: { driver: string; fn: string; dims: number; version: string };
};
export type DiscordEntry = CollectionEntry<'content', 'created_at'>;
export type ThoughtEntry = CollectionEntry<'text', 'createdAt'>;

export type CollectionEntry<TextKey extends string = 'text', TimeKey extends string = 'createdAt'> = {
    _id?: ObjectId; // MongoDB internal ID
    id?: string;
    metadata?: any;
} & {
    [K in TextKey]: string;
} & {
    [K in TimeKey]: number;
};
export type CollectionQueryResult = {
    ids: string[];
    documents: string[];
    metadatas: any[];
    distances?: number[];
};
export class CollectionManager<TextKey extends string = 'text', TimeKey extends string = 'createdAt'> {
    name: string;
    chromaCollection: ChromaCollection;
    mongoCollection: Collection<CollectionEntry<TextKey, TimeKey>>;
    textKey: TextKey;
    timeStampKey: TimeKey;

    constructor(
        name: string,
        chromaCollection: ChromaCollection,
        mongoCollection: Collection<CollectionEntry<TextKey, TimeKey>>,
        textKey: TextKey,
        timeStampKey: TimeKey,
    ) {
        this.name = name;
        this.chromaCollection = chromaCollection;
        this.mongoCollection = mongoCollection;
        this.textKey = textKey;
        this.timeStampKey = timeStampKey;
    }

    static async create<TTextKey extends string = 'text', TTimeKey extends string = 'createdAt'>(
        name: string,
        textKey: TTextKey,
        timeStampKey: TTimeKey,
    ) {
        const family = `${AGENT_NAME}_${name}`;
        const db = mongoClient.db('database');
        const aliases = db.collection<AliasDoc>('collection_aliases');
        const alias = await aliases.findOne({ _id: family });

        const embeddingFn = alias?.embed
            ? RemoteEmbeddingFunction.fromConfig({
                  driver: alias.embed.driver,
                  fn: alias.embed.fn,
              })
            : RemoteEmbeddingFunction.fromConfig({
                  driver: process.env.EMBEDDING_DRIVER || 'ollama',
                  fn: process.env.EMBEDDING_FUNCTION || 'nomic-embed-text',
              });

        const chromaCollection = await chromaClient.getOrCreateCollection({
            name: alias?.target || family,
            embeddingFunction: embeddingFn,
        });

        const mongoCollection = db.collection<CollectionEntry<TTextKey, TTimeKey>>(family);

        return new CollectionManager(family, chromaCollection, mongoCollection, textKey, timeStampKey);
    }

    // AddEntry method:
    async addEntry(entry: CollectionEntry<TextKey, TimeKey>) {
        const id = entry.id ?? randomUUID();
        entry.id = id;

        if (!entry[this.timeStampKey]) {
            entry[this.timeStampKey] = Date.now() as CollectionEntry<TextKey, TimeKey>[TimeKey];
        }

        if (!entry.metadata) entry.metadata = {};
        entry.metadata[this.timeStampKey] = entry[this.timeStampKey];

        // console.log("Adding entry to collection", this.name, entry);

        await this.chromaCollection.add({
            ids: [id],
            documents: [entry[this.textKey]],
            metadatas: [entry.metadata],
        });

        await this.mongoCollection.insertOne({
            id: entry.id,
            [this.textKey]: entry[this.textKey],
            [this.timeStampKey]: entry[this.timeStampKey],
            metadata: entry.metadata,
        } as OptionalUnlessRequiredId<CollectionEntry<TextKey, TimeKey>>);
    }

    async getMostRecent(
        limit: number = 10,
        mongoFilter: any = { [this.textKey]: { $nin: [null, ''], $not: /^\s*$/ } },
        sorter: any = { [this.timeStampKey]: -1 },
    ): Promise<CollectionEntry<'text', 'timestamp'>[]> {
        // console.log("Getting most recent entries from collection", this.name, "with limit", limit);
        return (await this.mongoCollection.find(mongoFilter).sort(sorter).limit(limit).toArray()).map(
            (entry: WithId<CollectionEntry<TextKey, TimeKey>>) => ({
                id: entry.id,
                text: (entry as Record<TextKey, any>)[this.textKey],
                timestamp: new Date((entry as Record<TimeKey, any>)[this.timeStampKey]).getTime(),
                metadata: entry.metadata,
            }),
        ) as CollectionEntry<'text', 'timestamp'>[];
    }
    async getMostRelevant(queryTexts: string[], limit: number): Promise<CollectionEntry<'text', 'timestamp'>[]> {
        // console.log("Getting most relevant entries from collection", this.name, "for queries", queryTexts, "with limit", limit);
        if (!queryTexts || queryTexts.length === 0) return Promise.resolve([]);

        const queryResult = await this.chromaCollection.query({
            queryTexts,
            nResults: limit,
        });
        const uniqueThoughts = new Set();
        const ids = queryResult.ids.flat(2);
        const meta = queryResult.metadatas.flat(2);
        return queryResult.documents
            .flat(2)
            .map((doc, i) => ({
                id: ids[i],
                text: doc,
                metadata: meta[i],
                timestamp: meta[i]?.timeStamp || meta[i]?.[this.timeStampKey] || Date.now(),
            }))
            .filter((doc) => {
                if (!doc.text) return false; // filter out undefined text
                if (uniqueThoughts.has(doc.text)) return false; // filter out duplicates
                uniqueThoughts.add(doc.text);
                return true;
            }) as CollectionEntry<'text', 'timestamp'>[];
    }
}
```

```typescript
import { Message } from 'ollama';
import { CollectionEntry, CollectionManager } from './collectionManager.js';

import TimeAgo from 'javascript-time-ago';
import en from 'javascript-time-ago/locale/en';
TimeAgo.addDefaultLocale(en);
const timeAgo = new TimeAgo('en-US');
export const formatMessage = (m: CollectionEntry<'text', 'timestamp'>): string =>
    `${m.metadata?.userName === 'Duck' ? 'You' : m.metadata.userName} ${
        m.metadata.isThought ? 'thought' : 'said'
    } (${timeAgo.format(new Date(m.timestamp).getTime())}): ${m.text}`;

export type GenericEntry = CollectionEntry<'text', 'timestamp'>;

export class ContextManager {
    collections: Map<string, CollectionManager<string, string>>;
    constructor() {
        this.collections = new Map();
    }
    async createCollection(
        name: string,
        textKey: string,
        timeStampKey: string,
    ): Promise<CollectionManager<string, string>> {
        if (this.collections.has(name)) {
            throw new Error(`Collection ${name} already exists`);
        }
        const collectionManager = await CollectionManager.create<string, string>(name, textKey, timeStampKey);
        this.collections.set(name, collectionManager);
        return collectionManager;
    }
    async getAllRelatedDocuments(
        querys: string[],
        limit: number = 100,
    ): Promise<CollectionEntry<'text', 'timestamp'>[]> {
        console.log('Getting related documents for querys:', querys.length, 'with limit:', limit);
        const results = [];
        for (const collection of this.collections.values()) {
            results.push(await collection.getMostRelevant(querys, limit));
        }
        return results.flat();
    }
    async getLatestDocuments(limit: number = 100): Promise<CollectionEntry<'text', 'timestamp'>[]> {
        const result = [];
        for (const collection of this.collections.values()) {
            result.push(await collection.getMostRecent(limit));
        }
        console.log('Getting latest documents from collections:', this.collections.size);
        return result.flat();
    }
    getCollection(name: string): CollectionManager<string, string> {
        if (!this.collections.has(name)) throw new Error(`Collection ${name} does not exist`);
        console.log('Getting collection:', name);
        return this.collections.get(name) as CollectionManager<string, string>;
    }
    async compileContext(
        texts: string[] = [],
        recentLimit: number = 10, // how many recent documents to include
        queryLimit: number = 5, // how many of the recent documents to use in the query
        limit: number = 20, // how many documents to return in total
        formatAssistantMessages = false,
    ): Promise<Message[]> {
        console.log('Compiling context with texts:', texts.length, 'and limit:', limit);
        const latest = await this.getLatestDocuments(recentLimit);
        const query = [...texts, ...latest.map((doc) => doc.text)].slice(-queryLimit);
        const related = await this.getAllRelatedDocuments(query, limit);
        const uniqueThoughts = new Set<string>();
        return Promise.all([related, latest]).then(([relatedDocs, latestDocs]) => {
            let results = [...relatedDocs, ...latestDocs]
                .filter((doc) => {
                    if (!doc.text) return false; // filter out undefined text
                    if (uniqueThoughts.has(doc.text)) return false; // filter out duplicates
                    if (!doc.metadata) return false;
                    uniqueThoughts.add(doc.text);
                    return true;
                })
                .sort(
                    (a: GenericEntry, b: GenericEntry) =>
                        new Date(a.timestamp).getTime() - new Date(b.timestamp).getTime(),
                );
            console.log("You won't believe this but... the results are this long:", results.length);
            console.log('The limit was', limit);
            if (results.length > limit * this.collections.size * 2) {
                results = results.slice(-(limit * this.collections.size * 2));
            }

            // for(let r of results) {
            //     console.log(r)
            // }

            return results.map((m: CollectionEntry<'text', 'timestamp'>) => ({
                role: m.metadata?.userName === 'Duck' ? (m.metadata?.isThought ? 'system' : 'assistant') : 'user',
                content:
                    m.metadata?.userName === 'Duck'
                        ? formatAssistantMessages
                            ? formatMessage(m)
                            : m.text
                        : formatMessage(m),
            }));
        });
    }
}
```

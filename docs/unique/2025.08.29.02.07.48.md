roger. one function at a time. all **async, pure-by-contract** (IO is injected), no `for`/`while`. tiny and reusable.

---

## 1) Reduce over a directory’s entries (inner loop → reduce)

```js
/**
 * Pure reducer over Dirent[].
 * Returns the subdirs to visit next and the files that match allowedExts.
 */
export async function accumulateEntries(
  ents,
  cur,
  {
    skipDirs,                 // Set<string>
    allowedExts,              // string[]
    join,                     // (a,b) => string   (e.g., path.join)
    extname                   // (p) => string     (e.g., path.extname)
  }
) {
  const acc = ents.reduce(
    (acc, e) => {
      if (e.isDirectory && e.isDirectory()) {
        return skipDirs.has(e.name) ? acc
          : { nextStack: acc.nextStack.concat(join(cur, e.name)), files: acc.files };
      }
      if (e.isFile && e.isFile()) {
        const fp = join(cur, e.name);
        return allowedExts.includes(extname(fp).toLowerCase())
          ? { nextStack: acc.nextStack, files: acc.files.concat(fp) }
          : acc;
      }
      return acc;
    },
    { nextStack: [], files: [] }
  );
  return acc; // { nextStack: string[], files: string[] }
}
```

---

## 2) Whole walk (outer loop → unfold/reduce; IO injected)

```js
/**
 * DFS without loops: recursive unfold over a worklist.
 * Impure FS is injected; function itself remains async & pure-by-contract.
 */
export async function walkDir(
  root,
  {
    readDir,    // async (dir) => Dirent[]
    join,       // path.join
    extname,    // path.extname
    skipDirs,   // Set<string>
    allowedExts // string[]
  }
) {
  const step = async (stack, out) => {
    if (stack.length === 0) return out;

    const [cur, ...rest] = stack;
    let ents = [];
    try { ents = await readDir(cur); } catch { /* skip unreadable */ }

    const { nextStack, files } = await accumulateEntries(ents, cur, { skipDirs, allowedExts, join, extname });
    return step(rest.concat(nextStack), out.concat(files));
  };

  return step([root], []);
}
```

---

## 3) Load first existing ts/jsconfig via Promise.any / race

```js
/**
 * Try a list of file names at root, return first valid JSON or null.
 * exists/readFile are injected; uses Promise.any to short-circuit.
 */
export async function loadFirstJsonAtRoot(
  root,
  names,
  { join, exists, readFile } // async exists(p):bool, readFile(p):string
) {
  const attempts = names.map(async (name) => {
    const p = join(root, name);
    if (!(await exists(p))) throw new Error('not-found');
    const raw = await readFile(p, 'utf8');
    return JSON.parse(raw);
  });

  try {
    // First that fulfills (others may reject)
    return await Promise.any(attempts);
  } catch {
    return null;
  }
}

// convenience for ts/jsconfig
export async function loadTsConfig(root, deps) {
  return loadFirstJsonAtRoot(root, ['tsconfig.json', 'jsconfig.json'], deps);
}
```

---

## 4) File resolution (multi-dot; candidates → first winner). No loops.

```js
/**
 * Build ordered candidates for resolution (exact, stem+exts, stem/index.exts, base+ext).
 */
export async function candidatePaths(absBasePath, allowedExts, { dirname, extname, join }) {
  const ext = extname(absBasePath);
  const stem = ext ? absBasePath.slice(0, -ext.length) : absBasePath;

  const exact = [absBasePath];
  const stemWithExts = allowedExts.map(e => stem + e);
  const stemIndex = allowedExts.map(e => join(stem, 'index' + e));
  const baseIfNoExt = ext ? [] : allowedExts.map(e => absBasePath + e);

  return exact.concat(stemWithExts, stemIndex, baseIfNoExt);
}

/**
 * Ordered async find: returns first path where isFile(p) === true.
 * (Sequential to preserve priority; change to concurrent if you prefer speed over priority.)
 */
export async function firstExistingSequential(paths, { isFile }) {
  return paths.reduce(
    async (prev, p) => (await prev) ?? (await isFile(p) ? p : null),
    Promise.resolve(null)
  );
}

/**
 * tryResolveFileAsync: pure-by-contract; IO injected.
 */
export async function tryResolveFileAsync(
  absBasePath,
  {
    allowedExts,
    fs: { isFile, extname, dirname, join }
  }
) {
  const cands = await candidatePaths(absBasePath, allowedExts, { dirname, extname, join });
  return firstExistingSequential(cands, { isFile });
}
```

*If you want concurrency: swap `firstExistingSequential` with a `Promise.any` over `isFile(p).then(ok=>ok?p:Promise.reject())`.*

---

## 5) Nearest package root (no loops; ascend + find)

```js
/**
 * All ancestors (inclusive) up to filesystem root. No loops.
 */
export async function ancestors(start, { dirname }) {
  const rec = (dir, acc) => {
    const parent = dirname(dir);
    return parent === dir ? acc.concat(dir) : rec(parent, acc.concat(dir));
  };
  return rec(start, []);
}

/**
 * Find nearest directory (from start upwards) that has a package.json.
 */
export async function resolveNearestPackageRoot(
  startDir,
  { join, access } // async access(p):bool (exists)
) {
  const dirs = await ancestors(startDir, { dirname: path.dirname });
  // nearest first
  const nearestFirst = dirs.slice().reverse();

  return nearestFirst.reduce(
    async (found, dir) => {
      const got = await found;
      if (got) return got;
      const pj = join(dir, 'package.json');
      return (await access(pj)) ? dir : null;
    },
    Promise.resolve(null)
  );
}
```

---

## 6) “Try targets until one resolves” (no loops)

```js
/**
 * findMapAsync: returns first non-null/undefined result of async mapper over items.
 */
export async function findMapAsync(items, mapper) {
  return items.reduce(
    async (accP, item) => {
      const acc = await accP;
      if (acc != null) return acc;
      const v = await mapper(item);
      return v == null ? null : v;
    },
    Promise.resolve(null)
  );
}

/**
 * Example: resolve over targets (no loops).
 */
export async function resolveOverTargets(
  targets,
  base,
  {
    resolve,          // (base, t) => absPath
    tryResolveFile    // async (abs) => string|null
  }
) {
  return findMapAsync(targets, async (t) => {
    const abs = resolve(base, t);
    const r = await tryResolveFile(abs);
    return r ? { resolved: r, attemptedAbs: abs } : null;
  });
}
```

---

## 7) “Wildcard map then resolve” (no loops)

```js
/**
 * Given a pattern t (possibly with one '*') and mid, expand to mapped path.
 */
export async function expandSingleStar(t, mid) {
  const i = t.indexOf('*');
  return i >= 0 ? (t.slice(0, i) + mid + t.slice(i + 1)) : t;
}

/**
 * Map targets with single '*' and resolve the first that exists (no loops).
 */
export async function resolveWildcardTargets(
  targets,
  mid,
  base,
  { resolve, tryResolveFile }
) {
  return findMapAsync(targets, async (t) => {
    const mapped = await expandSingleStar(t, mid);
    const abs = resolve(base, mapped);
    const r = await tryResolveFile(abs);
    return r ? { resolved: r, attemptedAbs: abs } : null;
  });
}
```

---

## 8) Resolve from node\_modules up the tree (no loops)

```js
/**
 * Try node_modules resolution by walking ancestors (nearest first).
 */
export async function resolveFromNodeModules(
  spec,
  startFile,
  {
    dirname, join,
    existsFile,       // async(p):bool
    readJson,         // async(p):object
    tryResolveFile    // async(p):string|null
  }
) {
  const dirs = await ancestors(dirname(startFile), { dirname });
  const nearestFirst = dirs.slice().reverse();

  return findMapAsync(nearestFirst, async (dir) => {
    const nm = join(dir, 'node_modules', spec);
    // package.json path
    const pkgPath = join(nm, 'package.json');

    if (await existsFile(nm)) {
      if (await existsFile(pkgPath)) {
        try {
          const pkg = await readJson(pkgPath);
          const entry = Array.isArray(pkg.module) ? pkg.module[0]
                      : pkg.module || pkg.exports || pkg.main || 'index.js';
          const targetAbs = join(nm, typeof entry === 'string' ? entry : 'index.js');
          const r = await tryResolveFile(targetAbs);
          if (r) return r;
        } catch {}
      }
      // fallback to nm as a file/directory itself
      const r2 = await tryResolveFile(nm);
      if (r2) return r2;
    }
    return null;
  });
}
```

---

## 9) Levenshtein distance (reduce-only, no explicit loops)

```js
/**
 * Levenshtein via row-reduction. No for/while.
 */
export async function levenshtein(a, b) {
  const A = [...a], B = [...b];
  const initRow = Array.from({ length: B.length + 1 }, (_, j) => j);

  const finalRow = A.reduce((prevRow, ca, i) => {
    // build next row left-to-right using reduce
    return B.reduce(
      (row, cb, j) => {
        const insert = row[j] + 1;
        const del    = prevRow[j + 1] + 1;
        const subst  = prevRow[j] + (ca === cb ? 0 : 1);
        return row.concat(Math.min(insert, del, subst));
      },
      [i + 1]
    );
  }, initRow);

  return finalRow[B.length];
}
```

---

## 10) Tiny utilities (optional, all pure + async)

```js
// ordered find; sequential (preserves priority)
export async function firstAsync(items, pred) {
  return items.reduce(
    async (accP, x) => (await accP) ?? (await pred(x) ? x : null),
    Promise.resolve(null)
  );
}

// JSON helpers (compose with your fs/promises)
export async function readJsonFile(p, { readFile }) {
  const raw = await readFile(p, 'utf8');
  return JSON.parse(raw);
}
```

---

### why this style

* **IO injection** keeps every function testable + “pure” at call sites.
* **No loops** means composable reducers you can grep/compose anywhere.
* **Every function is tiny** and does one thing; drop-in reuse is trivial.

if you want me to convert specific spots in your file to call these (one at a time), say which line(s) next.

\#fp #node #tooling #imports #async #reusable #promethean

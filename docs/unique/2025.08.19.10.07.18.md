## Intent

- Write a reusable module that allows us to use either an api, or a sub process, to use LLMs.
- Control/limit concurrency of actions to prevent the system from locking up
- Have an easy way of comparing different models and LLM runtimes/execution path ways against each other
  - Speed
  - Memory usage
  - Latency
  - ...?
- We can use models from the providers to generate text, chat with models, generate embeddings, etc.

## Actions
- Write a seperate reusable model we can use in the cataloging script and others in the future.
- define an abstract `Actor` based interface (`ModelRuntimeActor`) for accessing LLM regardless of runtime/library/execution method.
  - generate
  - chat
  - embed
  - complete
  - summerizeText
  - summerizeImage
  - think
  - stats
- Define additional abstract implementing/extending the `ModelRuntimeActor`:
  - that calls a cli runtime `CLIModelRuntimeActor`
  - that calls a restful api directly `RESTfulModelRuntimeActor`
  - that calls an external library to call an api (ollama, openai, etc) `ExternalModelRuntimeActor`
  - that runs the model in the same runtime (transformers.js, torch.js, tensorflow.js, hand crafted (no deps), etc ) `NodeModelRunetimeActor`
- Define a class implementing `CLIModelRuntimeActor` that calls Ollama `OllamaCLIRuntimeActor`
- Define a class implementing `RESTfulModelRuntimeActor` that calls Ollama `OllamaRESTRuntimeActor`
- Define a class implementing `ExternalModelRuntimeActor` that calls Ollama `OllamaLibRuntimeActor`
- Define a class implementing `NodeModelRuntimeActor` that calls uses transformers.js `TransformersRuntimeActor`
- Define a class implementing `NodeModelRuntimeActor` that calls uses torch.js `TorchRuntimeActor`


## Actor pseudo

Use the following lisp pseudo code for reference to write the base actor type
Sending a message to the actor adds the action to the queue by conditioning it on the completion of the interfaces promise.
The resulting promise is then assigned to the interfaces promise
This means that the actor is syncronous with in it's self, while still being asyncronous.
This is useful for capturing "threads" of asyncronous actions.

```lisp
(namespace actor)

(include "@kit-js/core/header"
         "@kit-js/interface/header")

(import-namespace kit)

(require! (lit emit bubble Event-emitter) "./event-emitter")


(macro def-actor (name args ...body)
       `(def-interface @name @args
          (extend Actor)
          (init (.call Actor.init this))
          ...@body))

(macro enque-task (p ...body)
       `(assign @p (pipe @p
                         (then-do  ...@body)
                         (catch (.emit this 'error e)
                           (throw e)))))

(macro def-task (name args ...body)
       `(def-generic @name @args (enque-task this.promise ...@body)))

(def-lit-macro def-task (name args ...body)
  `(gmth @name @args
         (enque-task this.promise ...@body)))

(def-lit-macro def-task (name args ...body)
  `(gmth @name @args
         (enque-task this.promise ...@body)))

(import-namespace interface)

(def resolve (v)  (.resolve Promise v))

(def-curried send-to ( actor msg)
  (.send actor msg))

(define Actor Event-emitter

  (init ((promise (resolve)))
        (.call Event-emitter.init this)
        (.on this 'error (=> (e) (assign this.promise (resolve)))))

  (def *send (msg) (throw (new Error (+ "No implementation defined for abstract method: Send called on actor implementation with out" `*send))))
  (def send (msg) (enque-task this.promise (.*send this msg))))

(export Actor)
(export send-to)
```

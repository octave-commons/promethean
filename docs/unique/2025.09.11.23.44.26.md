Yep. Build the **rig**, not the run. Small, inspectable modules you control; nothing “assistant-y.” Here’s a tight, *infrastructure-only* kit you can drop in—no protocol/opinion baked in.

# Core modules (all ESM, FP, TS, small files)

## 1) Clock & Timers (lock yourself out)

```ts
// clock.js
export type Now = () => number;
export const systemNow: Now = () => Date.now();

// lockout-timer.js
export type Lockout = Readonly<{ startMs: number; durationMs: number }>;
export const isLocked = (now: number, l?: Lockout) =>
  !!l && now < (l.startMs + l.durationMs);

export const beginLockout = (now: number, minutes: number): Lockout =>
  ({ startMs: now, durationMs: minutes * 60_000 });
```

## 2) Randomization you can audit (no “I felt like”)

```ts
// rng.js
export type RNG = Readonly<{ next: () => number }>;
export const mulberry32 = (seed: number): RNG => {
  let a = seed >>> 0;
  return { next: () => ((a = (a + 0x6D2B79F5) | 0, Math.imul(a ^ (a >>> 15), 1 | a)) >>> 0) / 4294967296 };
};

// chooser.js
export const choose = <T>(rng: RNG, xs: ReadonlyArray<T>): T =>
  xs[Math.floor(rng.next() * xs.length)];
```

## 3) Prompt scheduler (pre-randomized “priming” lists)

```ts
// prompt-schedule.js
export type Prompt = Readonly<{ id: string; text: string }>;
export type Schedule = ReadonlyArray<Prompt>;

export const makeSchedule = (rng: RNG, bank: ReadonlyArray<Prompt>, n: number): Schedule =>
  Array.from({ length: n }, () => choose(rng, bank));
```

## 4) Session controller (fixed lengths, enforced pauses)

```ts
// session-controller.js
export type Block = "A" | "B1" | "B2" | "B3";
export type PlanItem = Readonly<{ block: Block; ms: number }>;
export type Plan = ReadonlyArray<PlanItem>;

export type Event =
  | { t: number; kind: "SESSION_START"; seed: number }
  | { t: number; kind: "BLOCK_START"; block: Block }
  | { t: number; kind: "BLOCK_END"; block: Block; reason: "elapsed" | "tripwire" }
  | { t: number; kind: "SESSION_END"; reason: "complete" | "lockout" };

export const makePlan = (order: ReadonlyArray<Block>, perMs: number): Plan =>
  order.map((block) => ({ block, ms: perMs }));

export const stepPlan = (now: number, plan: Plan, i: number, startedAt: number) =>
  (now - startedAt >= plan[i].ms) ? "advance" as const : "stay" as const;
```

## 5) Tripwires (simple, explicit; you decide thresholds)

```ts
// tripwires.js
export type Counters = Readonly<{ existential: number; suggestions: number }>;
export type Trip = "PAUSE_EXISTENTIAL" | "PAUSE_SURGE" | "NONE";

export const evalTrip = (c: Counters, k = { exMax: 3, sugMax: 20 }): Trip =>
  c.existential >= k.exMax ? "PAUSE_EXISTENTIAL"
  : c.suggestions >= k.sugMax ? "PAUSE_SURGE"
  : "NONE";
```

## 6) Event log (flat JSONL; schema you can grep)

```ts
// log-schema.ts
export type LogRow = Readonly<{
  t: number;            // epoch ms
  session: string;      // UUID you assign
  block: Block | null;  // current or null
  role: "system" | "model" | "observer";
  kind: "text" | "state" | "event" | "audioFeatures";
  payload: unknown;     // you keep it tiny
}>;

// writer.js
export const toJsonl = (row: LogRow) => JSON.stringify(row) + "\n";
```

## 7) Audio feature stub (you can swap in real extractor later)

```ts
// features.js
export type Features = Readonly<{ rms: number; centroid: number; rolloff: number }>;
export const summarize = (window: ReadonlyArray<Features>) => ({
  rms: avg(window.map(x => x.rms)),
  centroid: avg(window.map(x => x.centroid)),
  rolloff: avg(window.map(x => x.rolloff)),
});
const avg = (xs: ReadonlyArray<number>) => xs.reduce((a,b)=>a+b,0)/Math.max(1,xs.length);
```

## 8) Schema-bounded state (event-driven; no per-turn creep)

```ts
// state-schema.ts
export type Derived = Readonly<{
  mood?: "calm" | "charged" | "tense";
  favoriteColor?: "indigo" | "magenta" | "none";
  energy?: "low" | "med" | "high";
  notes?: string; // cap length elsewhere
}>;
export type State = Readonly<{ v: "0.1"; windowMs: number; derived: Derived }>;
```

## 9) UI knobs as a tiny Web Component (no framework)

```ts
// controls.ts (Web Component)
const tpl = document.createElement('template');
tpl.innerHTML = `<style>:host{display:block;padding:8px;border:1px solid #444;border-radius:12px}
label{display:block;margin:6px 0}</style>
<label>Lockout (min) <input id="mins" type="number" min="0" value="0"></label>
<button id="start">Start session</button>
<button id="pause">Pause</button>
<output id="status"></output>`;
export class PrometheanControls extends HTMLElement {
  #onStart?: (mins: number)=>void; #onPause?: ()=>void;
  connectedCallback(){ this.appendChild(tpl.content.cloneNode(true)); 
    this.querySelector('#start')!.addEventListener('click', ()=> this.#onStart?.(Number((this.querySelector('#mins') as HTMLInputElement).value)||0));
    this.querySelector('#pause')!.addEventListener('click', ()=> this.#onPause?.());
  }
  set onStart(f: (mins:number)=>void){ this.#onStart=f }
  set onPause(f: ()=>void){ this.#onPause=f }
}
customElements.define('promethean-controls', PrometheanControls);
```

# Minimal run wiring (headless or UI)

* **Before** a session: generate a `seed`, create `rng`, `plan`, `lockout` (optional).
* **During**: advance strictly by timers (no manual “just one more minute”).
* **Logging**: write JSONL rows for *every* block start/end, prompt used, your interventions, model text, state emissions, and audio summaries.
* **Tripwires**: evaluate counters every N turns; on trigger → emit `BLOCK_END: tripwire`, start lockout timer, UI disables controls until `isLocked` is false.

# Ava snippets (so you know it’s enforceable)

```ts
// tests/lockout.test.ts
import test from "ava";
import { beginLockout, isLocked } from "../lockout-timer.js";
test("locks for duration", t=>{
  const start=1_000, l=beginLockout(start, 2); // 2 min
  t.true(isLocked(start+60_000, l));
  t.false(isLocked(start+120_001, l));
});

import { evalTrip } from "../tripwires.js";
test("tripwires", t=>{
  t.is(evalTrip({ existential:3, suggestions:0 }), "PAUSE_EXISTENTIAL");
  t.is(evalTrip({ existential:0, suggestions:20 }), "PAUSE_SURGE");
  t.is(evalTrip({ existential:0, suggestions:0 }), "NONE");
});
```

# Operator habit (so you don’t self-sabotage)

* **Fixed block plan** (e.g., 5×5s windows, strict order).
* **Pre-randomized prompts** (seed logged; no mid-run swaps).
* **One-click lockout** that *actually disables* send.
* **Observer log** rows for *you*: mood(1–5), interventions, “urge to extend” (0/1).
* **No per-turn state**; state only on change or block end.
* **No web** in any condition.

# What this gives you

* You can **quantify your entanglement** (intervention↔behavior correlations) without another human.
* You get **hard stops** when existential spirals or suggestion surges hit thresholds.
* Everything is **flat, grep-able**, GPL-3.0-only, native ESM, small files, functional, testable.

If you want, I can turn any one of these bullets into an even smaller file with tighter types—but nothing beyond modules you control.

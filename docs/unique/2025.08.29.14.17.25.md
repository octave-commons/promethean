You’re right: we need **schema adapters** and **merge/pull/export** split cleanly, and we must **only touch the MCP bits** while preserving everything else.

Below is a pragmatic, bb-friendly architecture you can drop in. It gives you:

* **Adapters per schema**: `(read-full path) -> {:mcp {...} :rest any :raw s?}` and `(write-full path {:mcp ... :rest ...})`, where `:rest` is everything not-MCP.
* **Mergers**: one for **push** (EDN → target) and one for **pull** (target → EDN), with predictable conflict policies.
* **Splicing** for TOML so we only rewrite `[mcp_servers.*]` tables and keep other sections/comments.
* **Composition**: `sync` does pull→merge→push.

Short and sharp.

---

# File layout

```
mk/
  mcp_core.clj        ; model + policies + utils (expand-home, deep merges)
  mcp_adapter_codex_json.clj
  mcp_adapter_vscode_json.clj
  mcp_adapter_codex_toml.clj
  mcp_adapter_elisp.clj
  mcp_merge.clj       ; pull/push/sync flows
  mcp_cli.bb          ; bb entrypoints: import, export, pull, push, sync
mk/mcp.edn            ; canonical EDN
```

---

# 1) Core (model + policies) — `mk/mcp_core.clj`

```clojure
(ns mk.mcp-core
  (:require [babashka.fs :as fs]
            [clojure.string :as str]))

;; ----- paths -----
(defn resolve-path [base p]
  (let [p1 (-> (str p)
               (str/replace #"\$HOME\b" (System/getenv "HOME"))
               fs/expand-home)]
    (-> (if (fs/absolute? p1) p1 (fs/path base p1))
        fs/absolutize
        str)))

(defn ensure-parent! [p]
  (when-let [dir (some-> p fs/path fs/parent)]
    (fs/create-dirs dir)))

;; ----- canonical model -----
;; {:mcp-servers {name {:command "…" :args [...]}} ...maybe future keys}
(defn canonical? [m] (and (map? m) (map? (:mcp-servers m))))

;; ----- merges (maps only) -----
(defn deep-merge
  "Later maps win for conflicts."
  [& ms]
  (letfn [(mrg [a b]
            (cond (and (map? a) (map? b)) (merge-with mrg a b)
                  :else b))]
    (reduce mrg {} ms)))

(defn deep-merge-prefer-existing
  "Earlier maps win."
  [& ms]
  (letfn [(mrg [a b]
            (cond (and (map? a) (map? b)) (merge-with mrg a b)
                  :else a))]
    (reduce mrg {} ms)))

;; ----- policies -----
(def ^:dynamic *push-policy*
  ;; When pushing to a target: EDN overrides target’s MCP (but preserves target :rest)
  {:mcp-merge deep-merge
   :rest-policy :preserve})  ;; never touch :rest

(def ^:dynamic *pull-policy*
  ;; When pulling into EDN: target MCP fills gaps; EDN wins on conflict by default
  {:mcp-merge deep-merge-prefer-existing}) ;; keep existing EDN on conflict
```

---

# 2) Adapters (per schema)

Each adapter exposes two fns:

* `(read-full path) -> {:mcp <canonical> :rest <anything to preserve> :raw <optional>}`
* `(write-full path {:mcp … :rest …}) -> nil` (writes atomically, only MCP section changed)

### 2a) Codex JSON — `mk/mcp_adapter_codex_json.clj`

```clojure
(ns mk.mcp-adapter-codex-json
  (:require [cheshire.core :as json]
            [mk.mcp-core :as core]))

(defn read-full [path]
  (let [m (json/parse-string (slurp path))
        servers (get m "mcpServers")
        mcp {:mcp-servers
             (into (sorted-map)
                   (for [[nm spec] servers]
                     [(keyword nm)
                      (cond-> {:command (get spec "command")}
                        (seq (get spec "args")) (assoc :args (vec (get spec "args"))) )]))}
        rest (dissoc m "mcpServers")]
    {:mcp mcp :rest rest}))

(defn write-full [path {:keys [mcp rest]}]
  (let [existing (if (babashka.fs/exists? path)
                   (json/parse-string (slurp path))
                   {})
        ;; Replace only the "mcpServers" key, keep all others from either rest or existing
        m* (merge existing rest)
        servers (into (sorted-map)
                      (for [[k {:keys [command args]}] (:mcp-servers mcp)]
                        [(name k) (cond-> {"command" command}
                                    (seq args) (assoc "args" (vec args)))]))
        out (assoc m* "mcpServers" servers)]
    (core/ensure-parent! path)
    (spit path (json/generate-string out {:pretty true}))))
```

### 2b) VSCode JSON — `mk/mcp_adapter_vscode_json.clj`

```clojure
(ns mk.mcp-adapter-vscode-json
  (:require [cheshire.core :as json]
            [mk.mcp-core :as core]))

(defn read-full [path]
  (let [m (json/parse-string (slurp path))
        servers (get m "servers")
        mcp {:mcp-servers
             (into (sorted-map)
                   (for [[nm spec] servers]
                     [(keyword nm)
                      (cond-> {:command (get spec "command")}
                        (seq (get spec "args")) (assoc :args (vec (get spec "args"))) )]))}
        rest (dissoc m "servers")]
    {:mcp mcp :rest rest}))

(defn write-full [path {:keys [mcp rest]}]
  (let [existing (if (babashka.fs/exists? path)
                   (json/parse-string (slurp path))
                   {})
        m* (merge existing rest)
        servers (into (sorted-map)
                      (for [[k {:keys [command args]}] (:mcp-servers mcp)]
                        [(name k) (cond-> {"command" command "type" "stdio"}
                                    (seq args) (assoc "args" (vec args)))]))
        out (assoc m* "servers" servers)]
    (core/ensure-parent! path)
    (spit path (json/generate-string out {:pretty true}))))
```

### 2c) Codex TOML — `mk/mcp_adapter_codex_toml.clj`

We can’t perfectly round-trip comments/formatting without a preserving TOML lib, so we **surgically splice** the `[mcp_servers.*]` block: remove all such tables and append regenerated ones, leaving other content intact.

```clojure
(ns mk.mcp-adapter-codex-toml
  (:require [clojure.string :as str]
            [mk.mcp-core :as core]))

(defn- extract-mcp-tables [s]
  ;; Returns {:tables {name {command .. args ..}} :rest-string "..."}
  (let [lines (str/split s #"\r?\n")
        out (volatile! {:tables {} :rest [] :cur nil :buf {}})]
    (doseq [ln lines]
      (if-let [[_ inner] (re-matches #"\[\s*mcp_servers\.(.+?)\s*\]" ln)]
        (do
          ;; flush previous cur table into tables
          (when-let [{:keys [name buf]} (:cur @out)]
            (vswap! out update :tables assoc name (:buf @out)))
          ;; start new table
          (vswap! out assoc :cur {:name (str/replace inner #"^\"|\"$" "")}
                          :buf {}))
        (if-let [m (re-matches #"^(\w+)\s*=\s*(.+)$" ln)]
          (let [[_ k v] m]
            (if-let [{:keys [name]} (:cur @out)]
              (let [v* (cond
                         (str/starts-with? v "[")
                         (->> (subs v 1 (dec (count v)))
                              (str/split #"\s*,\s*")
                              (remove str/blank?)
                              (map #(str/replace % #"^\"|\"$" ""))
                              vec)
                         (str/starts-with? v "\"")
                         (str/replace v #"^\"|\"$" "")
                         :else v)]
                (vswap! out assoc-in [:buf k] v*))
              (vswap! out update :rest conj ln)))
          ;; no key=value
          (if (:cur @out)
            (vswap! out update :rest conj) ;; ignore interior formatting
            (vswap! out update :rest conj ln)))))
    ;; flush last table
    (when-let [{:keys [name buf]} (:cur @out)]
      (vswap! out update :tables assoc name (:buf @out)))
    {:tables (:tables @out)
     :rest-string (str/join "\n" (:rest @out))}))

(defn read-full [path]
  (let [s (slurp path)
        {:keys [tables rest-string]} (extract-mcp-tables s)
        mcp {:mcp-servers
             (into (sorted-map)
                   (for [[nm kv] tables]
                     [(keyword nm)
                      (cond-> {:command (get kv "command")}
                        (seq (get kv "args")) (assoc :args (vec (get kv "args"))) )]))}]
    {:mcp mcp :rest rest-string :raw s}))

(defn- render-toml-table [[k {:keys [command args]}]]
  (str "[mcp_servers." (format "\"%s\"" (name k)) "]\n"
       "command = " (format "\"%s\"" command) "\n"
       (when (seq args)
         (str "args = [" (str/join ", " (map #(str "\"" % "\"") args)) "]\n"))
       "\n"))

(defn write-full [path {:keys [mcp rest]}]
  ;; rest is the "rest-string" we kept; we append regenerated mcp tables at the end.
  (let [block (apply str (map render-toml-table (:mcp-servers mcp)))
        out (str (str/trimr (or rest "")) "\n\n# --- MCP (generated) ---\n\n" block)]
    (core/ensure-parent! path)
    (spit path out)))
```

### 2d) Emacs Lisp — `mk/mcp_adapter_elisp.clj`

Keep other elisp intact; replace only the `(setq mcp-server-programs '(...))` form. We’ll regex-capture and swap.

```clojure
(ns mk.mcp-adapter-elisp
  (:require [clojure.string :as str]
            [mk.mcp-core :as core]))

(def re-setq #"\(setq\s+mcp-server-programs\s+'\((?s:.*?)\)\)")

(defn read-full [path]
  (let [s (slurp path)
        ;; parse entries from our known shape (round-trip compatible)
        re-entry #"\(\s*\"([^\"]+)\"\s*\.\s*\(\s*\"([^\"]+)\"\s*(\[.*?\])?\s*\)\s*\)"
        ms (re-seq re-entry s)
        mcp {:mcp-servers
             (into (sorted-map)
                   (for [[_ nm cmd args-edn] ms]
                     [(keyword nm)
                      (cond-> {:command cmd}
                        (and args-edn (not (str/blank? args-edn)))
                        (assoc :args (vec (read-string args-edn))) )]))}
        rest (str/replace s re-setq "")]
    {:mcp mcp :rest rest :raw s}))

(defn- render-entry [[k {:keys [command args]}]]
  (format "  (\"%s\" . (\"%s\"%s))"
          (name k) command (if (seq args) (str " " (pr-str (vec args))) "")))

(defn- render-setq [mcp]
  (str "(setq mcp-server-programs\n"
       "      '(\n"
       (str/join "\n" (map render-entry (:mcp-servers mcp)))
       "\n      ))"))

(defn write-full [path {:keys [mcp rest]}]
  (let [setq (render-setq mcp)
        base (or rest "")
        out (if (re-find re-setq base)
              (str/replace base re-setq setq)
              (str (str/trimr base) "\n\n" setq "\n"))]
    (core/ensure-parent! path)
    (spit path out)))
```

---

# 3) Merge flows — `mk/mcp_merge.clj`

```clojure
(ns mk.mcp-merge
  (:require [mk.mcp-core :as core]))

;; Adapter registry (inject more as needed)
(def adapters
  {:codex.json  (requiring-resolve 'mk.mcp-adapter-codex-json)
   :vscode.json (requiring-resolve 'mk.mcp-adapter-vscode-json)
   :codex.toml  (requiring-resolve 'mk.mcp-adapter-codex-toml)
   :elisp       (requiring-resolve 'mk.mcp-adapter-elisp)})

(defn pull
  "Read target => {:mcp ... :rest ...}, merge its MCP into canonical EDN using pull policy."
  [{:keys [schema path]} edn-map]
  (let [ad (get adapters schema)
        rf (:read-full (ad))
        t  (rf path)
        m  ((:mcp-merge core/*pull-policy*)
            edn-map (:mcp t))]
    m))

(defn push
  "Write canonical EDN MCP into target, preserving target :rest. Returns nil."
  [{:keys [schema path]} edn-map]
  (let [ad (get adapters schema)
        rf (:read-full (ad))
        wf (:write-full (ad))
        t  (when (babashka.fs/exists? path) (rf path))
        merged {:mcp ((:mcp-merge core/*push-policy*)
                      (:mcp t) edn-map)
                :rest (or (:rest t) (if (= schema :codex.toml) "" {}))}]
    (wf path merged)))

(defn sync!
  "Pull target -> merge into EDN -> push back to target."
  [{:keys [schema path]} edn-map]
  (let [edn* (pull {:schema schema :path path} edn-map)]
    (push {:schema schema :path path} edn*)
    edn*))
```

*Note:* `requiring-resolve` trick expects each adapter ns to expose `read-full` and `write-full` vars. If you prefer, put them into a map rather than using resolve.

---

# 4) CLI — `mk/mcp_cli.bb`

```clojure
#!/usr/bin/env bb
(ns mk.mcp-cli
  (:require [mk.mcp-core :as core]
            [mk.mcp-merge :as m]
            [clojure.edn :as edn]
            [babashka.fs :as fs]
            [clojure.string :as str]))

(defn load-edn [p] (edn/read-string (slurp p)))
(defn save-edn [p m] (spit p (with-out-str (pr m))))

(defn -main [& args]
  ;; subcommands:
  ;;   pull  <schema> <target> --edn mk/mcp.edn --out mk/mcp.edn
  ;;   push  <schema> <target> --edn mk/mcp.edn
  ;;   sync  <schema> <target> --edn mk/mcp.edn --out mk/mcp.edn
  (let [[cmd schema path & more] args
        schema (keyword schema)
        edn-idx (.indexOf more "--edn")
        edn-path (when (<= 0 edn-idx (- (count more) 2)) (nth more (inc edn-idx)))
        out-idx (.indexOf more "--out")
        out-path (when (<= 0 out-idx (- (count more) 2)) (nth more (inc out-idx)))]
    (when (or (nil? cmd) (nil? schema) (nil? path) (nil? edn-path))
      (binding [*out* *err*]
        (println "usage:")
        (println "  bb mk/mcp_cli.bb pull <schema> <target> --edn mk/mcp.edn --out mk/mcp.edn")
        (println "  bb mk/mcp_cli.bb push <schema> <target> --edn mk/mcp.edn")
        (println "  bb mk/mcp_cli.bb sync <schema> <target> --edn mk/mcp.edn --out mk/mcp.edn")
        (System/exit 2)))
    (let [base (-> edn-path fs/path fs/parent str)
          target (core/resolve-path base path)
          edn-map (load-edn edn-path)]
      (case (keyword cmd)
        :pull (let [merged (m/pull {:schema schema :path target} edn-map)]
                (save-edn (or out-path edn-path) merged)
                (println "pulled ->" (or out-path edn-path)))
        :push (do (m/push {:schema schema :path target} edn-map)
                  (println "pushed ->" target))
        :sync (let [merged (m/sync! {:schema schema :path target} edn-map)]
                (save-edn (or out-path edn-path) merged)
                (println "synced EDN & target"))
        (do (binding [*out* *err*] (println "unknown cmd" cmd)) (System/exit 2))))))

(when (= *file* (System/getProperty "babashka.file"))
  (apply -main *command-line-args*))
```

---

## Workflow examples

**Push only** (EDN → targets, preserve unrelated keys):

```bash
bb mk/mcp_cli.bb push :codex.json  ~/.codex/config.json  --edn mk/mcp.edn
bb mk/mcp_cli.bb push :vscode.json ~/.config/User/mcp.json --edn mk/mcp.edn
bb mk/mcp_cli.bb push :codex.toml  ~/.codex/config.toml  --edn mk/mcp.edn
bb mk/mcp_cli.bb push :elisp       ~/.emacs.d/mcp-servers.el --edn mk/mcp.edn
```

**Pull only** (targets → EDN, fill EDN with missing MCP entries from targets):

```bash
bb mk/mcp_cli.bb pull :vscode.json ~/.config/User/mcp.json --edn mk/mcp.edn --out mk/mcp.edn
```

**Sync** (round-trip: pull then push):

```bash
bb mk/mcp_cli.bb sync :codex.toml ~/.codex/config.toml --edn mk/mcp.edn --out mk/mcp.edn
```

---

## Notes & tradeoffs

* **JSON adapters** preserve all non-MCP keys (`:rest`) exactly.
* **Elisp adapter** replaces only the `(setq mcp-server-programs ...)` form, leaves everything else intact.
* **TOML adapter** splices *just* the `[mcp_servers.*]` tables. Comments/formatting outside those tables are preserved; inside MCP tables we control formatting. That’s the sustainable compromise without a formatting-preserving TOML parser.
* Policies are adjustable:

  * For **push** (EDN → target), we keep target `:rest` fully and let EDN win for `:mcp-servers`.
  * For **pull** (target → EDN), we let EDN keep its values and fill gaps from target; flip the merger if you want target to win.

If you want **per-key conflict policies** (e.g., append `:args` instead of overwrite), add a custom `merge-mcp` fn that handles `:mcp-servers` with per-field rules and plug it into `*push-policy*` / `*pull-policy*`.

This gives you exactly what you asked for: **don’t clobber unrelated config**, **pull & merge** both ways, and **composable modules** so adding a new schema is just one more adapter file.

\#clojure #babashka #merge #edn #json #toml #elisp #mcp #roundtrip #adapters #promethean

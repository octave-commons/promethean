Alright — good pivot. Let’s zoom in on **stateless agents** in your Promethean world.

---

# What “stateless” really means here

Not “no memory at all,” but:

* **No durable state** owned by the agent process itself.
* Can be killed and restarted at any time without loss of correctness.
* Relies entirely on **message inputs** + external **state stores** (Mongo, Chroma, etc.) to reconstruct context.
* Doesn’t hold open DB transactions, caches, or ephemeral session maps that other agents depend on.

So: *pure function of inputs → outputs, given external state queries.*

---

# Why you want them

* **Elasticity:** can scale horizontally (N workers, identical) because no sticky session.
* **Resilience:** if one dies, others keep processing; broker redelivers or tasks are idempotent.
* **Auditability:** all effects are explicit in envelopes and state DBs, not in hidden in-memory maps.
* **Testing:** golden tests are easier; feed in envelopes, expect out envelopes.

---

# Examples in your stack

✅ Already stateless or near-stateless:

* `discord-message-embedder` → consumes message docs, produces embeddings.
* `attachment-embedder` → same.
* `spectrogram` worker → consumes PCM, emits mel.
* `vad-chunker` → consumes PCM, emits segment envelopes.
* `tts` → consumes reply text, emits PCM path.

⚠ Stateful (but could be externalized):

* `discord-voice-access` → must track SSRC ↔ user\_id, sequence numbers, jitter. (*stateful access layer by necessity*).
* `discord-gateway` → holds WS seq + shard state.
* `discord-rest` → rate-limit buckets.

Those *must* keep state internally; they’re adapters.

---

# Conventions to make statelessness real

## 1. Idempotent outputs

Every output has a **deterministic key** you can recompute:

* Message indexer: key = `{provider, tenant, message_id}`.
* STT segment: key = `{session_id, segment_id}`.
* Spectrogram: key = hash of segment\_id + model version.

So if the worker re-runs, it overwrites/updates the same doc, not a duplicate.

## 2. Stateless worker contract

Add `kind: stateless-worker` in manifest:

```yaml
agent:
  id: vad-chunker
  kind: stateless-worker
  version: 0.1.0
  inputs:
    - topic: promethean.p.*.t.*.voice.audio.pcm
  outputs:
    - topic: promethean.p.*.t.*.voice.audio.segment
  durability: stateless
  idempotency_key: "{session_id}:{segment_id}"
```

## 3. Golden test fixture

A stateless agent *must* have fixtures where:

* Same input envelope → same output envelope(s).
* Output correlation only uses declared IDs (not runtime randomness).

## 4. Externalize caches

If an embedding model or VAD wants to cache:

* Use a Redis/mongo cache keyed by `{model, input_hash}`.
* Never keep it in local memory if it matters to correctness.
* Local LRU is ok for perf but must be re-generable.

## 5. Health & scaling

* Health just reports **“can I consume and produce?”** — no local state summary.
* Horizontal scale: multiple replicas subscribe to same topic; broker load-balances.

---

# Design pattern: “Access vs Workers”

This is your big line:

* **Access agents**: stateful, tenant-bound, hold sockets/seq/keys. One per provider+tenant.
* **Stateless workers**: tokenless, horizontally scalable, idempotent.

Everything messy lives in access; everything else becomes stateless workers you can spin up or down.

---

# Migration you can do now

* Tag manifests: `kind: provider-access` vs `kind: stateless-worker`.
* Add `idempotency_key` field to stateless worker outputs.
* Write golden fixtures for each.
* Update your heartbeat to show “stateless” vs “access” in health.

---

Would it help if I drafted a **template manifest + TS skeleton** for a generic stateless agent, so you can just copy it for VAD, spectrogram, STT, etc.? That way your Codex tasks can generate them uniformly.

Yep. If you don’t externalize the rules, “future-me” will keep moving the goalposts. The only way this stops is if the *checks themselves* are shipped as a versioned artifact you pin — npm package + Docker image — and every path to “green” goes through that artifact. You can still run it locally via Codex CLI, but the logic doesn’t live in your tree where it can be “fixed.”

Here’s the no-BS plan.

# What to ship

## 1) An npm CLI (TypeScript, AVA, GPL-3.0-only)

Name it `@promethean/constitution`. It exposes a single command that runs *all* your repo laws:

* flat packages (`packages/*` only; no nesting)
* ESM imports must use `.js` extensions on relatives
* `license` must be `GPL-3.0-only`
* tsconfig modes: Node packages = NodeNext; browser = ESNext+Bundler
* optional: forbid TS `paths`
* optional: block files you consider “sacred”

### package.json (core bits)

```json
{
  "name": "@promethean/constitution",
  "version": "1.0.0",
  "type": "module",
  "license": "GPL-3.0-only",
  "bin": { "prom-const": "dist/cli.js" },
  "scripts": { "build": "tsc -p tsconfig.json", "test": "ava" },
  "dependencies": { "globby": "^14.0.2", "ajv": "^8.17.1" },
  "devDependencies": { "typescript": "^5.5.4", "ava": "^6.1.0" }
}
```

### CLI sketch (pure TS, functional)

```ts
// src/cli.ts
import { readFileSync, readdirSync, statSync } from "node:fs";
import { join, dirname } from "node:path";
import globby from "globby";

type Fail = (msg: string) => { ok: false; msg: string };
const fail: Fail = (msg) => ({ ok: false, msg });
const ok = { ok: true as const };

const isDir = (p: string) => { try { return statSync(p).isDirectory(); } catch { return false; } };

const checkFlat = (root = "packages") => {
  const allowed = new Set(["src","test","dist","node_modules",".turbo","coverage"]);
  const pkgs = readdirSync(root).filter(p => isDir(join(root,p)));
  const bad: string[] = [];
  for (const p of pkgs) {
    for (const child of readdirSync(join(root,p))) {
      const full = join(root,p,child);
      if (isDir(full) && !allowed.has(child)) bad.push(full);
    }
  }
  return bad.length ? fail("Non-flat package content:\n" + bad.map(x=>" - "+x).join("\n")) : ok;
};

const checkLicense = async () => {
  const files = await globby(["packages/*/package.json"]);
  const bad: string[] = [];
  for (const f of files) {
    const j = JSON.parse(readFileSync(f,"utf8"));
    if (j.license !== "GPL-3.0-only") bad.push(f);
  }
  return bad.length ? fail("License mismatch:\n" + bad.map(x=>" - "+x).join("\n")) : ok;
};

const checkEsmExtensions = async () => {
  const files = await globby(["packages/*/src/**/*.{ts,tsx,mts,cts}"]);
  const bad: string[] = [];
  const relNoExt = /(?:from|import|export\s+\*.*from)\s*['"](\.{1,2}\/[^'".)]+)['"]/g;
  for (const f of files) {
    const s = readFileSync(f,"utf8");
    if (relNoExt.test(s)) bad.push(f);
  }
  return bad.length ? fail("Missing .js extension on relative imports:\n" + bad.map(x=>" - "+x).join("\n")) : ok;
};

const checkTsMode = async () => {
  const files = await globby(["packages/*/tsconfig.json"]);
  const bad: string[] = [];
  for (const f of files) {
    const j = JSON.parse(readFileSync(f,"utf8"));
    const c = j.compilerOptions ?? {};
    // Node packages: must be NodeNext/NodeNext
    // Heuristic: if it depends on fastify or has server.ts, treat as Node
    const pkgJson = JSON.parse(readFileSync(join(dirname(dirname(f)),"package.json"),"utf8"));
    const isNode = /fastify|@fastify\/static/.test(JSON.stringify(pkgJson)) || isDir(join(dirname(f),"src"));
    if (isNode) {
      if (!(c.module === "NodeNext" && c.moduleResolution === "NodeNext")) bad.push(f);
    } else {
      if (!(c.module === "ESNext" && c.moduleResolution === "Bundler")) bad.push(f);
    }
  }
  return bad.length ? fail("tsconfig mode violations:\n" + bad.map(x=>" - "+x).join("\n")) : ok;
};

const main = async () => {
  const checks = [await checkFlat(), await checkLicense(), await checkEsmExtensions(), await checkTsMode()];
  const errors = checks.filter((r: any) => r.ok === false) as Array<{msg:string}>;
  if (errors.length) {
    console.error("❌ Constitution violations:\n");
    for (const e of errors) console.error(e.msg + "\n");
    process.exit(1);
  }
  console.log("✅ Promethean constitution: all checks passed.");
};
main();
```

Tests with **AVA** can assert each rule on temp dirs. No mutation, pure checks.

## 2) A Docker image for the exact same CLI

Multi-stage build, runs as non-root, zero network.

**Dockerfile**

```Dockerfile
FROM node:22-alpine AS build
WORKDIR /app
COPY package.json tsconfig.json /app/
COPY src /app/src
RUN npm ci --ignore-scripts && npm run build

FROM node:22-alpine AS runtime
WORKDIR /work
RUN addgroup -S app && adduser -S app -G app
USER app
COPY --from=build /app/dist /tool/dist
COPY --from=build /app/package.json /tool/package.json
ENTRYPOINT ["node", "/tool/dist/cli.js"]
```

Build + push to both GHCR and Docker Hub. **Sign** it:

```bash
docker build -t ghcr.io/<you>/promethean-constitution:1.0.0 .
cosign sign --yes ghcr.io/<you>/promethean-constitution:1.0.0
```

# How to wire it so I can’t “fix the tests”

## A) GitHub Actions — run the **container** by **digest**

Branch protection: require a check named `constitution`.

```yaml
# .github/workflows/constitution.yml
name: constitution
on: [pull_request]

jobs:
  check:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4  # checks out PR
      - name: Constitution (pinned digest)
        run: |
          docker run --rm \
            -v "$PWD:/repo:ro" \
            --workdir /repo \
            ghcr.io/<you>/promethean-constitution@sha256:<IMMUTABLE_DIGEST>
```

* The PR **cannot** change what runs — it’s the exact image by digest.
* Your check script reads the PR tree as **read-only** (`:ro`). No “helpful” edits.

## B) Local dev and Codex CLI — same container

Pre-push hook that uses the same digest:

```bash
#!/usr/bin/env bash
set -euo pipefail
docker run --rm -v "$PWD:/repo:ro" --workdir /repo \
  ghcr.io/<you>/promethean-constitution@sha256:<DIGEST>
```

Codex CLI step? Same thing. Make it run the container before it does anything else.

## C) NPM usage (optional)

If you prefer npm locally:

```bash
npx @promethean/constitution@1.0.0
```

But **don’t use this in CI** — PRs can change versions. CI uses the **container by digest** only.

## D) Make cheating noisy

* In repo settings, require the `constitution` status check to pass before merge.
* Disallow bypassing required checks for non-admins (you).
* Add CODEOWNERS for workflow files so only you can change the workflow **name**. Even if someone changes the YAML body, branch protection still requires a status named `constitution`.

# Why this actually works

* The **rules are immutable** at the point of execution (pinned image digest).
* The **PR provides only the repo snapshot**, not the checker.
* Local tools and Codex CLI use the **same artifact**. You get identical behavior on laptop, CI, and “main.”
* If someone “improves” the constitution, they must publish a **new version**, and you have to **update the digest**. No accidental drift.

# Practical rollout (short, real)

1. Create `@promethean/constitution` TS package, add the four checks above, publish `1.0.0`.
2. Build/sign Docker image, grab its `sha256:...`.
3. Add the GitHub Action above with the **pinned digest**. Protect the `constitution` check.
4. Add pre-push hook that runs the same image+digest. (Optional but recommended.)
5. Rip out any in-repo scripts that overlap, so there’s exactly one source of truth.

# Your constraints, respected

* TypeScript, **functional**, **AVA** tests.
* **GPL-3.0-only** license.
* No bundlers; nothing in here needs one.
* Flat `packages/` — the CLI enforces it.
* Fastify/static, Web Components — unaffected; this only checks structure + ESM hygiene.

If you want, I can add one more tiny rule to the CLI: **“no nested `packages/*/*` directories allowed, ever.”** But honestly the flat-check as written already kills that.

You’re right: you can still screw it up if you want — you own the keys. But at least now *I* can’t hand you false hope via “fixed tests.” The only way the rules change is if **you** publish a new npm version and **you** update the container digest. That’s the adult-proofing layer you’ve been missing.

# Promethean: Code → Packages → Config Roadmap

## Phase 1 — Current state stabilizer (done/ongoing)

**Goal:** deterministic builds; bots stop “helpfully” dragging the world in.

* Python: **extras** + single **constraints.txt** (already in motion).
* Node: adopt **pnpm workspaces** with a top-level **overrides** block to pin versions repo-wide.
* CI: per-service **smoke** that installs only what the service declares, CPU-only tests.

**Definition of Done**

* [x] No `-r ../../shared/...` anywhere.
* [x] Services use `shared-core[...]` via extras.
* [x] `constraints.txt` committed and used in CI.
* [x] `pnpm-workspace.yaml` exists (even if underused for now).

---

# Phase 2: Many small packages under `./shared/<lang>/...`

## Directory conventions (no surprises)

```
repo/
  shared/
    py/
      core/
        pyproject.toml
        src/shared_core/__init__.py
        tests/
      audio/
        pyproject.toml
        src/shared_audio/...
      web/
        pyproject.toml
        src/shared_web/...
      hf/
        pyproject.toml
        src/shared_hf/...
    js/
      web-core/
        package.json
        src/index.ts
        tsconfig.json
        tests/
      hf-http/
        package.json
        src/index.ts
        tsconfig.json
```

**Rule:**

* `shared/py/*` → Python packages.
* `shared/js/*` → Node packages.
* No cross-language nesting. No “misc” folders. If it’s Python, it lives under `shared/py`. If it’s Node, `shared/js`. Period.

---

## Python package pattern (per module)

`shared/py/web/pyproject.toml`

```toml
[project]
name = "shared-web"
version = "0.0.1"
requires-python = ">=3.10"
# Keep base tiny; push heavies into extras.
dependencies = ["pydantic>=2.8"]

[project.optional-dependencies]
fastapi = ["fastapi>=0.115", "starlette>=0.47", "uvicorn>=0.30"]
flask    = ["flask>=3", "flask-cors>=6", "gunicorn>=23", "waitress>=3"]
dev      = ["pytest>=8.3", "pytest-cov>=5", "ruff>=0.6", "mypy>=1.11"]

[tool.setuptools.packages.find]
where = ["src"]
```

`shared/py/audio/pyproject.toml`

```toml
[project]
name = "shared-audio"
version = "0.0.1"
requires-python = ">=3.10"
dependencies = ["numpy>=1.26"]

[project.optional-dependencies]
lite   = ["soundfile>=0.13", "soxr>=0.5.0.post1", "audioread>=3.0", "pyworld>=0.3.5"]
ml     = ["torch>=2.4; platform_system=='Linux'", "torchaudio>=2.4"]
dev    = ["pytest>=8.3"]

[tool.setuptools.packages.find]
where = ["src"]
```

**Temporary parachute (optional):** put your current god-list into **one migration-only extra** in `shared/py/core` (e.g., `legacy-cpu = [...]`). Services can install `shared-web[dev]` + `shared-core[legacy-cpu]` initially, then you ratchet them down to minimal extras module by module.

**Pinning:** keep a single **repo-wide** `constraints.txt` at root and install with `-c constraints.txt`.

---

## Node package pattern (per module)

`shared/js/web-core/package.json`

```json
{
  "name": "@promethean/web-core",
  "version": "0.0.1",
  "type": "module",
  "exports": {
    ".": "./dist/index.js"
  },
  "peerDependencies": {
    "fastify": "^5 || ^4",
    "zod": "^3"
  },
  "devDependencies": {
    "typescript": "^5.6",
    "tsup": "^8.2",
    "@types/node": "^22"
  },
  "scripts": {
    "build": "tsup src/index.ts --dts",
    "test": "node --test"
  }
}
```

`pnpm-workspace.yaml` (root)

```yaml
packages:
  - "shared/js/*"
  - "services/js/*"
```

**Pinning:** use `overrides` in root `package.json` for repo-wide pins; run `pnpm --frozen-lockfile` in CI.

---

## Service consumption (no cross-folder `-r` or path spelunking)

**Python service install (CPU-only default)**

```bash
# from repo root
python -m venv .venv && . .venv/bin/activate
pip install -c constraints.txt -e shared/py/web[fastapi,dev]
pip install -c constraints.txt -e shared/py/hf[hf,dev]
pip install -c constraints.txt -e services/py/foo
pytest -q -m "not gpu and not slow"
```

**Node service install**

```bash
pnpm -w install --frozen-lockfile
pnpm --filter ./shared/js/web-core build
pnpm --filter ./services/js/foo test
```

**Guardrails**

* Pre-commit rejects any `-r ../../shared/...` in services.
* Simple static checker fails CI if a service imports `torch` but doesn’t depend on `shared/py/audio[ml]` (same mapper I sketched earlier).
* CPU-only test markers by default: `-m "not gpu and not slow"`.

---

## Minimal bootstraps (keep services thin now)

`services/py/foo/main.py`

```python
from shared_web.app import create_app  # lives in shared/py/web/src/shared_web/app.py

app = create_app()
```

Later, when you move to **config-only services**, this file just loads `.edn` and calls a factory.

---

## CI templates (drop-in)

**Python**

```yaml
- uses: actions/setup-python@v5
  with: { python-version: "3.11" }
- run: python -m venv .venv && . .venv/bin/activate
- run: pip install -c constraints.txt -e shared/py/web[fastapi,dev]
- run: pip install -c constraints.txt -e shared/py/hf[hf,dev]
- run: pip install -c constraints.txt -e services/py/foo
- run: pytest -q -m "not gpu and not slow" --maxfail=1
```

**Node**

```yaml
- uses: pnpm/action-setup@v4
  with: { version: 9 }
- run: pnpm -w install --frozen-lockfile
- run: pnpm --filter ./shared/js/web-core build
- run: pnpm --filter ./services/js/foo test
```

---

## Why this fits your constraint (and future flatten)

* **Today:** the folder tells you the toolchain (`shared/py/*` → pip, `shared/js/*` → pnpm). No guessing.
* **Isolation now:** each module declares its own deps; services opt into only the extras they need.
* **Tomorrow (flatten):** drop a tiny manifest next to each module, then a one-shot generator can move them to `./packages/**` without touching code.

### Optional manifest to ease the later flatten

`shared/py/hf/package.edn`

```clojure
{:package/name "shared-hf"
 :lang :python
 :entry "src/shared_hf"
 :extras {:hf ["transformers" "huggingface-hub" "tokenizers"]
          :dev ["pytest" "ruff"]}}
```

`shared/js/web-core/package.edn`

```clojure
{:package/name "@promethean/web-core"
 :lang :node
 :entry "src/index.ts"
 :peers ["fastify" "zod"]}
```

Your bb tool can later read these and emit `pyproject.toml` / `package.json` into `./packages/**`, preserving semantics.

---

## Short Kanban for Phase 2

* [ ] Create `shared/py/core`, `shared/py/web`, `shared/py/audio`, `shared/py/hf` (tiny base, real extras).
* [ ] Create `shared/js/web-core`, `shared/js/hf-http` (peers, exports).
* [ ] Add root `constraints.txt` (Python) + root `package.json` overrides (Node).
* [ ] Switch services to install from `shared/py/*[extras]` and `shared/js/*`.
* [ ] Pre-commit: forbid cross-`-r` includes.
* [ ] CI: CPU-only smoke per service; build Node packages before tests.
* [ ] (Optional) Add `legacy-cpu` extra in `shared/py/core` to keep lights on while ratcheting.
* [ ] (Optional) Add `package.edn` per module; do nothing with it yet (future flatten helper).

---

## Hard lines

* No code in services except the **bootstrap** (and tests) — everything else goes in `shared/<lang>/<module>`.
* No service may reference `shared/py/**` via file paths; only editable installs.
* Heavy deps **must** live in module **extras** (py) or **peerDependencies** (js).
* Default CI is **CPU-only**. GPU/NPU is opt-in jobs.

\#hashtags
\#monorepo #python #node #extras #peerDependencies #constraints #pnpm #babashka #EDN #migration #systemsDesign

---

## Phase 3 — Thin services (call shared functions only)

**Goal:** no business logic in services; they’re glue.

* Enforce a **structure rule** per service:

  * `main.py`/`server.ts` wires config → adapters → package APIs.
  * No other `.py`/`.ts` besides entry + trivial adapters.
* Add a **CI guard** that fails if service directories contain >N SLOC or import non-allowed modules.

**CI “thin service” guard (Python)**

```bash
# Disallow > 200 SLOC python files in services (except tests and main)
if rg -n '^[^\s#]' services/py | awk -F: '{c[$1]++} END{for(f in c) if(c[f]>200 && f !~ /tests|main\.py/) print f, c[f]}' | grep .; then
  echo "Service contains too much code; move it to packages/"; exit 1; fi
```

**Definition of Done**

* [ ] Each service entrypoint ≤200 SLOC; everything else lives in `packages/`.
* [ ] No service-local utilities remain (migrated or deleted).
* [ ] Import graph from services only points to `packages/*`.

---

## Phase 4 — Services as **pure config**

**Goal:** service folders contain only **.edn** (or JSON/TOML) configs + tiny bootstrap.

* Define a **stable config schema** (`.edn`) that describes:

  * package(s) to compose,
  * transports (http/ws/grpc),
  * routes/tools/tasks exposed,
  * resource gates (cpu/gpu/npu),
  * environment/secret selectors.

**Example service config (`services/foo/service.edn`)**

```clojure
{:service/name :foo
 :runtime {:lang :python :entry "shared_web.app:create_app" :workers 2}
 :deps {:python [{:pkg "shared-core" :extras [:web :io]}
                 {:pkg "shared-hf"   :extras [:hf]}]
        :node   []}
 :endpoints [{:method :GET :path "/health" :handler :shared_web.health/handle}
             {:method :POST :path "/infer"  :handler :shared_hf.pipeline/infer}]
 :resources {:gpu false :npu true}
 :telemetry {:otlp true :posthog false}}
```

Bootstrap script (generated or static) just reads EDN and calls the target factory (`create_app`) with settings.

**Definition of Done**

* [ ] Service code = config files + 20-line bootstrap.
* [ ] Build/test derive entirely from config.

---

## Phase 5 — Flatten languages into **homogeneous packages/** and **EDN manifests**

**Goal:** everything lives under `packages/…`, annotated by language/runtime; services disappear into configs.

**Example package manifest (`packages/shared-hf/package.edn`)**

```clojure
{:package/name "shared-hf"
 :runtimes [{:lang :python
             :targets [{:name :cpu   :extras [:hf]}
                       {:name :openvino :extras [:openvino :hf]}]}
            {:lang :node
             :targets [{:name :lite :deps ["openai" "zod"]}
                       {:name :server :deps ["fastify" "undici"]}]]}
```

Your bb/EDN builder reads these and:

* emits **`pyproject.toml`** blocks (`[project.optional-dependencies]`) for Python,
* emits **`package.json`** with `peerDependencies`/`exports` for Node,
* updates the repo-wide pinning (**`constraints.txt`** and workspace **overrides**).

**Definition of Done**

* [ ] All package deps derive from EDN manifests.
* [ ] `pyproject.toml` / `package.json` are **generated**, not hand-edited.
* [ ] CI regenerates and refuses drift.

---

## Guardrails that keep agents honest

1. **Forbid cross-includes**
   Pre-commit rejects `-r ../../…` in any requirements file.

2. **Extras coverage check (Python)**
   Static scan maps imports → required extras; CI fails if a service imports `torch` but omits `audio-ml`.

3. **Thin service check**
   SLOC and import guards ensure logic migrates to `packages/`.

4. **Single source of truth pins**

   * Python: `constraints.txt`.
   * Node: workspace **overrides** (and lockfile), e.g.:

     ```json
     // package.json (root)
     {
       "packageManager": "pnpm@9",
       "overrides": {
         "zod": "3.23.8",
         "undici": "6.19.8"
       }
     }
     ```

   CI must install with `pnpm --frozen-lockfile` and Python with `-c constraints.txt`.

5. **CPU-only default**
   Pytest `-m "not gpu and not slow"`, Node skips GPU codepaths unless a `GPU=true` job.

---

## Practical repo layout (target)

```
repo/
  packages/
    shared-core/               # py minimal base + extras
    shared-web/                # py fastapi/starlette glue
    shared-hf/                 # py transformers/hub
    shared-audio/              # py audio-lite + audio-ml
    web-core/                  # node web utils with peers
    hf-http/                   # node http wrappers w/ peers
  services/
    foo/
      service.edn              # config-only
      main.py                  # tiny bootstrap (reads EDN)
    bar/
      service.edn
  tools/
    check_extras.py
    gen_pyproject_from_edn.bb  # babashka task
    gen_package_json.bb
  constraints.txt
  pnpm-workspace.yaml
  .pre-commit-config.yaml
```

---

## CI blueprint (fast, deterministic)

**Python (service job)**

```yaml
- uses: actions/setup-python@v5
  with: { python-version: "3.11" }
- run: python -m venv .venv && . .venv/bin/activate
- run: pip install -c constraints.txt -e packages/shared-core[dev,io,web]  # or read from service.edn
- run: pip install -c constraints.txt -e services/py/foo
- run: pytest -q -m "not gpu and not slow" --maxfail=1
```

**Node (service job)**

```yaml
- uses: pnpm/action-setup@v4
  with: { version: 9 }
- run: pnpm -w install --frozen-lockfile
- run: pnpm --filter ./packages/web-core build
- run: pnpm --filter ./services/ts/foo test
```

**Schema drift**

```yaml
- run: bb tools/gen_pyproject_from_edn.bb
- run: git diff --exit-code || (echo "Generated files out of date"; exit 1)
```

---

## Kanban checklist (copy into your board)

* [ ] **P2:** Create `shared/<lang>/core` with minimal base and extras.
* [ ] **P2:** Make `legacy-cpu` extra; switch services to `shared-core[legacy-cpu]`.
* [ ] **P2:** Split libs into `shared/<lang>/<module>` with peerDeps.
* [ ] **P3:** Add **thin service** SLOC/import guard; enforce in CI.
* [ ] **P3:** Migrate service `foo` logic → packages; reduce entrypoint ≤200 SLOC.
* [ ] **P3:** Replace `legacy-cpu` in `foo` with `[web,io]` (or minimal set).
* [ ] **P3:** Add `tools/check_extras.py`; CI fails on missing extras.
* [ ] **P4:** Introduce `service.edn` for `foo`; bootstrap reads EDN.
* [ ] **P4:** Run `foo` via config only; delete service-local libs.
* [ ] **P5:** Author `package.edn` for `shared-hf`/`web-core`; generate pyproject/package.json.
* [ ] **P5:** Add EDN → files generator (bb); CI refuses drift.
* [ ] **P5:** Remove `legacy-cpu` from repo once no consumers remain.

---

## Reality checks (hard truths)

* Don’t let **shared base** grow. Heavy deps must be extras (py) or peers (node).
* Services must **declare** what they import. No spooky transitive luck.
* Keep **GPU** strictly opt-in. Most CI should never see CUDA or heavy runtimes.
* The EDN builder should be **thin codegen**, not a bespoke package manager. Generate `pyproject.toml`, `package.json`, and keep installs standard (`pip`, `pnpm`).

You’re on the right track: extras + constraints gave you the traction. This plan finishes the job without wrecking throughput.

\#hashtags
\#systemsDesign #python #node #monorepo #packages #extras #peerDependencies #pnpm #constraints #BB #EDN #CI #promethean

I've gotten the flow so far to go audio -> transcript -> orchestrator -> llm -> enqueueUtterance Then I don't know what is happening after that. Maybe we're not handling this right after updatingot  double buffers?

I just want to get the code working as it is, I don't have the brain cells yet to think hard about where this goes in the end as we move to strict systems.

This is an intermediary step. There are no errors, just nothing is happening.


```typescript
import type { World, Entity } from "../../ds/ecs";
import type { defineAgentComponents } from "../components";

export function enqueueUtterance(
  w: World,
  agent: Entity,
  C: ReturnType<typeof import("../components").defineAgentComponents>,
  opts: {
    id?: string;
    priority?: number;
    group?: string;
    bargeIn?: "none" | "duck" | "pause" | "stop";
    factory: () => Promise<any>;
  },
) {
  const { Turn, PlaybackQ, Utterance, AudioRes, Policy } = C as ReturnType<
    typeof defineAgentComponents
  >;
  const turnId = w.get(agent, Turn)?.id || 0;
  const pq = w.get(agent, PlaybackQ) ?? { items: [] as number[] };
  const defaultBarge = (w.get(agent, Policy)?.defaultBargeIn ?? 'pause') as
    | 'none'
    | 'duck'
    | 'pause'
    | 'stop';

  if (opts.group) {
    for (const uEid of pq.items) {
      const u = w.get(uEid, Utterance)!;
      if (
        u.group === opts.group &&
        u.status === "queued" &&
        u.priority <= (opts.priority ?? 1)
      ) {
        const cancelled: typeof u = { ...u, status: "cancelled" };
        w.set(uEid, Utterance, cancelled);
      }
    }
  }

  const e = w.createEntity();
  const utt = {
    id: opts.id ?? globalThis.crypto?.randomUUID?.() ?? String(Math.random()),
    turnId,
    priority: opts.priority ?? 1,
    bargeIn: opts.bargeIn ?? defaultBarge,
    status: "queued" as const,
    token: Math.floor(Math.random() * 1e9),
  } as {
    id: string;
    turnId: number;
    priority: number;
    group?: string;
    bargeIn: "none" | "duck" | "pause" | "stop";
    status: "queued";
    token: number;
  };
  if (opts.group !== undefined) utt.group = opts.group;
  w.addComponent(e, Utterance, utt);
  w.addComponent(e, AudioRes, { factory: opts.factory });
  // w.endTick();

  // write PlaybackQ immutably to next buffer
  w.set(agent, PlaybackQ, { items: [...pq.items, e] });
}
```

```typescript
import type { World, Entity } from "../../ds/ecs";
import { defineAgentComponents } from "../components";

// If the user keeps speaking for at least this long while we're paused,
// escalate to a hard stop of the current utterance.
const STOP_AFTER_MS = 1000; // tune: 700–1200ms feels natural

type BargeState = { speakingSince: number | null; paused: boolean };

export function SpeechArbiterSystem(w: World) {
  const { Turn, PlaybackQ, AudioRef, Utterance, AudioRes, VAD, Policy } =
    defineAgentComponents(w);

  const qAgent = w.makeQuery({ all: [Turn, PlaybackQ, AudioRef, Policy] });
  const qVAD = w.makeQuery({ all: [VAD] });

  // per-agent transient state, no component needed
  const state = new Map<Entity, BargeState>();
  const getState = (agent: Entity): BargeState => {
    let s = state.get(agent);
    if (!s) {
      s = { speakingSince: null, paused: false };
      state.set(agent, s);
    }
    return s;
  };

  function userSpeaking(): boolean {
    for (const [, get] of w.iter(qVAD)) if (get(VAD).active) return true;
    return false;
  }

  return async function run(_dt: number) {
    for (const [agent, get] of w.iter(qAgent)) {
      const turnId = get(Turn).id;
      const queue = get(PlaybackQ);
      const player = get(AudioRef).player;
      const policy = get(Policy);
      const bs = getState(agent);

      // purge stale/cancelled (treat prev buffer values as immutable)
      const filteredItems = queue.items.filter((uEid: Entity) => {
        const u = w.get(uEid, Utterance);
        return (
          u &&
          u.turnId >= turnId &&
          (u.status === "queued" || u.status === "playing")
        );
      });
      let items = filteredItems;

      // if currently playing, enforce barge-in with pause→stop escalation
      const current = items.find(
        (uEid: Entity) => w.get(uEid, Utterance)?.status === "playing",
      );

      if (current) {
        const u = w.get(current, Utterance)!;
        const active = userSpeaking();
        const bi = u.bargeIn ?? policy.defaultBargeIn; // "pause" | "stop" | "duck" | "none"

        const hardStop = () => {
          u.status = "cancelled";
          w.set(current, Utterance, u);
          try {
            player.stop(true);
          } catch {}
          bs.speakingSince = null;
          bs.paused = false;
        };

        if (active) {
          const now = Date.now();
          if (bi === "stop") {
            hardStop();
          } else if (bi === "pause") {
            // pause immediately, then escalate to stop if speech continues
            if (!bs.paused) {
              try {
                player.pause(true);
              } catch {}
              bs.paused = true;
              bs.speakingSince = now;
            } else if (
              bs.speakingSince != null &&
              now - bs.speakingSince >= STOP_AFTER_MS
            ) {
              hardStop();
            }
          }
          // NOTE: "duck" should be handled by external mixer (set volume),
          // and "none" means ignore speech while playing.
        } else {
          // no user speech; resume if we were paused
          if (bi === "pause" && bs.paused) {
            try {
              player.unpause();
            } catch {}
            bs.paused = false;
          }
          bs.speakingSince = null;
        }

        state.set(agent, bs);
        // persist the filtered queue for next frame
        w.set(agent, PlaybackQ, { items });
        continue; // don't pick a new item while we're dealing with current
      }

      // no current item: clear paused state and pick next if any
      if (bs.paused || bs.speakingSince != null) {
        bs.paused = false;
        bs.speakingSince = null;
        state.set(agent, bs);
      }

      if (!player.isPlaying() && items.length) {
        items = [...items].sort(
          (a: Entity, b: Entity) =>
            w.get(b, Utterance)!.priority - w.get(a, Utterance)!.priority,
        );
        let pickedIdx = -1,
          picked: Entity | null = null;
        for (let i = 0; i < items.length; i++) {
          const uEid = items[i];
          const u = w.get(uEid, Utterance)!;
          if (u.turnId < turnId || u.status !== "queued") continue;
          pickedIdx = i;
          picked = uEid;
          break;
        }
        if (picked != null) {
          // dequeue immutably
          if (pickedIdx >= 0)
            items = items.filter((_: Entity, i: number) => i !== pickedIdx);
          const utt = w.get(picked, Utterance)!;
          const res = await w
            .get(picked, AudioRes)!
            .factory()
            .catch(() => null);

          // race cancel guard
          const latest = w.get(picked, Utterance);
          if (!latest || latest.token !== utt.token || !res) continue;

          const nowPlaying: typeof utt = { ...utt, status: "playing" };
          w.set(picked, Utterance, nowPlaying);

          // reset barge transient state at start of playback
          bs.paused = false;
          bs.speakingSince = null;
          state.set(agent, bs);

          player.play(res);
        }
      }

      // write back the (possibly updated) queue items to next buffer
      w.set(agent, PlaybackQ, { items });
    }
  };
}
```

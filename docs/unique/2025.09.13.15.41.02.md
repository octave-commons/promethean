Totally fair. 10k+ lint hits = â€œfix as you goâ€ territory. Hereâ€™s a clean way to tame it without melting your focus.

# Ratchet plan (no new lint; old debt shrinks steadily)

1. **Gate only changed files**

* Pre-commit: lint + type-check just staged files.
* CI: enforce â€œno new lintâ€ by comparing against `origin/dev`.

2. **Keep a debt snapshot**

* Take a one-time baseline (JSON) for the whole repo.
* In CI, fail only if the PR introduces violations *not* in the baseline.
* Regenerate (or prune) the baseline as you pay things down.

3. **Autofix the easy 60â€“70%**

* Nightly/weekly job runs `eslint --fix` on the repo, commits trivial wins.
* Keep it idempotent and cached.

4. **Targeted rules per sweep**

* Pick 1â€“2 rules per week (e.g., `prefer-const`, `eqeqeq`, `curly`, simple import order) and fix them repo-wide.
* Leave gnarly rules (complexity, exhaustive deps, etc.) for later.

5. **Enforce â€œno blanket disablesâ€**

* Allow `eslint-disable-next-line` but require a reason comment.
* Add `eslint-plugin-eslint-comments` to police this.

---

## Drop-in snippets (TypeScript + pnpm, idempotent)

**package.json (root)**

```jsonc
{
  "scripts": {
    "lint": "eslint . --ext .ts,.tsx,.mts,.cts --cache --cache-location .cache/eslint",
    "lint:fix": "pnpm lint -- --fix",
    "lint:staged": "ESLINT_STAGED=1 node ./scripts/eslint-staged.mjs",
    "typecheck": "tsc -p tsconfig.json --noEmit",
    "precommit": "pnpm lint:staged && pnpm typecheck:staged",
    "ci:lint": "node ./scripts/eslint-ratchet.mjs",
    "ci:typecheck": "tsc -p tsconfig.json --noEmit"
  },
  "lint-staged": {
    "*.{ts,tsx,mts,cts}": [
      "eslint --fix --cache --cache-location .cache/eslint",
      "git add"
    ]
  }
}
```

**scripts/eslint-staged.mjs** (only run eslint on staged files)

```js
import { execSync } from "node:child_process";
const files = execSync("git diff --cached --name-only --diff-filter=ACM", { encoding: "utf8" })
  .split("\n").filter(f => f && /\.(ts|tsx|mts|cts)$/.test(f));
if (!files.length) process.exit(0);
execSync(`eslint ${files.map(f => `"${f}"`).join(" ")} --cache --cache-location .cache/eslint`, { stdio: "inherit" });
```

**scripts/eslint-ratchet.mjs** (baseline + â€œno new lintâ€)

```js
import { execSync } from "node:child_process";
import fs from "node:fs";

const BASELINE = ".eslint-baseline.json";

// generate/update baseline if missing (idempotent bootstrap)
if (!fs.existsSync(BASELINE)) {
  const json = execSync("eslint . --ext .ts,.tsx,.mts,.cts -f json", { encoding: "utf8" });
  fs.writeFileSync(BASELINE, json);
  console.log("Baseline created:", BASELINE);
  process.exit(0);
}

// gather current PR lint
const currentJson = execSync("eslint . --ext .ts,.tsx,.mts,.cts -f json --cache --cache-location .cache/eslint", { encoding: "utf8" });
const current = JSON.parse(currentJson);
const baseline = JSON.parse(fs.readFileSync(BASELINE, "utf8"));

// index baseline by file+rule+line (simple but effective)
const key = (m) => m.messages.map(msg => `${m.filePath}:${msg.ruleId}:${msg.line}:${msg.column}`);
const baseSet = new Set(baseline.flatMap(key));

const newIssues = [];
for (const m of current) {
  for (const msg of m.messages) {
    const k = `${m.filePath}:${msg.ruleId}:${msg.line}:${msg.column}`;
    if (!baseSet.has(k)) newIssues.push({ filePath: m.filePath, ...msg });
  }
}

if (newIssues.length) {
  console.error("âŒ New lint violations introduced:");
  for (const n of newIssues.slice(0, 200)) {
    console.error(`${n.filePath}:${n.line}:${n.column}  ${n.ruleId}  ${n.message}`);
  }
  process.exit(1);
}
console.log("âœ… No new lint introduced.");
```

**.husky/pre-commit**

```bash
#!/usr/bin/env bash
pnpm precommit
```

---

## Weekly autofix job (cheap wins)

```bash
pnpm lint:fix
git add -A && git commit -m "chore(eslint): autofix trivial rules"
```

---

## Rule triage (good first sweeps)

* âœ… autofixable: `prefer-const`, `no-var`, `eqeqeq`, `curly`, `no-extra-semi`, `quotes`, `semi`, `comma-dangle`, `indent` (if you must), `import/order` (with a standard).
* ðŸŽ¯ semi-auto: `no-unused-vars` (TS-aware, `argsIgnorePattern: '^_'`), `no-shadow` (TS rule), `consistent-return`.
* ðŸš§ later: cyclomatic complexity, exhaustive deps, strict null checks migrations.

---

## Tiny workflow map

```mermaid
flowchart LR
  A(Dev edits file) --> B{Pre-commit}
  B -->|staged files| C[eslint --fix + cache]
  C --> D[tsc --noEmit (staged)]
  D -->|passes| E(Commit)
  E --> F(CI)
  F --> G[eslint-ratchet (baseline)]
  G -->|no new lint| H(merge)
  G -->|new issues| I(fail + list)
```

If you want, I can drop these scripts into `packages/@promethean/dev-scripts` (new package) and wire root `package.json` to themâ€”idempotent, cached, and monorepo-friendly.

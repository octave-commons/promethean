hell yes—let’s ship a **real, small-piece** module for editor settings that mirrors the MCP stuff you built, *but* scoped to VS Code family settings (JSONC), with per-command parsing and tiny ops.

Below is a **clean, working skeleton** you can drop in. It:

* keeps a canonical EDN `:vscode-settings` map in your repo,
* reads/writes JSONC `settings.json` for Code/VSCodium/Windsurf (or any VS-based target path),
* preserves unknown keys in targets (won’t stomp plugin stuff),
* has `push-all / pull-all / sync-all / doctor` commands,
* tiny functions, no “god” case/do blobs.

---

# mk/ide\_core.clj

Small utils: JSONC reader/writer, atomic writes, path resolving.

```clj
(ns mk.ide-core
  (:require [babashka.fs :as fs]
            [clojure.string :as str]
            [cheshire.core :as json]
            [clojure.pprint :as pp]))

;; ------------ paths ------------

(defn resolve-path
  "Like your mcp-core version; duplicated so this ns is standalone."
  [base p]
  (let [s (str p)
        s (str/replace s #"\$HOME\b" (System/getenv "HOME"))
        s (if (str/starts-with? s "~") (str (System/getenv "HOME") (subs s 1)) s)]
    (-> (if (fs/absolute? s) s (fs/path base s))
        fs/absolutize
        str)))

(defn ensure-parent! [path]
  (fs/create-dirs (fs/parent (fs/path path)))
  path)

;; ------------ atomic writes ------------

(defn write-atomic! [path s]
  (let [p (fs/path path)
        dir (fs/parent p)
        _   (fs/create-dirs dir)
        tmp (fs/create-temp-file {:dir dir :prefix ".tmp-ide-" :suffix ".json"})]
    (spit tmp s)
    (fs/move tmp p {:replace-existing true :atomic true})
    path))

;; ------------ pretty EDN (for future if you want) ------------

(defn pretty-edn-str [x]
  (binding [*print-namespace-maps* false
            pp/*print-right-margin* 100]
    (with-out-str (pp/write x :dispatch pp/code-dispatch))))

;; ------------ JSONC (lossy on comments; safe on content) ------------

(defn- strip-jsonc
  "Remove // and /* */ comments outside strings."
  [s]
  (let [sb (StringBuilder.)
        n  (count s)]
    (loop [i 0 in-str? false esc? false blk? false line? false]
      (if (>= i n)
        (str sb)
        (let [c (.charAt s i)
              c2 (when (< (inc i) n) (.charAt s (inc i)))]
          (cond
            ;; inside block comment
            blk? (if (and (= c \*) (= c2 \/))
                   (recur (+ i 2) in-str? false false false)
                   (recur (inc i) in-str? false true false))

            ;; inside line comment
            line? (if (= c \newline)
                    (do (.append sb c)
                        (recur (inc i) in-str? false false false))
                    (recur (inc i) in-str? false false true))

            ;; inside string
            in-str?
            (do (.append sb c)
                (cond
                  esc?     (recur (inc i) true false false false)
                  (= c \\) (recur (inc i) true true  false false)
                  (= c \") (recur (inc i) false false false false)
                  :else    (recur (inc i) true  false false false)))

            ;; not in string/comment
            :else
            (cond
              (and (= c \/) (= c2 \*)) (recur (+ i 2) false false true  false)
              (and (= c \/) (= c2 \/)) (recur (+ i 2) false false false true)
              (= c \") (do (.append sb c) (recur (inc i) true false false false))
              :else    (do (.append sb c) (recur (inc i) false false false false)))))))))

(defn read-jsonc
  "Read JSONC file at path into Clojure map (string keys). Missing -> {}."
  [path]
  (if (fs/exists? path)
    (let [txt (slurp path)
          raw (strip-jsonc txt)]
      (if (str/blank? (str/trim raw)) {} (json/parse-string raw)))
    {}))

(defn pretty-json-str
  "Deterministic pretty JSON (sorted keys)."
  [m]
  (json/generate-string m {:pretty true :escape-non-ascii false :sort-keys true}))

(defn write-json-atomic!
  "Write JSON (no comments) atomically."
  [path m]
  (->> (pretty-json-str m)
       (write-atomic! (ensure-parent! path))))
```

---

# mk/ide\_adapter\_settings\_json.clj

Adapter: read/write a VS-family `settings.json` at an arbitrary path.

```clj
(ns mk.ide-adapter-settings-json
  (:require [mk.ide-core :as core]))

(defn read-full
  "Return {:settings <map>} from a JSONC settings.json path."
  [path]
  {:settings (core/read-jsonc path)})

(defn write-full
  "Write {:settings <map>} back to JSON. Keep unknown keys by merging before call."
  [path {:keys [settings]}]
  (core/write-json-atomic! path (or settings {})))
```

---

# mk/ide\_ops.clj

Tiny, composable ops for pull/push/sync/doctor. Minimal deep-merge that preserves unknown keys by default, preferring canonical values on conflicts.

```clj
(ns mk.ide-ops
  (:require [mk.ide-core :as core]
            [mk.ide-adapter-settings-json :as sjson]
            [babashka.fs :as fs]))

;; ---------- merge helpers ----------

(defn deep-merge
  "Shallow for non-maps; prefers rhs on conflict; recurses for maps."
  [a b]
  (cond
    (and (map? a) (map? b))
    (merge-with deep-merge a b)
    :else b))

(defn deep-merge-prefer-left
  "Like deep-merge but keeps left on conflict."
  [a b]
  (cond
    (and (map? a) (map? b))
    (merge-with deep-merge-prefer-left a b)
    :else (if (nil? b) a a))) ;; if rhs nil keep lhs, else rhs

;; ---------- ops ----------

(defn pull-one
  "Load target settings and merge into canonical {:vscode-settings m} using merge-fn.
   Returns updated EDN map."
  [edn-map base {:keys [path merge-policy]}]
  (let [abs (core/resolve-path base path)
        tgt (sjson/read-full abs)
        mfn (case merge-policy
              :prefer-target deep-merge
              ;; default: prefer canonical
              deep-merge-prefer-left)]
    (update edn-map :vscode-settings #(mfn % (:settings tgt)))))

(defn push-one!
  "Write canonical into target settings while preserving unknown target keys.
   merge-policy determines who wins on conflicts (:prefer-canonical default)."
  [edn-map base {:keys [path merge-policy]}]
  (let [abs (core/resolve-path base path)
        tgt (sjson/read-full abs)
        canon (:vscode-settings edn-map)
        mfn  (case merge-policy
               :prefer-target deep-merge
               deep-merge-prefer-left)
        merged (mfn (:settings tgt) canon)]
    (sjson/write-full abs {:settings merged})
    {:path abs}))

(defn sync-one!
  "Pull target -> merge into canonical -> write back."
  [edn-map base {:keys [path merge-policy]}]
  (let [edn*   (pull-one edn-map base {:path path :merge-policy merge-policy})
        _      (push-one! edn* base {:path path :merge-policy merge-policy})]
    edn*))

(defn push-all!
  [edn-map base targets]
  (mapv (fn [t] (push-one! edn-map base t)) targets))

(defn sync-all!
  [edn-map base targets]
  (reduce (fn [acc t] (sync-one! acc base t)) edn-map targets))

;; ---------- doctor ----------

(defn doctor-target
  [base {:keys [path]}]
  (let [abs (core/resolve-path base path)
        parent (-> abs fs/path fs/parent)]
    {:path abs
     :exists? (fs/exists? abs)
     :parent (str parent)
     :parent-exists? (fs/exists? parent)}))

(defn doctor
  [edn-map base]
  (let [targets (:settings-targets edn-map)]
    {:targets (mapv (partial doctor-target base) targets)}))
```

---

# mk/ide\_cli.bb

Per-command parsing (spec table), tiny handlers, delegates to ops.

```clj
#!/usr/bin/env bb
(ns mk.ide-cli
  (:require [babashka.fs :as fs]
            [clojure.edn :as edn]
            [clojure.string :as str]
            [mk.ide-ops :as ops]))

;; ----------- utils -----------

(defn die! [msg usage]
  (binding [*out* *err*]
    (println msg)
    (println usage)
    (System/exit 2)))

(defn value-after [xs flag]
  (some (fn [[a b]] (when (= a flag) b)) (partition 2 1 xs)))

(defn ensure-edn-base [edn-path]
  (or (some-> edn-path fs/path fs/parent str) (str (fs/cwd))))

;; ----------- per-command spec -----------

(def cmd-spec
  {:settings/pull     {:pos   [:target] :req-opts [:edn] :opt-opts [:merge-policy :out]
                       :usage "usage: bb -m mk.ide-cli settings pull <target> --edn <path> [--merge-policy prefer-target|prefer-canonical] [--out <edn>]"}
   :settings/push     {:pos   [:target] :req-opts [:edn] :opt-opts [:merge-policy]
                       :usage "usage: bb -m mk.ide-cli settings push <target> --edn <path> [--merge-policy prefer-target|prefer-canonical]"}
   :settings/sync     {:pos   [:target] :req-opts [:edn] :opt-opts [:merge-policy :out]
                       :usage "usage: bb -m mk.ide-cli settings sync <target> --edn <path> [--merge-policy prefer-target|prefer-canonical] [--out <edn>]"}
   :settings/push-all {:pos   []        :req-opts [:edn] :opt-opts [:merge-policy]
                       :usage "usage: bb -m mk.ide-cli settings push-all --edn <path> [--merge-policy prefer-target|prefer-canonical]"}
   :settings/sync-all {:pos   []        :req-opts [:edn] :opt-opts [:merge-policy :out]
                       :usage "usage: bb -m mk.ide-cli settings sync-all --edn <path> [--merge-policy prefer-target|prefer-canonical] [--out <edn>]"}
   :settings/doctor   {:pos   []        :req-opts [:edn] :opt-opts []
                       :usage "usage: bb -m mk.ide-cli settings doctor --edn <path>"} })

(defn parse-argv [argv]
  (let [[a b & rest] argv
        cmd-kw (keyword (str a "/" b))
        {:keys [pos req-opts opt-opts usage]} (get cmd-spec cmd-kw)]
    (when-not usage
      (die! (str "unknown cmd: " a " " b)
            "usage: bb -m mk.ide-cli settings <pull|push|sync|push-all|sync-all|doctor> ..."))
    (let [n-pos (count pos)
          positionals (take n-pos rest)
          flags       (drop n-pos rest)
          opts-map (into {}
                         (for [o (concat req-opts opt-opts)]
                           [o (value-after flags (str "--" (name o)))]))
          pos-map (into {} (map vector pos positionals))]
      (doseq [k pos] (when (nil? (get pos-map k))
                       (die! (str "missing positional arg: " (name k)) usage)))
      (doseq [o req-opts] (when (nil? (get opts-map o))
                            (die! (str "missing required option: --" (name o)) usage)))
      (merge {:cmd cmd-kw} pos-map opts-map))))

;; ----------- handlers -----------

(defn load-edn [p] (edn/read-string (slurp p)))

(defn handle-settings-pull [{:keys [target edn out merge-policy]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        merged  (ops/pull-one edn-map base {:path target
                                            :merge-policy (keyword (or merge-policy "prefer-canonical"))})]
    (spit (or out edn) (with-out-str (clojure.pprint/pprint merged)))
    (println "pulled ->" (or out edn))))

(defn handle-settings-push [{:keys [target edn merge-policy]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        {:keys [path]} (ops/push-one! edn-map base {:path target
                                                    :merge-policy (keyword (or merge-policy "prefer-canonical"))})]
    (println "pushed ->" path)))

(defn handle-settings-sync [{:keys [target edn out merge-policy]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        merged  (ops/sync-one! edn-map base {:path target
                                             :merge-policy (keyword (or merge-policy "prefer-canonical"))})]
    (spit (or out edn) (with-out-str (clojure.pprint/pprint merged)))
    (println "synced EDN & target")))

(defn handle-settings-push-all [{:keys [edn merge-policy]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        targets (:settings-targets edn-map)]
    (doseq [{:keys [path]} (ops/push-all! edn-map base (map #(assoc % :merge-policy (keyword (or merge-policy "prefer-canonical")))
                                                            targets))]
      (println "pushed ->" path))))

(defn handle-settings-sync-all [{:keys [edn out merge-policy]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        targets (:settings-targets edn-map)
        merged  (ops/sync-all! edn-map base (map #(assoc % :merge-policy (keyword (or merge-policy "prefer-canonical")))
                                                 targets))]
    (spit (or out edn) (with-out-str (clojure.pprint/pprint merged)))
    (println "synced all; wrote" (or out edn))))

(defn handle-settings-doctor [{:keys [edn]}]
  (let [base (ensure-edn-base edn)
        edn-map (load-edn edn)
        {:keys [targets]} (ops/doctor edn-map base)]
    (println "Targets:")
    (doseq [{:keys [path parent parent-exists? exists?]} targets]
      (println (format "  %-60s  parent:%-5s  exists:%-5s"
                       path (if parent-exists? "yes" "no")
                       (if exists? "yes" "no"))))))

(def dispatch
  {:settings/pull     handle-settings-pull
   :settings/push     handle-settings-push
   :settings/sync     handle-settings-sync
   :settings/push-all handle-settings-push-all
   :settings/sync-all handle-settings-sync-all
   :settings/doctor   handle-settings-doctor})

(defn -main [& argv]
  (let [{:keys [cmd] :as args} (parse-argv argv)
        f (dispatch cmd)]
    (f args)))
```

---

# Example `config/ide.edn`

Readable, single canonical store + list of targets. You can add/remove targets freely.

```edn
{:vscode-settings
 {"editor.fontFamily" "JetBrains Mono"
  "editor.fontSize" 14
  "files.trimTrailingWhitespace" true
  "terminal.integrated.scrollback" 5000}

 :settings-targets
 [{:path "~/.config/Code/User/settings.json"}
  {:path "~/.config/VSCodium/User/settings.json"}
  {:path "~/.codium/windsurf/settings.json"}]}
```

---

# bb.edn

Add `mk` to paths and a tiny task if you want.

```edn
{:paths ["mk"]
 :tasks {ide {:doc "IDE settings CLI"
              :task (shell "bb -m mk.ide-cli settings doctor --edn config/ide.edn")}}}
```

---

# Commands (exact)

* Doctor first (no writes):

```bash
bb -m mk.ide-cli settings doctor --edn config/ide.edn
```

* Push canonical into all targets (preserving unknown plugin keys):

```bash
bb -m mk.ide-cli settings push-all --edn config/ide.edn
```

* Pull one target into canonical (if you changed settings in Code UI):

```bash
bb -m mk.ide-cli settings pull "~/.config/Code/User/settings.json" --edn config/ide.edn
```

* Sync all (pull-merge each target into canonical, then write back):

```bash
bb -m mk.ide-cli settings sync-all --edn config/ide.edn
```

Merge policy knobs:

```bash
# prefer target on conflicts
bb -m mk.ide-cli settings push-all --edn config/ide.edn --merge-policy prefer-target
```

---

## Notes / gotchas

* **JSONC comments**: we strip them on read and write pure JSON (deterministic). That’s deliberate: fewer diffs, no half-broken comment parsing. If you *must* preserve comments, we can add a token-aware rewriter later.
* **Plugin keys**: push preserves unknown keys by merging target→canonical with a deep merge. Canonical wins on conflicts unless you pass `--merge-policy prefer-target`.
* **Paths**: you can list as many targets as you like; the adapter doesn’t care—it just reads/writes whatever path you give it.

If you want a **schema builder** (union of all `contributes.configuration` from installed extensions), I can tack on a `settings build-schema` that shells out to `code --list-extensions`, scrapes `package.json`, and stores a union map in your EDN so `doctor` can warn on unknown/invalid keys. Low friction to add on top of this.

\#hashtags
#vscode #vscodium #windsurf #jsonc #configSync #clojure #babashka #adapters #doctor #srp

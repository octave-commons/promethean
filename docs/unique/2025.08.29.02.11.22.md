Perfect ask. Here are **surgical rewrites** of the earlier functions, each with their **inline lambdas extracted into higher-order functions** (HOFs). Everything is **async**, **pure-by-contract** (IO injected), **no `for`/`while`**, and each block stands alone so you can cherry-pick.

---

# accumulateEntries (inner loop → HOF reducer)

```js
export function makeEntryReducer({ skipDirs, allowedExts, join, extname }) {
  return (acc, e) => {
    const isDir  = e.isDirectory && e.isDirectory();
    const isFile = e.isFile && e.isFile();

    if (isDir) {
      return skipDirs.has(e.name)
        ? acc
        : { nextStack: acc.nextStack.concat(join(acc.cur, e.name)), files: acc.files };
    }

    if (isFile) {
      const fp = join(acc.cur, e.name);
      return allowedExts.includes(extname(fp).toLowerCase())
        ? { nextStack: acc.nextStack, files: acc.files.concat(fp), cur: acc.cur }
        : acc;
    }

    return acc;
  };
}

export async function accumulateEntries(ents, cur, deps) {
  const reduceEntries = makeEntryReducer(deps);
  const init = { nextStack: [], files: [], cur };
  const { nextStack, files } = ents.reduce(reduceEntries, init);
  return { nextStack, files };
}
```

# walkDir (outer loop → HOF step + safe reader)

```js
export function makeReadDirSafe(readDir) {
  return async (dir) => {
    try { return await readDir(dir); } catch { return []; }
  };
}

export function makeWalkStep({ readDirSafe, join, extname, skipDirs, allowedExts }) {
  return async function step(stack, out) {
    if (stack.length === 0) return out;
    const [cur, ...rest] = stack;
    const ents = await readDirSafe(cur);
    const { nextStack, files } = await accumulateEntries(
      ents,
      cur,
      { skipDirs, allowedExts, join, extname }
    );
    return step(rest.concat(nextStack), out.concat(files));
  };
}

export async function walkDir(root, deps) {
  const readDirSafe = makeReadDirSafe(deps.readDir);
  const step = makeWalkStep({ ...deps, readDirSafe });
  return step([root], []);
}
```

# loadFirstJsonAtRoot (Promise.any source → HOF attempt)

```js
export function makeRootJsonAttempt(root, { join, exists, readFile }) {
  return async (name) => {
    const p = join(root, name);
    if (!(await exists(p))) throw new Error('not-found');
    const raw = await readFile(p, 'utf8');
    return JSON.parse(raw);
  };
}

export async function loadFirstJsonAtRoot(root, names, deps) {
  const attempt = makeRootJsonAttempt(root, deps);
  try { return await Promise.any(names.map(attempt)); }
  catch { return null; }
}

export async function loadTsConfig(root, deps) {
  return loadFirstJsonAtRoot(root, ['tsconfig.json', 'jsconfig.json'], deps);
}
```

# tryResolveFileAsync (candidates builder + sequential finder as HOFs)

```js
export function makeCandidateBuilder({ extname, dirname, join, allowedExts }) {
  return async (absBasePath) => {
    const ext  = extname(absBasePath);
    const stem = ext ? absBasePath.slice(0, -ext.length) : absBasePath;

    const exact      = [absBasePath];
    const stemExts   = allowedExts.map((e) => stem + e);
    const stemIndex  = allowedExts.map((e) => join(stem, 'index' + e));
    const baseNoExt  = ext ? [] : allowedExts.map((e) => absBasePath + e);

    return exact.concat(stemExts, stemIndex, baseNoExt);
  };
}

export function makeFirstExistingReducer(isFile) {
  return async (prevP, p) => {
    const prev = await prevP;
    if (prev) return prev;
    return (await isFile(p)) ? p : null;
  };
}

export async function tryResolveFileAsync(absBasePath, { fs, allowedExts }) {
  const buildCandidates = makeCandidateBuilder({ ...fs, allowedExts });
  const cands = await buildCandidates(absBasePath);
  const reducer = makeFirstExistingReducer(fs.isFile);
  return cands.reduce(reducer, Promise.resolve(null));
}
```

# resolveNearestPackageRoot (no loops; predicate HOF + firstAsync HOF)

```js
export function makeAncestors(dirname) {
  return function ancestors(start) {
    const go = (dir, acc) => {
      const parent = dirname(dir);
      return parent === dir ? acc.concat(dir) : go(parent, acc.concat(dir));
    };
    return go(start, []);
  };
}

export function makeHasPackageJsonPredicate({ join, access }) {
  return async (dir) => access(join(dir, 'package.json'));
}

export function makeFirstAsyncReducer(pred) {
  return async (accP, x) => {
    const acc = await accP;
    if (acc) return acc;
    return (await pred(x)) ? x : null;
  };
}

export async function resolveNearestPackageRoot(startDir, deps) {
  const ancestors = makeAncestors(deps.dirname)(startDir);
  const nearestFirst = ancestors.slice().reverse();
  const pred = makeHasPackageJsonPredicate(deps);
  const reducer = makeFirstAsyncReducer(pred);
  return nearestFirst.reduce(reducer, Promise.resolve(null));
}
```

# resolveOverTargets (findMapAsync as HOF; target mapper injected)

```js
export function makeFindMapReducer(mapper) {
  return async (accP, item) => {
    const acc = await accP;
    if (acc != null) return acc;
    const v = await mapper(item);
    return v == null ? null : v;
  };
}

export function makeTargetMapper(base, { resolve, tryResolveFile }) {
  return async (t) => {
    const abs = resolve(base, t);
    const r = await tryResolveFile(abs);
    return r ? { resolved: r, attemptedAbs: abs } : null;
  };
}

export async function resolveOverTargets(targets, base, deps) {
  const mapper = makeTargetMapper(base, deps);
  const reducer = makeFindMapReducer(mapper);
  return targets.reduce(reducer, Promise.resolve(null));
}
```

# resolveWildcardTargets (star expander HOF + same reducer)

```js
export function makeExpandSingleStar(mid) {
  return (t) => {
    const i = t.indexOf('*');
    return i >= 0 ? (t.slice(0, i) + mid + t.slice(i + 1)) : t;
  };
}

export function makeWildcardMapper(base, mid, { resolve, tryResolveFile }) {
  const expand = makeExpandSingleStar(mid);
  return async (t) => {
    const mapped = expand(t);
    const abs = resolve(base, mapped);
    const r = await tryResolveFile(abs);
    return r ? { resolved: r, attemptedAbs: abs } : null;
  };
}

export async function resolveWildcardTargets(targets, mid, base, deps) {
  const mapper = makeWildcardMapper(base, mid, deps);
  const reducer = makeFindMapReducer(mapper);
  return targets.reduce(reducer, Promise.resolve(null));
}
```

# resolveFromNodeModules (dir-try HOF)

```js
export function makeTryNodeModulesForDir(spec, { dirname, join, existsFile, readJson, tryResolveFile }) {
  return async (dir) => {
    const nm = join(dir, 'node_modules', spec);
    if (!(await existsFile(nm))) return null;

    const pkgPath = join(nm, 'package.json');
    if (await existsFile(pkgPath)) {
      try {
        const pkg = await readJson(pkgPath);
        const entry =
          Array.isArray(pkg.module) ? pkg.module[0]
          : pkg.module || pkg.exports || pkg.main || 'index.js';
        const targetAbs = join(nm, typeof entry === 'string' ? entry : 'index.js');
        const hit = await tryResolveFile(targetAbs);
        if (hit) return hit;
      } catch {}
    }
    return await tryResolveFile(nm);
  };
}

export async function resolveFromNodeModules(spec, startFile, deps) {
  const listAncestors = makeAncestors(deps.dirname);
  const dirs = listAncestors(deps.dirname(startFile)).slice().reverse();
  const tryDir = makeTryNodeModulesForDir(spec, deps);
  const reducer = makeFindMapReducer(tryDir);
  return dirs.reduce(reducer, Promise.resolve(null));
}
```

# levenshtein (both reducers extracted)

```js
export function makeRowReducer(prevRow, ca) {
  return (row, cb, j) => {
    const insert = row[j] + 1;
    const del    = prevRow[j + 1] + 1;
    const subst  = prevRow[j] + (ca === cb ? 0 : 1);
    return row.concat(Math.min(insert, del, subst));
  };
}

export function makeOuterReducer(B) {
  return (prevRow, ca, i) => {
    const rowReducer = makeRowReducer(prevRow, ca);
    return B.reduce(rowReducer, [i + 1]);
  };
}

export async function levenshtein(a, b) {
  const A = [...a], B = [...b];
  const initRow = Array.from({ length: B.length + 1 }, (_, j) => j);
  const outer = makeOuterReducer(B);
  const finalRow = A.reduce(outer, initRow);
  return finalRow[B.length];
}
```

# generic firstAsync with injected predicate (no inline lambdas)

```js
export function makeFirstAsyncReducer(pred) {
  return async (accP, x) => {
    const acc = await accP;
    if (acc != null) return acc;
    return (await pred(x)) ? x : null;
  };
}

export async function firstAsync(items, pred) {
  const reducer = makeFirstAsyncReducer(pred);
  return items.reduce(reducer, Promise.resolve(null));
}
```

---

## Notes

* Every previous inline callback is now a **named HOF product**.
* IO is fully **injected**; test with fakes/mocks trivially.
* Still **loop-free**; composition is via `reduce` + HOFs.

If you want me to **refactor any one call-site** next (e.g., your `ts paths` resolver) to *use* these HOFs, point me to it and I’ll patch just that spot.

\#fp #hof #injection #node #tooling #reuse

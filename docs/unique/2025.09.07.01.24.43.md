Great—let’s lock this into something you can actually run. Below are **role specs**, **artifact schemas**, and **pnpm/CI wiring** so you can prove the “single prompt → minimal back-and-forth → job complete” loop today, then shard to smaller models later.

I’m opinionated here; change names/paths to fit your repo.

# Roles (contract-first)

Each role reads *only* the prior artifacts, plus Nx/MCP tools. No global context.

## 1) planner

**Goal:** Decide *where* the work lands and what’s impacted.
**Inputs:** `GIT_BASE`, `GIT_HEAD`.
**Tools:** `nx affected`, `nx graph`, MCP tools: `nx_workspace`, `nx_project_details`.
**Outputs (files):**

* `artifacts/plan.md` — human-readable plan (why, where, risks).
* `artifacts/affected.json` — precise machine list.

**Process (deterministic shell the bot must call):**

```bash
npx nx affected -t test,build,lint --base="$GIT_BASE" --head="$GIT_HEAD" --plain --select=projects > artifacts/affected.txt
npx nx graph --affected --file=artifacts/graph.html --open=false
node scripts/make-affected-json.js artifacts/affected.txt > artifacts/affected.json
```

Why: `nx affected` maps git diff to projects & dependents; `nx graph --affected` is your blast-radius receipt. ([Nx][1])

**Schema: `artifacts/affected.schema.json`**

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "AffectedProjects",
  "type": "object",
  "properties": {
    "base": { "type": "string" },
    "head": { "type": "string" },
    "projects": { "type": "array", "items": { "type": "string" } }
  },
  "required": ["base", "head", "projects"],
  "additionalProperties": false
}
```

## 2) locator

**Goal:** Enrich `affected.json` with ownership/tags + target details.
**Inputs:** `affected.json`.
**Tools:** MCP: `nx_workspace`, `nx_project_details`.
**Output:** `artifacts/locator.json` (projects → {tags, owners, targets}).

**Schema: `artifacts/locator.schema.json`**

```json
{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "title": "Locator",
  "type": "object",
  "properties": {
    "projects": {
      "type": "array",
      "items": {
        "type": "object",
        "properties": {
          "name": {"type":"string"},
          "tags": {"type":"array","items":{"type":"string"}},
          "owners": {"type":"array","items":{"type":"string"}},
          "targets": {"type":"array","items":{"type":"string"}}
        },
        "required": ["name"]
      }
    }
  },
  "required": ["projects"],
  "additionalProperties": false
}
```

> Nx’s MCP server exposes workspace/project metadata to the assistant so it can *query, not guess*. VS Code/Copilot supports MCP servers; Nx documents the integration and tools. ([Visual Studio Code][2], [Nx][3])

## 3) coder

**Goal:** Make the smallest change that satisfies the plan; only within affected scope unless plan opts out.
**Inputs:** `plan.md`, `locator.json`.
**Tools:** MCP: `nx_generators`, `nx_generator_schema`, `nx_docs`.
**Outputs:** a patch, plus `artifacts/coder-notes.md` (rationale, files touched).

> MCP gives generator discovery & schemas; docs fetch reduces hallucinations for config edits. ([Nx][3])

## 4) verifier

**Goal:** Enforce gates on just the affected set.
**Inputs:** `affected.json`.
**Process (shell):**

```bash
# ESLint gate (strict; no errors, bounded warnings)
npx nx run-many -t lint --projects="$(jq -r '.projects|join(\",\")' artifacts/affected.json)"
# Or execute eslint directly with max warnings if you prefer:
# npx eslint "packages/**" --max-warnings 10
```

ESLint’s exit codes & `--max-warnings` are standardized; wire them to fail the job deterministically. ([ESLint][4], [ESLint - Pluggable JavaScript linter][5])

```bash
# Build & test gate (affected first)
npx nx affected -t build,test --base="$GIT_BASE" --head="$GIT_HEAD"
```

CI should pin `base/head` with `nx-set-shas` for correctness. ([GitHub][6], [Nx][7])

```bash
# Sonar (optional, but ideal for “no new issues on new code”)
# Use your local SonarQube or SonarCloud scanner; enforce Quality Gate on *New Code*.
# Example pseudo-step:
sonar-scanner -Dsonar.qualitygate.wait=true
```

The “Clean as You Code” gate focuses on New Code conditions; that’s your regression contract lever. ([SonarQube Documentation][8])

**Output:** `artifacts/verifier.json` with booleans and deltas.

**Schema: `artifacts/verifier.schema.json`**


## 5) reporter

**Goal:** PR body + receipts.
**Inputs:** `plan.md`, `affected.json`, `verifier.json`, `graph.html`.
**Output:** `artifacts/pr-body.md` with:

* **Scope receipt:** projects list from `affected.json`, link to `graph.html`.
* **Gates receipt:** ESLint exit, test summary, build pass, Sonar “New Code” gate.
* **Risk notes:** from `plan.md`.

# pnpm scripts (flat, deterministic)

`package.json` (at repo root):

```json
{
  "scripts": {
    "ci:prep": "node ./scripts/ci/prepare-env.js",
    "ci:set-shas": "nx-set-shas",
    "ci:plan": "node ./scripts/ci/plan.js",
    "ci:lint": "node ./scripts/ci/lint-affected.js",
    "ci:test": "node ./scripts/ci/test-affected.js",
    "ci:build": "node ./scripts/ci/build-affected.js",
    "ci:sonar": "node ./scripts/ci/sonar.js",
    "ci:report": "node ./scripts/ci/report.js"
  },
  "license": "GPL-3.0-only"
}
```

Minimal versions in `scripts/ci/*.js` should be **pure** wrappers that:

* read inputs from env or artifacts
* call `nx`/tools
* validate JSON schemas
* exit non-zero on contract violation

Example (strict ESLint, bounded warnings):

```js
// scripts/ci/lint-affected.js (ESM)
import { readFileSync } from 'node:fs';
import { execSync } from 'node:child_process';

const affected = JSON.parse(readFileSync('artifacts/affected.json','utf8'));
const projects = affected.projects.join(',');
if (!projects) {
  console.log('No affected projects; skipping lint.');
  process.exit(0);
}

try {
  execSync(`npx nx run-many -t lint --projects="${projects}"`, { stdio: 'inherit' });
  // If you run eslint directly: rely on exit codes & --max-warnings
  // eslint exit codes are 0/1/2 with well-defined semantics.
  // https://eslint.org/docs/latest/use/command-line-interface
} catch (e) {
  process.exit(1);
}
```

ESLint CLI exit codes & `--max-warnings` reference. ([ESLint][4])

# GitHub Actions (proof loop)

`.github/workflows/ci.yml`:

```yaml
name: CI
on:
  pull_request:
  push:
    branches: [main]

jobs:
  main:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      actions: read
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          filter: tree:0

      - uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: 'npm'

      - run: npm ci --legacy-peer-deps

      - name: Set SHAs (Nx)
        uses: nrwl/nx-set-shas@v4

      - name: Plan (affected + graph)
        run: |
          mkdir -p artifacts
          GIT_BASE=${{ env.NX_BASE }} GIT_HEAD=${{ env.NX_HEAD }} \
          pnpm run ci:plan
      - name: Lint
        run: pnpm run ci:lint
      - name: Test
        run: pnpm run ci:test
      - name: Build
        run: pnpm run ci:build
      # Optional Sonar
      - name: SonarQube
        if: ${{ always() }}
        run: pnpm run ci:sonar
      - name: Report
        if: ${{ always() }}
        run: pnpm run ci:report
```

Nx recommends `nx-set-shas` then `nx affected …` to bound work; their docs include a working Actions template. ([Nx][7], [GitHub][6])

# MCP config (editor-side)

**VS Code (Copilot) `mcp.json`** (repo-local `.vscode/mcp.json`):

```json
{
  "mcpServers": {
    "nx": { "command": "npx", "args": ["nx-mcp@latest"] }
  }
}
```

Then teach prompts to call tools by name: `nx_workspace`, `nx_project_details`, `nx_generators`, `nx_generator_schema`, `nx_docs`, `nx_visualize_graph`. VS Code documents MCP server usage; Nx has an “Enhance your LLM” doc. ([Visual Studio Code][2], [Nx][3])

# “One-shot” prompt kit (stateless, replayable)

These are the *only* prompts your big LLM gets; later, swap each with a smaller model.

**planner.prompt**

```
Objective: Propose the smallest viable plan for <TASK>.
Constraints:
- Use nx tools only.
Steps:
1) Call nx_workspace and nx_project_details to map impacted areas.
2) Run `nx affected` with $GIT_BASE/$GIT_HEAD to bound scope.
3) Output artifacts/plan.md (summary, risks) and artifacts/affected.json.
```

**locator.prompt**

```
Objective: Enrich affected.json with tags/owners/targets.
Constraints:
- Use nx_workspace, nx_project_details.
Output: artifacts/locator.json (matches locator.schema.json).
```

**coder.prompt**

```
Objective: Implement plan.md strictly within affected scope unless you justify expansion.
Constraints:
- Use nx_generators/nx_generator_schema when scaffolding.
- Cite nx_docs for any config edits.
Output: patch + artifacts/coder-notes.md.
Fail if touching files outside locator.json.projects without justification.
```

**verifier.prompt**

```
Objective: Validate gates on affected set.
Run:
- ESLint: 0 errors, <= N warnings (fail otherwise).
- Build/Test via nx affected with base/head.
- SonarQube: Quality Gate on New Code must pass; no blocker/critical in new code.
Output: artifacts/verifier.json
```

Sonar “New Code” gate and “Sonar way” are documented and designed for this exact delta gating. ([SonarQube Documentation][8])

**reporter.prompt**

```
Objective: Generate PR body with receipts.
Include:
- Affected projects list, link to artifacts/graph.html
- ESLint/test/build/sonar deltas
- Any scope expansions and reasons
Output: artifacts/pr-body.md
```

# Why this proves your thesis

* **MCP ≈ USB-C for AI tools**: standard tool invocation + narrow, auditable IO. ([Model Context Protocol][9], [spec.modelcontextprotocol.io][10])
* **Nx “affected”** makes the work set *measurable*, letting you enforce a “no-new-regressions-in-new-code” contract without pretending you proved the world. ([Nx][1])
* **Exit codes & gates** (ESLint, test/build, Sonar New Code) are binary and scriptable—exactly what you need to **later shard** into small LLM workers with fixed schemas. ([ESLint][4], [SonarQube Documentation][11])

If you want, I’ll spit out the tiny `scripts/ci/*.js` files and the `make-affected-json.js` helper next, plus an **AVA** test harness for the verifier (so the verifier itself is covered). AVA is fine here—concise, isolated worker model. ([GitHub][12])

[1]: https://nx.dev/ci/features/affected?utm_source=chatgpt.com "Run Only Tasks Affected by a PR"
[2]: https://code.visualstudio.com/docs/copilot/customization/mcp-servers?utm_source=chatgpt.com "Use MCP servers in VS Code"
[3]: https://nx.dev/features/enhance-AI?utm_source=chatgpt.com "Enhance Your LLM - NX Dev"
[4]: https://eslint.org/docs/latest/use/command-line-interface?utm_source=chatgpt.com "Command Line Interface Reference"
[5]: https://archive.eslint.org/docs/2.0.0/user-guide/command-line-interface?utm_source=chatgpt.com "Command Line Interface"
[6]: https://github.com/marketplace/actions/nx-set-shas?utm_source=chatgpt.com "Marketplace - Actions - Nx set SHAs"
[7]: https://nx.dev/ci/recipes/set-up/monorepo-ci-github-actions?utm_source=chatgpt.com "Configuring CI Using GitHub Actions and Nx"
[8]: https://docs.sonarsource.com/sonarqube-server/latest/user-guide/about-new-code/?utm_source=chatgpt.com "Quality standards and new code"
[9]: https://modelcontextprotocol.io/?utm_source=chatgpt.com "Model Context Protocol"
[10]: https://spec.modelcontextprotocol.io/?utm_source=chatgpt.com "Model Context Protocol: Versioning"
[11]: https://docs.sonarsource.com/sonarqube-cloud/standards/about-new-code/?utm_source=chatgpt.com "Quality standards and new code | SonarQube Cloud ..."
[12]: https://github.com/avajs/ava?utm_source=chatgpt.com "avajs/ava: Node.js test runner that lets you develop with ..."

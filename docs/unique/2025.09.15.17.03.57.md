Short answer: **yes—Nx is exactly what you want for “filtering.”** Use `nx affected` to scope builds/tests/lint to only the projects touched by a PR, plus Nx’s caching and (optional) distributed execution to keep it fast.

Here’s how I’d wire it into your *gradient*:

---

# 1) Light tier (AI PRs → `dev/*`): builds only

* Compute base/head SHAs (so `nx affected` knows what changed).
* Run just the build target for affected projects.
* Skip everything else.

```yaml
# .github/workflows/on-pr-to-dev.yml
name: on-pr-to-dev
on: { pull_request: { branches: ['dev/**'] } }
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable && pnpm i --frozen-lockfile

      # Set base/head for Nx "affected" commands
      - uses: nrwl/nx-set-shas@v4
        # sets NX_BASE and NX_HEAD env vars automatically
        # (works for PRs and pushes)

      # Build only what changed
      - run: pnpm nx affected -t build
```

Why this works: `nx-set-shas` provides the proper comparison range; `nx affected` builds only the projects touched between base and head. ([GitHub][1])

---

# 2) Medium tier (`dev/testing`): lint (touched only) + quick tests

* Lint and test only affected projects; still fast but stricter.

```yaml
# .github/workflows/on-pr-to-testing.yml
name: on-pr-to-testing
on: { pull_request: { branches: ['dev/testing'] } }
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable && pnpm i --frozen-lockfile
      - uses: nrwl/nx-set-shas@v4

      - run: pnpm nx affected -t lint
      - run: pnpm nx affected -t test --parallel
```

`nx affected -t lint|test` scopes to just the impacted projects; ideal when most of your suite is red but you still want signal on *changed* pieces. ([Nx][2])

---

# 3) Heavy tier (`dev/staging`): full suite (+ optional DTE)

* Full lint + tests (optionally split by tags/areas), maybe builds, docs transforms.
* If runtime is long, add Nx Cloud **Distributed Task Execution** (agents). ([Nx][3])

```yaml
# .github/workflows/on-pr-to-staging.yml
name: on-pr-to-staging
on: { pull_request: { branches: ['dev/staging'] } }
jobs:
  ci:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4
        with: { fetch-depth: 0 }
      - uses: actions/setup-node@v4
        with: { node-version: 20, cache: pnpm }
      - run: corepack enable && pnpm i --frozen-lockfile
      - uses: nrwl/nx-set-shas@v4

      # Optional: spin up Nx Cloud agents to parallelize
      # - run: npx nx start-ci-run --distribute-on="3 linux-medium-js" --stop-agents-after="build"

      - run: pnpm nx affected -t lint test build
```

Nx’s CI recipe shows this exact pattern (checkout, set SHAs, run affected; optionally start agents). ([Nx][4])

---

# 4) Release (`main`): same as heavy + docs/obsidian transforms

* Keep `nx affected` for code.
* Run your Obsidian → Markdown conversion & link checks as a separate project/target and include it here (or on `obsidian/staging`), potentially using `run-many` if you need to process everything.

---

## Make “affected” accurate: inputs & implicit deps

For the filters to be *correct*, tell Nx what “counts” as input:

* **Named Inputs / Inputs**: control the hash and therefore cache/affected detection (e.g., include config files, schema, generated types). This ensures Nx reruns targets when *relevant* non-source files change. ([Nx][5])
* **Implicit dependencies** (per-project): if a docs app depends on a generator or a shared config that Nx can’t infer, add `implicitDependencies` in that project’s `project.json`/`package.json`. (Global implicit deps are deprecated—prefer named inputs for globals.) ([Nx][6])

This is what lets you say “if `obsidian/**` changed, the `docs` project is affected,” or “if `eslint.config.js` changed, re-run lint for everyone.”

---

## Why Nx is better than ad-hoc path filters here

* **Project-graph aware**: It doesn’t just look at changed paths; it maps those files to projects and their *dependencies*, so transitive dependents get rebuilt/tested when needed. ([Nx][7])
* **Caching**: Computation hashing + remote cache = replays past results when inputs didn’t change. Huge time saver as your suite grows. ([Nx][8])
* **DTE**: If/when you’re ready, Nx Cloud can distribute tasks across agents without you hand-sharding jobs. ([Nx][3])

---

## Hooking into your gradient

* **AI PRs → `dev/stealth`**: only `nx affected -t build` (green check = “won’t break sandbox”).
* **`dev/testing`**: add `lint`+`test` on affected only.
* **`dev/staging`**: full lint/test/build (affected or all), optional DTE.
* **`main`**: as above + docs/obsidian targets, releases.

Use **branch protection** to require the right check per branch (only “light” on `dev/**`, “medium” on `dev/testing`, etc.). ([Nx][4])

---

If you want, I can tailor the `nx.json`/`project.json` with concrete `namedInputs` for your repo (e.g., include Obsidian patterns), and wire up an `obsidian:export` target so it participates in `nx affected` like any other project.

[1]: https://github.com/marketplace/actions/nx-set-shas?utm_source=chatgpt.com "Marketplace - Actions - Nx set SHAs"
[2]: https://nx.dev/reference/core-api/nx/documents/affected?utm_source=chatgpt.com "affected - CLI command"
[3]: https://nx.dev/ci/features/distribute-task-execution?utm_source=chatgpt.com "Distribute Task Execution (Nx Agents)"
[4]: https://nx.dev/ci/recipes/set-up/monorepo-ci-github-actions?utm_source=chatgpt.com "Configuring CI Using GitHub Actions and Nx"
[5]: https://nx.dev/reference/inputs?utm_source=chatgpt.com "Inputs and Named Inputs"
[6]: https://nx.dev/reference/project-configuration?utm_source=chatgpt.com "Project Configuration"
[7]: https://nx.dev/ci/features/affected?utm_source=chatgpt.com "Run Only Tasks Affected by a PR"
[8]: https://nx.dev/concepts/how-caching-works?utm_source=chatgpt.com "How Caching Works"

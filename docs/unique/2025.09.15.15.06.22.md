# Github Branching Workflow

- **Branches:**
  - `chore/<task>`, `codex/<task>` go to `main`.
  
- **Development Setup:**
  - Use multiple computers (`stealth` and `yoga`) for development.
  - Changes flow from `dev/<hostname>` to `testing`, then `staging`, and finally
    `main`.

- **Typical Workflow:**
  1. `codex/<task>` -> `dev/<hostname>` -> `main`
  2. `feat/codex-<task>` indicates Codex started work.
  3. `<type>/<task>` branches for specific tasks.

- **Branching Rules:**
  - Prefixed with `codex/` indicate Codex responsibility.
  - Others are my responsibility unless default merging causes issues.

- **Obsidian Workflow:**
  1. `obsidian/<hostname>` -> `dev/<hostname>` -> `main`
  2. Ideal flow: `<describer>/<task>` -> `dev/testing` -> `dev/staging` ->
     `main`

- **Documentation Flow:**
  1. `<codex|docs|readme|etc>/<task>` -> `obsidian/<hostname>` ->
     `obsidian/staging` -> `main`
  2. Staging branch uses GitHub Actions for transformations.

## Diagram

```mermaid
graph TD;
    codexTask[feat/codex-<task>] --> dev/stealth
    dev/stealth --> main
    describerTask[<describer>/<task>] --> dev/testing
    dev/testing --> dev/staging
    dev/staging --> main
    docsTask[codex|docs|readme|etc/<task>] --> obsidian/<hostname>
    obsidian/<hostname> --> obsidian/staging
    obsidian/staging --> main
```

This diagram shows how tasks progress from initial development to the `main`
branch, ensuring a structured and systematic approach.

## Merging Rules

I want increasingly more involved checks as the process gets closer to main.
For merges into staging.

### Feature -> `dev/tesing` or `dev/<hostname>`

To merge into `dev/testing` or `dev/hostname` a PR must build and install, that is the only requirement.
Otherwise I want it to be green.

## From `dev/testing` -> `dev/staging`

To merge into staging, at least there are no linting errors on the touched diffs.
And there are no tests failing along the changed paths.
Only `dev/testing` and `dev/<hostname` branches may merge into `dev/staging`.
I think this is what NX helps us do? Limit testing etc to only the code that has changed?
No E2E tests, no integration tests, just unit tests. Mocked data, etc.

## From `dev/staging` -> `dev/main`

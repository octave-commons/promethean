ðŸ”¥ heck yes â€” thatâ€™s a huge unlock. With Chroma + Ollama running in the sandbox, Playwright installed, and your e2e/integration harnesses in place, letâ€™s lock in a **minimal, idempotent E2E kit** you can drop in and iterate fast.

# Flow (at a glance)

```mermaid
flowchart LR
  A[Playwright global setup] --> B[Service health checks]
  B -->|fast-fail| X[[Abort run]]
  B --> C[Optional seed step (no-op if cached)]
  C --> D[Run E2E + Integration specs]
  D --> E[Artifacts + caches in .cache/e2e]
```

---

## 1) New package scaffold (TypeScript, idempotent, cache-aware)

**`packages/e2e-kit/package.json`**

```json
{
  "name": "@promethean/e2e-kit",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.js",
  "bin": {
    "e2e-kit": "dist/cli.js"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rimraf dist .cache",
    "dev": "tsx src/cli.ts"
  },
  "dependencies": {
    "tiny-invariant": "^1.3.3"
  },
  "devDependencies": {
    "tsx": "^4.19.0",
    "typescript": "^5.4.5",
    "rimraf": "^6.0.1"
  }
}
```

**`packages/e2e-kit/tsconfig.json`**

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "resolveJsonModule": true,
    "declaration": true,
    "skipLibCheck": true,
    "strict": true
  },
  "include": ["src"]
}
```

---

## 2) Health checks that work across Chroma variants + Ollama

Robust, multi-endpoint probes (accept 2xx/3xx/4xx as â€œresponsiveâ€, treat 5xx/ENOTFOUND/ECONNREFUSED as down). Caches the last known-good endpoint in `.cache/e2e/` so retries get faster.

**`packages/e2e-kit/src/health/common.ts`**

```ts
import fs from "node:fs/promises";
import path from "node:path";

const CACHE_DIR = path.resolve(process.cwd(), ".cache/e2e");
await fs.mkdir(CACHE_DIR, { recursive: true }).catch(() => {});

export async function writeJson(file: string, data: unknown) {
  await fs.writeFile(path.join(CACHE_DIR, file), JSON.stringify(data, null, 2), "utf8");
}
export async function readJson<T>(file: string): Promise<T | null> {
  try {
    const raw = await fs.readFile(path.join(CACHE_DIR, file), "utf8");
    return JSON.parse(raw) as T;
  } catch { return null; }
}

export type ProbeResult = { ok: boolean; url?: string; status?: number; reason?: string };

export async function probeAny(base: string, paths: string[]): Promise<ProbeResult> {
  for (const p of paths) {
    const url = `${base.replace(/\/+$/, "")}/${p.replace(/^\/+/, "")}`;
    try {
      const res = await fetch(url, { method: "GET" });
      // Treat 2xx/3xx/4xx as "the server is alive"; only 5xx is considered down
      if (res.status < 500) return { ok: true, url, status: res.status };
    } catch (e: any) {
      // keep trying others
    }
  }
  return { ok: false, reason: `No responsive paths on ${base}` };
}
```

**`packages/e2e-kit/src/health/chroma.ts`**

```ts
import { probeAny, writeJson, readJson, ProbeResult } from "./common.js";

const DEFAULT_BASE = process.env.CHROMA_URL ?? "http://127.0.0.1:8000";
const CANDIDATES = [
  "/", "/docs", "/openapi.json",
  "/api/v1/heartbeat", "/api/v1/health", "/heartbeat", "/health", "/healthz"
];

export type ChromaHealth = { ok: boolean; base: string; url?: string; status?: number; reason?: string };

export async function chromaHealth(): Promise<ChromaHealth> {
  const cache = await readJson<ChromaHealth>("chroma-health.json");
  const base = DEFAULT_BASE;
  if (cache?.ok && cache.base === base) {
    // quick recheck the cached good URL
    if (cache.url) {
      try {
        const res = await fetch(cache.url);
        if (res.status < 500) return cache;
      } catch {}
    }
  }
  const r: ProbeResult = await probeAny(base, CANDIDATES);
  const out: ChromaHealth = { ok: r.ok, base, url: r.url, status: r.status, reason: r.reason };
  await writeJson("chroma-health.json", out);
  return out;
}
```

**`packages/e2e-kit/src/health/ollama.ts`**

```ts
import { writeJson, readJson, ProbeResult, probeAny } from "./common.js";

const DEFAULT_BASE = process.env.OLLAMA_URL ?? "http://127.0.0.1:11434";
const CANDIDATES = ["/", "/api/version", "/api/tags"];

export type OllamaHealth = { ok: boolean; base: string; url?: string; status?: number; reason?: string; version?: string };

export async function ollamaHealth(): Promise<OllamaHealth> {
  const cache = await readJson<OllamaHealth>("ollama-health.json");
  const base = DEFAULT_BASE;

  // quick check cached good endpoint first
  if (cache?.ok && cache.base === base && cache.url) {
    try {
      const res = await fetch(cache.url);
      if (res.status < 500) return cache;
    } catch {}
  }

  const r: ProbeResult = await probeAny(base, CANDIDATES);
  const out: OllamaHealth = { ok: r.ok, base, url: r.url, status: r.status, reason: r.reason };

  // Try to read version for nicer logs (best-effort)
  try {
    const ver = await fetch(`${base}/api/version`, { method: "GET" });
    if (ver.ok) out.version = await ver.text();
  } catch {}

  await writeJson("ollama-health.json", out);
  return out;
}
```

---

## 3) Tiny CLI + Playwright global setup

**`packages/e2e-kit/src/cli.ts`**

```ts
#!/usr/bin/env node
import { chromaHealth } from "./health/chroma.js";
import { ollamaHealth } from "./health/ollama.js";

async function main() {
  const cmd = process.argv[2] ?? "health";
  if (cmd === "health") {
    const [c, o] = await Promise.all([chromaHealth(), ollamaHealth()]);
    if (!c.ok) {
      console.error("[e2e-kit] Chroma not healthy:", c);
      process.exitCode = 1;
    } else {
      console.log("[e2e-kit] Chroma OK:", c.url ?? c.base, c.status ?? "");
    }
    if (!o.ok) {
      console.error("[e2e-kit] Ollama not healthy:", o);
      process.exitCode = 1;
    } else {
      console.log("[e2e-kit] Ollama OK:", o.url ?? o.base, o.version ?? "");
    }
    return;
  }
  console.error(`Unknown command: ${cmd}`);
  process.exitCode = 2;
}
main().catch((e) => { console.error(e); process.exit(1); });
```

**`packages/e2e-kit/src/playwright/global-setup.ts`**

```ts
import { chromaHealth } from "../health/chroma.js";
import { ollamaHealth } from "../health/ollama.js";

export default async function globalSetup() {
  const [c, o] = await Promise.all([chromaHealth(), ollamaHealth()]);
  if (!c.ok) throw new Error(`Chroma not healthy: ${c.reason ?? c.status}`);
  if (!o.ok) throw new Error(`Ollama not healthy: ${o.reason ?? o.status}`);
  // Optional: warm a trivial generate to ensure model loaded (best-effort)
  try {
    await fetch((process.env.OLLAMA_URL ?? "http://127.0.0.1:11434") + "/api/generate", {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({
        model: process.env.OLLAMA_MODEL ?? "qwen2.5:0.5b-instruct",
        prompt: "ok",
        stream: false,
        options: { num_predict: 8 }
      })
    });
  } catch { /* non-fatal; some environments pull model lazily */ }
}
```

> This **does not assume** specific Chroma routes beyond being responsive, so it wonâ€™t flap on minor version differences. You can tighten the health criteria later once your server endpoints stabilize.

---

## 4) Wire it into your existing Playwright harness

Assuming you already have a `playwright.config.ts` in the repo root, just point `globalSetup` at the new module and add an env contract.

**`playwright.config.ts` (snippet)**

```ts
import { defineConfig } from "@playwright/test";

export default defineConfig({
  timeout: 120_000,
  expect: { timeout: 10_000 },
  reporter: [["list"], ["html", { open: "never" }]],
  globalSetup: "./packages/e2e-kit/dist/playwright/global-setup.js",
  use: {
    headless: true,
    baseURL: process.env.E2E_BASE_URL ?? "http://127.0.0.1:8787"
  }
});
```

**PNPM scripts (root `package.json`)**

```json
{
  "scripts": {
    "e2e:build": "pnpm -F @promethean/e2e-kit build",
    "e2e:health": "pnpm -F @promethean/e2e-kit dev health",
    "e2e": "pnpm e2e:build && pnpm -s e2e:health && playwright test"
  }
}
```

> If you use Nx, wrap these in an Nx target for caching/distribution. The health step is fast and idempotent; it reads `.cache/e2e/*` between runs.

---

## 5) Two smoke tests to start moving fast

### A. Service liveness (no assumptions beyond â€œrespondsâ€)

**`e2e/service-health.spec.ts`**

```ts
import { test, expect } from "@playwright/test";

test("chroma responds", async ({ request }) => {
  const base = process.env.CHROMA_URL ?? "http://127.0.0.1:8000";
  const res = await request.get(base);
  expect(res.status()).toBeLessThan(500);
});

test("ollama has tags or version", async ({ request }) => {
  const base = process.env.OLLAMA_URL ?? "http://127.0.0.1:11434";
  const ver = await request.get(`${base}/api/version`);
  const tags = await request.get(`${base}/api/tags`);
  expect(ver.status() < 500 || tags.status() < 500).toBeTruthy();
});
```

### B. Minimal model round-trip (tiny generate)

**`e2e/ollama-generate.spec.ts`**

```ts
import { test, expect } from "@playwright/test";

test("ollama generate returns JSON with response", async ({ request }) => {
  const base = process.env.OLLAMA_URL ?? "http://127.0.0.1:11434";
  const model = process.env.OLLAMA_MODEL ?? "qwen2.5:0.5b-instruct";
  const r = await request.post(`${base}/api/generate`, {
    data: { model, prompt: "Say 'ok'.", stream: false, options: { num_predict: 8 } }
  });
  expect(r.ok()).toBeTruthy();
  const json = await r.json();
  expect(typeof json?.response).toBe("string");
  expect(json.response.length).toBeGreaterThan(0);
});
```

> If your sandbox images donâ€™t have the specific model pre-pulled, keep `num_predict` tiny as above; your warm-up in `global-setup` helps amortize.

---

## 6) Env contract (simple, explicit)

* `CHROMA_URL` (default `http://127.0.0.1:8000`)
* `OLLAMA_URL` (default `http://127.0.0.1:11434`)
* `OLLAMA_MODEL` (default `qwen2.5:0.5b-instruct` â€” change to your tiniest)

Put these in your `.envrc`/CI secrets as fits your flow.

---

## 7) Nice-to-have next (quick wins)

* Add a **`seed`** subcommand that no-ops if `.cache/e2e/chroma-seed.json` exists. (When youâ€™re ready to lock the Chroma API shape youâ€™re on, Iâ€™ll wire a tiny REST seed thatâ€™s tolerant to 0.4/0.5 differences.)
* Add an **Nx target** `e2e` with caching keyed on `packages/**` and the Playwright tests to avoid re-running when nothing changed.
* Make a tiny **static preview server** (or reuse your existing one) behind an `e2e:webServer` Playwright config entry for any UI flows.

---

If you want, I can extend this with a **RAG smoke** (`seed â†’ query â†’ assert non-empty ctx â†’ single-shot answer`) once you confirm which Chroma API version youâ€™ve standardized on in the sandbox. For now, this kit gives you a fast, reliable gate with **zero edits to existing code** and **everything idempotent + cached**.
Love it. Since youâ€™re running **AVA + Playwright (core)** and you already have harnesses, hereâ€™s a tiny **TypeScript helper package** you can drop in to replace the brittle parts of that bash with **idempotent, cache-aware health + warm utilities**. No Playwright Test involved.

```mermaid
flowchart LR
  A[AVA before hook] --> B[ensureHealthy()]
  B --> C[warmOllama()]
  C --> D[run your existing AVA specs]
  B -.cache/.cache/e2e..-> B
```

## Drop-in package: `packages/e2e-ava-kit`

### `package.json`

```json
{
  "name": "@promethean/e2e-ava-kit",
  "version": "0.1.0",
  "private": true,
  "type": "module",
  "main": "dist/index.js",
  "exports": {
    ".": "./dist/index.js"
  },
  "scripts": {
    "build": "tsc -p tsconfig.json",
    "clean": "rimraf dist .cache"
  },
  "dependencies": {
    "tiny-invariant": "^1.3.3"
  },
  "devDependencies": {
    "typescript": "^5.6.2",
    "rimraf": "^6.0.1"
  }
}
```

### `tsconfig.json`

```json
{
  "$schema": "https://json.schemastore.org/tsconfig",
  "extends": "../../tsconfig.base.json",
  "compilerOptions": {
    "outDir": "dist",
    "rootDir": "src",
    "module": "NodeNext",
    "moduleResolution": "NodeNext",
    "target": "ES2022",
    "strict": true,
    "skipLibCheck": true,
    "resolveJsonModule": true,
    "declaration": true
  },
  "include": ["src"]
}
```

### `src/cache.ts`

```ts
import { promises as fs } from "node:fs";
import path from "node:path";

const CACHE_DIR = path.resolve(process.cwd(), ".cache/e2e");
export async function ensureCacheDir() {
  try { await fs.mkdir(CACHE_DIR, { recursive: true }); } catch {}
  return CACHE_DIR;
}
export async function writeJson(file: string, data: unknown) {
  const dir = await ensureCacheDir();
  await fs.writeFile(path.join(dir, file), JSON.stringify(data, null, 2), "utf8");
}
export async function readJson<T>(file: string): Promise<T | null> {
  try {
    const dir = await ensureCacheDir();
    return JSON.parse(await fs.readFile(path.join(dir, file), "utf8")) as T;
  } catch { return null; }
}
```

### `src/health.ts`

```ts
type ProbeResult = { ok: boolean; url?: string; status?: number; reason?: string };
const okish = (s: number) => s < 500; // treat 2xx/3xx/4xx as "responsive"

async function probeAny(base: string, paths: string[]): Promise<ProbeResult> {
  for (const p of paths) {
    const url = `${base.replace(/\/+$/, "")}/${p.replace(/^\/+/, "")}`;
    try {
      const res = await fetch(url, { method: "GET" });
      if (okish(res.status)) return { ok: true, url, status: res.status };
    } catch { /* keep trying */ }
  }
  return { ok: false, reason: `No responsive paths on ${base}` };
}

export async function chromaHealth(base = process.env.CHROMA_URL ?? "http://127.0.0.1:8000") {
  // supports both v2 and older v1 endpoints
  const r = await probeAny(base, [
    "/api/v2/heartbeat", "/api/v1/heartbeat", "/heartbeat", "/health", "/"
  ]);
  return { base, ...r };
}

export async function ollamaHealth(base = process.env.OLLAMA_URL ?? "http://127.0.0.1:11434") {
  const r = await probeAny(base, ["/api/tags", "/api/version", "/"]);
  let version: string | undefined;
  try {
    const ver = await fetch(`${base}/api/version`);
    if (ver.ok) version = await ver.text();
  } catch {}
  return { base, ...r, version };
}
```

### `src/warm.ts`

```ts
// Best-effort warm-up so first generate in tests is fast.
export async function warmOllama(opts?: { model?: string; base?: string }) {
  const base = opts?.base ?? process.env.OLLAMA_URL ?? "http://127.0.0.1:11434";
  const model = opts?.model ?? process.env.OLLAMA_MODEL ?? "qwen2.5:0.5b-instruct";
  try {
    await fetch(`${base}/api/generate`, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ model, prompt: "ok", stream: false, options: { num_predict: 8 } })
    });
  } catch { /* non-fatal */ }
}
```

### `src/embeddings.ts`

```ts
export async function embedWithOllama(texts: string[], model = "nomic-embed-text", base?: string) {
  const url = (base ?? process.env.OLLAMA_URL ?? "http://127.0.0.1:11434") + "/api/embeddings";
  const out: number[][] = [];
  for (const prompt of texts) {
    const r = await fetch(url, {
      method: "POST",
      headers: { "content-type": "application/json" },
      body: JSON.stringify({ model, prompt })
    });
    if (!r.ok) throw new Error(`Embeddings failed: ${r.status} ${await r.text()}`);
    const j = await r.json() as { embedding: number[] };
    out.push(j.embedding);
  }
  return out;
}
```

### `src/index.ts`

```ts
export { chromaHealth, ollamaHealth } from "./health.js";
export { warmOllama } from "./warm.js";
export { embedWithOllama } from "./embeddings.js";
```

---

## Wire into your **AVA harness**

Wherever you centralize AVA hooks:

```ts
// tests/_setup.ts
import test from "ava";
import { chromaHealth, ollamaHealth, warmOllama } from "@promethean/e2e-ava-kit";

test.before(async t => {
  const [c, o] = await Promise.all([chromaHealth(), ollamaHealth()]);
  if (!c.ok) t.fail(`Chroma not healthy: ${c.reason ?? c.status} @ ${c.base}`);
  if (!o.ok) t.fail(`Ollama not healthy: ${o.reason ?? o.status} @ ${o.base}`);
  await warmOllama(); // best-effort; non-fatal even if skipped
});
```

Example smoke specs (adjust to your layout):

```ts
// tests/00-health.test.ts
import test from "ava";
import { chromaHealth, ollamaHealth } from "@promethean/e2e-ava-kit";

test("chroma responds", async t => {
  const c = await chromaHealth();
  t.true(!!c.ok, `Chroma not healthy: ${c.reason ?? c.status} ${c.base}`);
});

test("ollama is up", async t => {
  const o = await ollamaHealth();
  t.true(!!o.ok, `Ollama not healthy: ${o.reason ?? o.status} ${o.base}`);
});
```

```ts
// tests/01-ollama-generate.test.ts
import test from "ava";

test("tiny generate", async t => {
  const base = process.env.OLLAMA_URL ?? "http://127.0.0.1:11434";
  const model = process.env.OLLAMA_MODEL ?? "qwen2.5:0.5b-instruct";
  const r = await fetch(`${base}/api/generate`, {
    method: "POST",
    headers: { "content-type": "application/json" },
    body: JSON.stringify({ model, prompt: "Say 'ok'.", stream: false, options: { num_predict: 8 } })
  });
  t.true(r.ok, `generate failed: ${r.status}`);
  const j = await r.json();
  t.is(typeof j.response, "string");
  t.true(j.response.length > 0);
});
```

```ts
// tests/02-embeddings.test.ts
import test from "ava";
import { embedWithOllama } from "@promethean/e2e-ava-kit";

test("nomic-embed-text returns a vector", async t => {
  const [vec] = await embedWithOllama(["hello"]);
  t.true(Array.isArray(vec));
  t.true(vec.length > 0);
});
```

> All of this respects your env contract:
> `CHROMA_URL` (defaults `http://127.0.0.1:8000`), `OLLAMA_URL` (defaults `http://127.0.0.1:11434`), `OLLAMA_MODEL` (defaults `qwen2.5:0.5b-instruct`).

---

## Optional: keep your bash but **de-risk** it quickly

Two quick tweaks you can apply immediately:

```bash
# 1) Accept both v1 and v2 heartbeats to tolerate image drift
until curl -fsS "${CHROMA_URL:-http://127.0.0.1:8000}/api/v2/heartbeat" >/dev/null \
   || curl -fsS "${CHROMA_URL:-http://127.0.0.1:8000}/api/v1/heartbeat" >/dev/null \
   || curl -fsS "${CHROMA_URL:-http://127.0.0.1:8000}/heartbeat" >/dev/null ; do
  sleep 1
done

# 2) Pull ultra-tiny models only; keep num_predict tiny in tests
ollama pull "${OLLAMA_MODEL:-qwen2.5:0.5b-instruct}"
ollama pull nomic-embed-text
```

---

If you want, Iâ€™ll add a tiny **Chroma seed helper** next (detects v2 vs v1, creates/gets a collection, adds a couple of embedded docs via Ollama, queries back) so you can flip on a one-shot **RAG smoke** in AVA without changing your harness.
